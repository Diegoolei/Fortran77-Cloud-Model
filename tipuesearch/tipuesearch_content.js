var tipuesearch = {"pages":[{"title":" cloud_model ","text":"cloud_model CloudModel Table of Contents Python Instalation Usage Features Extra Functionality Requirements Fortran for devs F2Py Integration Fortran-only compiling gfortran nvfortran Installation Contributing License CloudModel This repository hosts the re-engineered cloud simulation model, now implemented in Fortran 90 and wrapped for Python integration. Below are the instructions for setting up and running the model, as well as additional requirements for animation functionality and compilation with different Fortran compilers. Table of Contents Python Installation Usage Extra Functionality Requirements Fortran Fortran Only F2Py Contributing License Python Instalation To install as a pip package: pip install -i https://test.pypi.org/simple/ cloudmodel Usage To run the model, first import it from the library from cloudmodel import CloudModel and call it with the desired parameters CloudModel ( simulation_time_minutes , #(int): The total simulation time in minutes. save_time_minutes , # (int): The time interval in minutes at which the model state is saved. statistic_time_minutes , # (int): The time interval in minutes at which statistics are calculated. bacup_time_minutes , # (int): The time interval in minutes at which backups are created. ) When the model finishes running there will be a new directory, where all the output data from the simulation will be stored. The following section describes all the functions that can be applied to those simulation results. Features class FileStyle : \"\"\"A class representing the file style for cloud data. Attributes: chosen_file (str): The chosen input file type. output_data_path (str): The path to the output data folder. cmp_output_data_path (str): The path to the comparison output data folder. img_path (str): The path to the image folder. txt_path (str): The path to the text folder. cmp_txt_path (str): The path to the comparison text folder. vid_path (str): The path to the video folder. img_option (str): The image style option. folder_handle (str): The folder handling option. Methods: _get_data(): Get the data from the selected files. _get_var_from_data(file_number, var_iterator): Get a specific variable from the data. list_var(): List all the variables. get_var(var, time): Get a specific variable at a given time. show_var_dataframe(var_array, center, axis): Show the variable data as a DataFrame. center_var(var_array, center, axis): Center the variable data along a specific axis. get_var_max_value_position(var_array): Get the position of the maximum value in the variable data. check_path(path, selected_file_name): Check if the path exists and create it if necessary. cloud_binary_comparison(): Compare the binary files in the output data and comparison output data folders. live_var_animation(variable): Create a live animation of a variable. plot_style(variable): Plot the style of a variable. generate_image(frame, var_number): Generate an image for a specific frame and variable. animate_variables(var_list, save_animation, show_animation): Animate multiple variables. animate_variable(var_to_animate, save_animation, show_animation, check_path): Animate a specific variable. parse_status_img(): Parse the status images. multi_var_img(var_1, var_2, file=\"inis.da\"): Create an image with multiple variables. show_file_diff(file): Show the differences between two text files. cloud_text_comparison(): Compare text files in the specified paths and display the differences, if any. get_unequal_files(): Get the unequal files between two folders. parse_text_files(): Parse the text files. \"\"\" A run + image generation for all variables to all the simulated times would look like this: from cloudmodel import CloudModel CloudModel ( simulation_time_minutes = 45 , save_time_minutes = 3 , statistic_time_minutes = 3 , bacup_time_minutes = 3 , ) cloud = FileStyle ( chosen_file = \"Nube\" , output_data_path = \"Data/new_code/\" , cmp_output_data_path = \"outputdata1/\" , img_path = \"img/new_code/\" , txt_path = \"txt/\" , cmp_txt_path = \"txt1/\" , vid_path = \"vid/\" , img_option = \"Contour\" , folder_handle = \"Delete\" , ) cloud . parse_status_img () theta_base = cloud . get_var ( cloud . var_list [ 3 ]) cloud . show_var_dataframe ( theta_base , 3 ) Extra Functionality Requirements To display animations, follow these steps: Install ffmpeg : console\nsudo apt install ffmpeg If you’re using Windows Subsystem for Linux (WSL), you can show Matplotlib plots and other GUI elements by following these steps : Install Xming X Server for Windows . Run the following command in your WSL2 terminal: console\n  sudo apt-get install python-tk Fortran for devs This section is focused on the steps needed to re-compile the model to mantain usability with the Python package. F2Py Integration To compile for F2Py, follow these steps: Navigate to the interface directory: console\ncd interface Compile using make : console\nmake Fortran-only compiling gfortran Linux: Install gfortran : sudo apt install gfortran MacOS: Install gfortran using Homebrew: brew install gfortran xcode-select --install Execution: Run the following command with fpm : fpm run --profile release nvfortran Installation Install the appropriate Nvidia drivers for your system. Install the Nvidia CUDA toolkit . Install the Nvidia HPC SDK . The installation path is usually /opt/nvidia/hpc_sdk/Linux_x86_64/(version)/compilers/bin . Add it to your PATH. Execution: Run the following command with fpm : fpm run --compiler \"/opt/nvidia/hpc_sdk/Linux_x86_64/(version)/compilers/bin/nvfortran\" --flag \"-O3 -cuda\" Contributing Fork the repository. Create a new branch: git checkout -b feature-name . Make your changes. Push your branch: git push origin feature-name . Create a pull request. License This project is licensed under the MIT License . Developer Info Diego E. Oleiarz Computer science student.","tags":"home","loc":"index.html"},{"title":"init_config – cloud_model","text":"public  subroutine init_config(sim_time, save_lapse, statistic_time, backup_time, restore_from_backup, directory) Initializes the configuration for the simulation. Arguments Type Intent Optional Attributes Name real, intent(in) :: sim_time simulation time in minutes real, intent(in) :: save_lapse save lapse in minutes real, intent(in) :: statistic_time statistic time in minutes real, intent(in) :: backup_time backup time in minutes logical, intent(in) :: restore_from_backup restore backup character(len=*), intent(in) :: directory","tags":"","loc":"proc/init_config.html"},{"title":"velpre01_init – cloud_model","text":"public  subroutine velpre01_init() Uses dimensions Arguments None","tags":"","loc":"proc/velpre01_init.html"},{"title":"TT_f – cloud_model","text":"public  function TT_f(z_aux) Arguments Type Intent Optional Attributes Name real(kind=4), intent(in) :: z_aux Return Value real Variables Type Visibility Attributes Name Initial real, public :: a real, public :: xx","tags":"","loc":"proc/tt_f.html"},{"title":"PP – cloud_model","text":"public  subroutine PP(G, Rd, dx, nz1, Pres, Pres0) Arguments Type Intent Optional Attributes Name real :: G real :: Rd real :: dx integer :: nz1 real :: Pres (-3:nz1+3) real :: Pres0 Variables Type Visibility Attributes Name Initial real, public :: dx4 real, public :: integ (-2:nx4+2) integer, public :: k integer, public :: nx4 real, public :: ya real, public :: yd real, public :: ym real, public :: zetaa real, public :: zetad real, public :: zetam","tags":"","loc":"proc/pp.html"},{"title":"PP2 – cloud_model","text":"public  subroutine PP2(G, dx, air_density_z_initial, Pres00, Pres0) Uses dimensions Arguments Type Intent Optional Attributes Name real :: G real :: dx real :: air_density_z_initial (-3:nz1+3) real :: Pres00 (-3:nz1+3) real :: Pres0 Variables Type Visibility Attributes Name Initial real, public :: Den00 (-3:3*nz1+3) real, public :: integ (-3:3*nz1+3) integer, public :: k real, public :: ya real, public :: yd real, public :: ym","tags":"","loc":"proc/pp2.html"},{"title":"initial_conditions – cloud_model","text":"public  subroutine initial_conditions() Uses cant01 dimensions config constants dinamic_var_perturbation microphysics_perturbation initial_z_state Condiciones iniciales para las variables dinamicas Corresponde a una nube con hielo Calcula la presion inicial en forma iterativa , primero supone aire seco y luego integra considerando la densidad total , incluyendo el vapor . Solo hay una perturbacion en temperatura para iniciar la conveccion Incluye viento de corte , tipo frente calculo de ‘constantes’ que dependen de T condiciones de tiempo bueno\n TT_f not pure function, do concurrent not allowed Velocidad terminal para gota de lluvia, cte que depende de P Velocidad terminal para la nieve, cte que depende de P Velocidad terminal para el granizo, cte que depende de z Recalculo de la Presion y de Tita\nRecalculo de la Presion a partir de la densidad Arguments None Variables Type Visibility Attributes Name Initial real, public :: aerosol_max_perturbation = 10000. Maximum aerosol perturbation real, public :: aerosol_total real, public :: aux real, public :: base_horizontal_velocity real, public :: celcius_temperature_aux real, public :: cubic_lv_saturation real, public :: cubic_sv_saturation real, public :: gaussian integer, public :: i real, public :: initial_x_perturbation = (nx1+1.)*dx1/2. Initial disturbance’s x-coordinate real, public :: initial_y_perturbation = (nx1+1.)*dx1/2. Initial disturbance’s y-coordinate real, public :: initial_z_perturbation = 0. Initial disturbance’s z-coordinate real, public :: intercept_lv_saturation real, public :: intercept_sv_saturation integer, public :: j integer, public :: k real, public :: latent_heat_exponent_aux integer, public :: n real, public :: perturbation_width = 2000. perturbation_width real, public :: quadratic_lv_saturation real, public :: quadratic_sv_saturation real, public :: quartic_lv_saturation real, public :: quartic_sv_saturation real, public :: quintic_lv_saturation real, public :: quintic_sv_saturation real, public :: relative_humidity_aux real, public :: sat_press_lv_aux real, public :: sextic_lv_saturation real, public :: sextic_sv_saturation real, public :: sigma_a = 200.**2. z decay of the perturbation in A real, public :: sigma_t = 2*1000.**2. z decay of the perturbation in T real, public :: slope_lv_saturation real, public :: slope_sv_saturation real, public :: temperature_aux real, public :: temperature_max_perturbation = .7 Maximum temperature perturbation integer, public :: unit real, public :: vapor_total real, public :: x_aux real, public :: y_aux real, public :: z_aux real, public :: z_reference","tags":"","loc":"proc/initial_conditions.html"},{"title":"cloud_movement – cloud_model","text":"public  subroutine cloud_movement() Uses model_var dinamic_var_perturbation microphysics_perturbation desplazamiento de la nube\nRedefine el valor de todas las variables (deberian\nser las que se graban solamente)\ncalculo de la posicion media de la nube, es decir de las gotitas\nel centro esta inicialmente en nx1/2+.5, nx1/2+.5\nposxx y posyy son siempre en modulo menores que dx1\nEn posx y posy se guarda para cada current_time la posicion en\npuntos de red\n   corrimiento en x\n   corrimiento en y Arguments None","tags":"","loc":"proc/cloud_movement.html"},{"title":"cloud_position – cloud_model","text":"public  subroutine cloud_position() Uses cant01 lmngot microphysics_perturbation model_var initial_z_state lmncri desplazamientos horizontales a partir de la velocidad media de la nube\ncalculo la altura media de la nube, la velocidad media de la nube\nes tomada como la velocidad del aire sin perturbar a esa altura Arguments None","tags":"","loc":"proc/cloud_position.html"},{"title":"initialize_model – cloud_model","text":"public  subroutine initialize_model() Uses cant01 dimensions config microphysics_perturbation model_var constants dinamic_var_perturbation model_initial_conditions initial_z_state Arguments None Variables Type Visibility Attributes Name Initial integer, public :: unit_number","tags":"","loc":"proc/initialize_model.html"},{"title":"statistics – cloud_model","text":"public  subroutine statistics() Uses model_var dinamic_var_perturbation config microphysics_perturbation Arguments None Variables Type Visibility Attributes Name Initial integer, public :: unit_number","tags":"","loc":"proc/statistics.html"},{"title":"dinamics – cloud_model","text":"public  subroutine dinamics() Uses dimensions lmnnie lmngot microphysics_perturbation lmnllu model_var advecs dinamic_var_perturbation initial_z_state lmngra extra_subrut lmncri calculo de la dinamica y de la termodinamica Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer, public :: l integer, public :: m integer, public :: n","tags":"","loc":"proc/dinamics.html"},{"title":"filtro – cloud_model","text":"public  subroutine filtro(varia1, facx, facy, facz) Uses filtro01 dimensions filtro para theta_base vapor_base\n Esta subrutina filtra componentes de alta frecuencia espacial.\n El valor de la variable del punto j se filtra con los valores\n extrapolados linalmente de los puntos j-3 y j-1 y similares,\n pasando un polinomio de grado 4 Redefiniciones y contornos Filtro Arguments Type Intent Optional Attributes Name real, intent(inout), DIMENSION(-3:NX1 + 3, -3:NX1 + 3, -2:NZ1 + 2) :: varia1 real, intent(in) :: facx real, intent(in) :: facy real, intent(in) :: facz Variables Type Visibility Attributes Name Initial character(len=50), public :: text","tags":"","loc":"proc/filtro.html"},{"title":"floor_and_ceiling_contour – cloud_model","text":"public  subroutine floor_and_ceiling_contour() Uses cant01 dimensions microphysics_perturbation model_var dinamic_var_perturbation initial_z_state contornos en el piso y en el techo Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j","tags":"","loc":"proc/floor_and_ceiling_contour.html"},{"title":"floor_and_ceiling_contour_redefinition – cloud_model","text":"public  subroutine floor_and_ceiling_contour_redefinition() Uses initial_z_state dinamic_var_perturbation dimensions microphysics_perturbation contornos en el piso y en el techo Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j","tags":"","loc":"proc/floor_and_ceiling_contour_redefinition.html"},{"title":"floor_condition_redefinition – cloud_model","text":"public  subroutine floor_condition_redefinition() Uses cant01 dimensions microphysics_perturbation model_var dinamic_var_perturbation initial_z_state modificada las condiciones en el piso\nRedefinicion Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k","tags":"","loc":"proc/floor_condition_redefinition.html"},{"title":"lateral_contour – cloud_model","text":"public  subroutine lateral_contour() Uses dinamic_var_perturbation dimensions microphysics_perturbation contornos laterales Arguments None Variables Type Visibility Attributes Name Initial integer, public :: j integer, public :: k","tags":"","loc":"proc/lateral_contour.html"},{"title":"lateral_contour_redefinition – cloud_model","text":"public  subroutine lateral_contour_redefinition() Uses dinamic_var_perturbation dimensions microphysics_perturbation contornos laterales Arguments None Variables Type Visibility Attributes Name Initial integer, public :: j integer, public :: k","tags":"","loc":"proc/lateral_contour_redefinition.html"},{"title":"microphisics_substring – cloud_model","text":"public  subroutine microphisics_substring() Uses cant01 dimensions microphysics_perturbation model_var constants dinamic_var_perturbation initial_z_state microphysics extra_subrut Sublazo Microfisico Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer, public :: l integer, public :: m integer, public :: n","tags":"","loc":"proc/microphisics_substring.html"},{"title":"negative_correction – cloud_model","text":"public  subroutine negative_correction() Uses model_var extra_subrut Arguments None","tags":"","loc":"proc/negative_correction.html"},{"title":"save_backup – cloud_model","text":"public  subroutine save_backup() Uses cant01 dimensions model_initialization config io model_var constants dinamic_var_perturbation graba microphysics_perturbation initial_z_state Arguments None Variables Type Visibility Attributes Name Initial integer, public :: unit_number","tags":"","loc":"proc/save_backup.html"},{"title":"speed_pressure – cloud_model","text":"public  subroutine speed_pressure() Uses cant01 dimensions p3v3 velpre01 constants dinamic_var_perturbation initial_z_state sv_inhomogeneous_velocities_and_speed_pressure calculo de la velocidad y la presion\n Calcula la evolucion del la presion y las velocidades con un paso de tiempo menor lt3\n Las cantidades 1 son las presentes en el paso grande y las 2 son las del paso futuro, las 3 son auxiliares\n Le resta la perturbacion promedio\n      redefiniciones y contornos suavizado Arguments None","tags":"","loc":"proc/speed_pressure.html"},{"title":"vapor_advection – cloud_model","text":"public  subroutine vapor_advection() Uses advecs dinamic_var_perturbation dimensions microphysics_perturbation Adveccion de vapores Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j","tags":"","loc":"proc/vapor_advection.html"},{"title":"vapour_negative_correction – cloud_model","text":"public  subroutine vapour_negative_correction() Uses initial_z_state dimensions microphysics_perturbation correccion de negativos para el vapor Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k","tags":"","loc":"proc/vapour_negative_correction.html"},{"title":"water_calculation – cloud_model","text":"public  subroutine water_calculation() Uses initial_z_state model_var dimensions microphysics_perturbation primer calculo de agua (sin laterales) Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k","tags":"","loc":"proc/water_calculation.html"},{"title":"model – cloud_model","text":"public  subroutine model() Uses cant01 model_aux forbear iso_fortran_env model_initialization model_var dinamic_var_perturbation Incluye microfisica con vapor, gotitas, lluvia, cristales, nieve\ny granizos (por unidad de volumen)\nCon viento de corte.\nEste modelo simula una nube tridimensional, con diferencias\nfinitas adelantadas en el tiempo y centradas en el espacio\nEste modelo (asi como sus variantes) sirve de test\nLas grillas son las mismas para las cantidades dinamicas y\nmicrofisicas, como asi tambien los intervalos de tiempo.\nTodas las variables son reales*4\nCondiciones de contorno homogeneas para las variables microfisicas\nGraba el valor de todas las variables cada ltb segundos.\nGraba el valor de las variables para analisis cada ltg segundos.\nCondicion de contorno nula para el vapor\nContempla el desplazamiento de la nube.\nMejora la condicion en el piso para los aerosoles cuando hay agua (815) Arguments None Variables Type Visibility Attributes Name Initial type(bar_object), public :: progress_bar real(kind=R8P), public :: progress_percent","tags":"","loc":"proc/model.html"},{"title":"microfis – cloud_model","text":"public  subroutine microfis(els, ess, Lvl, Lvs, Lsl, T, Dv, Eaccn, Eaucn, Eacng, Lsl00, Fcal, n, qvapaux, qgotaux, qlluaux, qcriaux, qnieaux, qgraaux, Naer, daer2, nu, yy) Uses cant01 dimensions microf05 constants dinamic_var_perturbation microphysics_perturbation Esta subrutina resuelve lo que le pasa a las gotitas,las gotas,\n los cristales, la nieve, el granizo  y al vapor entre si.\n Si hay nucleacion de gotitas no hay condensacion de agua liquida\n Se ha modificado la parte de evaporacion teniendo en cuenta que\n se debe tender a alcanzar el nivel de saturacion\n    Parametros comunes parametros de las distribuciones y variables relacionadas Gotitas calculo de los distintos procesos para los hidrometeoros Evaporacion - Condensacion\n    Gotitas\n    Lluvia\n    Cristales Nieve\npara granizos (sup crecimiento humedo, se verifica en Tgra)\npara aerosoles Autoconversion\ngotitas a lluvia\ncristales a nieve Acrecion\ngotitas por lluvia\ngotitas por nieve\ncristales por nieve\ngotitas por granizo\nlluvia por granizo\ncristales por granizo (sup aqui crecimiento humedo, si es seco se corrige en Tgra)\nnieve por granizo Congelacion-Fusion de gotas y cristales\ncongelacion homogenea de gotitas\ncongelacion homogenea de lluvia\nfusion de la nieve colision entre lluvia y nieve o cristales que forman granizos (o nieve)\nlluvia con cristales\nlluvia con nieve Coleccion de aerosoles\ncoleccion por lluvia coleccion por nieve coleccion por granizo difusion a gotitas difusion a cristales Calculo de la temperatura del granizo y determinacion del tipo\n de crecimiento, se usan los terminos de intercambio anteriores\n Primero suponemos crecimiento humedo y calculamos alfagra.\n Si alfagra>1 el crecimiento es seco.\n Si alfagra<0 o Tg>T0 hay melting multiplicacion de cristales por colisiones\n     colisiones entre granizo con nieve\n     colisiones entre granizo con granizos terminos de intercambio Arguments Type Intent Optional Attributes Name real, intent(in) :: els real, intent(in) :: ess real, intent(in) :: Lvl real, intent(in) :: Lvs real, intent(in) :: Lsl real, intent(in) :: T real, intent(in) :: Dv real, intent(in) :: Eaccn real, intent(in) :: Eaucn real, intent(in) :: Eacng real, intent(in) :: Lsl00 real, intent(inout) :: Fcal integer, intent(in) :: n real(kind=8), intent(inout) :: qvapaux real(kind=8), intent(inout) :: qgotaux real(kind=8), intent(inout) :: qlluaux real(kind=8), intent(inout) :: qcriaux real(kind=8), intent(inout) :: qnieaux real(kind=8), intent(inout) :: qgraaux real, intent(in) :: Naer real, intent(inout) :: daer2 real, intent(in) :: nu integer, intent(in) :: yy","tags":"","loc":"proc/microfis.html"},{"title":"graba120 – cloud_model","text":"public  subroutine graba120(air_density_z_initial, temperature_z_initial, theta_z_initial, Pres00, vapor_z_initial, cc2, aerosol_z_initial, u_z_initial, v_z_initial, u_perturbed_base, u_perturbed_new, v_perturbed_base, v_perturbed_new, w_perturbed_base, w_perturbed_new, theta_base, theta_new, pressure_base, pressure_new, vapor_base, vapor_new, drop_base, drop_new, rain_base, rain_new, crystal_base, crystal_new, snow_base, snow_new, hail_base, hail_new, aerosol_base, aerosol_new, heat_force, Tvis, Tlvl, Tlsl, Tlvs, Telvs, Tesvs, Av, Vtnie, Vtgra0, vapor_z_relative, aerosol_z_relative, Eautcn, Eacrcn) Uses config dimensions Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-3:nz1 + 3) :: air_density_z_initial real, intent(in), dimension(-3:nz1 + 3) :: temperature_z_initial real, intent(in), dimension(-3:nz1 + 3) :: theta_z_initial real, intent(in), dimension(-3:nz1 + 3) :: Pres00 real, intent(in), dimension(-3:nz1 + 3) :: vapor_z_initial real, intent(in), dimension(-3:nz1 + 3) :: cc2 real, intent(in), dimension(-3:nz1 + 3) :: aerosol_z_initial real, intent(in), dimension(-3:nz1 + 3) :: u_z_initial real, intent(in), dimension(-3:nz1 + 3) :: v_z_initial real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: u_perturbed_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: u_perturbed_new real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: v_perturbed_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: v_perturbed_new real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: w_perturbed_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: w_perturbed_new real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: theta_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: theta_new real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: pressure_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: pressure_new real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: vapor_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: vapor_new real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: drop_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: drop_new real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: rain_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: rain_new real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: crystal_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: crystal_new real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: snow_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: snow_new real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: hail_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: hail_new real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: aerosol_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: aerosol_new real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: heat_force real, intent(in), dimension(210:320) :: Tvis real, intent(in), dimension(210:320) :: Tlvl real, intent(in), dimension(210:320) :: Tlsl real, intent(in), dimension(210:320) :: Tlvs real, intent(in), dimension(210:320) :: Telvs real, intent(in), dimension(210:320) :: Tesvs real, intent(in), dimension(-3:2*nz1 + 5) :: Av real, intent(in), dimension(-3:2*nz1 + 5) :: Vtnie real, intent(in), dimension(-3:2*nz1 + 5) :: Vtgra0 real, intent(in), dimension(nz1) :: vapor_z_relative real, intent(in), dimension(nz1) :: aerosol_z_relative real, intent(in), dimension(210:320) :: Eautcn real, intent(in), dimension(210:320) :: Eacrcn Variables Type Visibility Attributes Name Initial integer, public :: unit_number","tags":"","loc":"proc/graba120.html"},{"title":"graba231 – cloud_model","text":"public  subroutine graba231(k, w_perturbed_new, theta_base, vapor_base, rain_base, hail_base, aerosol_base, vapor_z_initial, aerosol_z_initial, file_number) Uses config dimensions Grabacion 2D Arguments Type Intent Optional Attributes Name integer, intent(in) :: k real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: w_perturbed_new real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: theta_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: vapor_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: rain_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: hail_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: aerosol_base real, intent(in), dimension(-3:nz1 + 3) :: vapor_z_initial real, intent(in), dimension(-3:nz1 + 3) :: aerosol_z_initial character(len=3), intent(in) :: file_number Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j character(len=100), public :: nombre integer, public :: unit_number","tags":"","loc":"proc/graba231.html"},{"title":"graba320 – cloud_model","text":"public  subroutine graba320(u_perturbed_base, v_perturbed_base, w_perturbed_base, theta_base, pressure_base, vapor_base, drop_base, rain_base, crystal_base, snow_base, hail_base, aerosol_base, file_number) Uses config dimensions Grabacion 3D Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: u_perturbed_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: v_perturbed_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: w_perturbed_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: theta_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: pressure_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: vapor_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: drop_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: rain_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: crystal_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: snow_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: hail_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: aerosol_base character(len=3), intent(in) :: file_number Variables Type Visibility Attributes Name Initial character(len=30), public :: file_name integer, public :: unit_number","tags":"","loc":"proc/graba320.html"},{"title":"coraer – cloud_model","text":"public  subroutine coraer(aerneg) Uses initial_z_state coraer_vars dimensions microphysics_perturbation Esta subrutina corrige los lugares en donde la dinamica da\nnegativa la cantidad de aerosoles Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: aerneg","tags":"","loc":"proc/coraer.html"},{"title":"corcri – cloud_model","text":"public  subroutine corcri() Uses lmncri corgot_vars dimensions microphysics_perturbation Esta subrutina corrige los lugares en donde la dinamica da\nnegativa la cantidad de cristales Arguments None","tags":"","loc":"proc/corcri.html"},{"title":"corgot – cloud_model","text":"public  subroutine corgot() Uses corgot_vars lmngot dimensions microphysics_perturbation Esta subrutina corrige los lugares en donde la dinamica da\nnegativa la cantidad de gotitas Arguments None","tags":"","loc":"proc/corgot.html"},{"title":"corgra – cloud_model","text":"public  subroutine corgra() Uses lmngra corgot_vars dimensions microphysics_perturbation Esta subrutina corrige los lugares en donde la dinamica da\nnegativa la cantidad de granizos Arguments None","tags":"","loc":"proc/corgra.html"},{"title":"corllu – cloud_model","text":"public  subroutine corllu() Uses corgot_vars lmnllu dimensions microphysics_perturbation Esta subrutina corrige los lugares en donde la dinamica da\nnegativa la cantidad de gotas Arguments None","tags":"","loc":"proc/corllu.html"},{"title":"cornie – cloud_model","text":"public  subroutine cornie() Uses lmnnie corgot_vars dimensions microphysics_perturbation Esta subrutina corrige los lugares en donde la dinamica da\nnegativa la cantidad de nieve Arguments None","tags":"","loc":"proc/cornie.html"},{"title":"corvap – cloud_model","text":"public  subroutine corvap(Qvapneg) Uses initial_z_state corvap_vars dimensions microphysics_perturbation Esta subrutina corrige los lugares en donde la dinamica da\nnegativa la cantidad de vapor Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Qvapneg","tags":"","loc":"proc/corvap.html"},{"title":"daeros – cloud_model","text":"public  subroutine daeros(l, m, n) Uses cant01 dimensions constants advecs dinamic_var_perturbation microphysics_perturbation initial_z_state daeros_vars turbvar Arguments Type Intent Optional Attributes Name integer, intent(in) :: l integer, intent(in) :: m integer, intent(in) :: n","tags":"","loc":"proc/daeros.html"},{"title":"dcrist – cloud_model","text":"public  subroutine dcrist(l, m, n) Uses cant01 dimensions constants advecs dinamic_var_perturbation microphysics_perturbation initial_z_state dcrist_vars turbvar Arguments Type Intent Optional Attributes Name integer, intent(in) :: l integer, intent(in) :: m integer, intent(in) :: n","tags":"","loc":"proc/dcrist.html"},{"title":"dgotit – cloud_model","text":"public  subroutine dgotit(l, m, n) Uses cant01 dgotit_vars dimensions constants advecs dinamic_var_perturbation microphysics_perturbation initial_z_state turbvar Arguments Type Intent Optional Attributes Name integer, intent(in) :: l integer, intent(in) :: m integer, intent(in) :: n","tags":"","loc":"proc/dgotit.html"},{"title":"dgrani – cloud_model","text":"public  subroutine dgrani(l, m, n) Uses cant01 dimensions dgrani_vars constants advecs dinamic_var_perturbation microphysics_perturbation initial_z_state turbvar **  termino de sedimentacion\n** Arguments Type Intent Optional Attributes Name integer, intent(in) :: l integer, intent(in) :: m integer, intent(in) :: n","tags":"","loc":"proc/dgrani.html"},{"title":"dlluvi – cloud_model","text":"public  subroutine dlluvi(l, m, n) Uses cant01 dimensions dlluvi_vars constants advecs dinamic_var_perturbation microphysics_perturbation initial_z_state turbvar **  termino de sedimentacion Arguments Type Intent Optional Attributes Name integer, intent(in) :: l integer, intent(in) :: m integer, intent(in) :: n","tags":"","loc":"proc/dlluvi.html"},{"title":"dnieve – cloud_model","text":"public  subroutine dnieve(l, m, n) Uses cant01 dimensions constants advecs dinamic_var_perturbation dnieve_vars microphysics_perturbation initial_z_state turbvar **  termino de sedimentacion Arguments Type Intent Optional Attributes Name integer, intent(in) :: l integer, intent(in) :: m integer, intent(in) :: n","tags":"","loc":"proc/dnieve.html"},{"title":"dvapor – cloud_model","text":"public  subroutine dvapor(l, m, n) Uses cant01 dimensions dvapor_vars constants advecs dinamic_var_perturbation microphysics_perturbation initial_z_state turbvar Arguments Type Intent Optional Attributes Name integer, intent(in) :: l integer, intent(in) :: m integer, intent(in) :: n","tags":"","loc":"proc/dvapor.html"},{"title":"inhomogeneous_velocities – cloud_model","text":"public  subroutine inhomogeneous_velocities(i, j, k, dden0z) Uses cant01 dimensions constants dinamic_var_perturbation microphysics_perturbation initial_z_state turbvar sv_inhomogeneous_velocities_and_speed_pressure Esta subrutina calcula los terminos inomogeneos para las velocidades Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k real, intent(in) :: dden0z Variables Type Visibility Attributes Name Initial real(kind=8), public :: coefficient_a1 Coefficient a1 real(kind=8), public :: coefficient_a2 Coefficient a2 real(kind=8), public :: coefficient_a3 Coefficient a3 real(kind=8), public :: divergence_x Divergence x real(kind=8), public :: divergence_y Divergence y real(kind=8), public :: divergence_z Divergence z real(kind=8), public :: gravitational_acceleration Gravitational acceleration real(kind=8), public :: laplacian_of_laplacian Laplacian of laplacian real(kind=8), public :: turbulence_x Turbulence x real(kind=8), public :: turbulence_y Turbulence y real(kind=8), public :: turbulence_z Turbulence z real(kind=8), public :: velocity_xx Velocity component xx real(kind=8), public :: velocity_xy Velocity component xy real(kind=8), public :: velocity_xz Velocity component xz real(kind=8), public :: velocity_yx Velocity component yx real(kind=8), public :: velocity_yy Velocity component yy real(kind=8), public :: velocity_yz Velocity component yz real(kind=8), public :: velocity_zx Velocity component zx real(kind=8), public :: velocity_zy Velocity component zy real(kind=8), public :: velocity_zz Velocity component zz","tags":"","loc":"proc/inhomogeneous_velocities.html"},{"title":"nuclea – cloud_model","text":"public  subroutine nuclea(Qvap, Qliq, Naer, TT, rhoa, e1, esl, ess, rl, rs, Lvl, Lvs, Naux, auxl, auxs) Uses cant01 constants nuclea61 dimensions variacion en los aerosoles\nconsiderando que las nuevas gotitas tienen un radio Rgotmin Arguments Type Intent Optional Attributes Name real, intent(inout) :: Qvap real, intent(inout) :: Qliq real, intent(in) :: Naer real, intent(inout) :: TT real, intent(in) :: rhoa real, intent(inout) :: e1 real, intent(inout) :: esl real, intent(inout) :: ess real, intent(inout) :: rl real, intent(in) :: rs real, intent(in) :: Lvl real, intent(in) :: Lvs real, intent(inout) :: Naux real, intent(inout) :: auxl real, intent(inout) :: auxs","tags":"","loc":"proc/nuclea.html"},{"title":"suma – cloud_model","text":"public  subroutine suma(sum, a1, a2, a3) Arguments Type Intent Optional Attributes Name real :: sum real :: a1 real :: a2 real :: a3 Variables Type Visibility Attributes Name Initial real, public :: aux integer, public :: j","tags":"","loc":"proc/suma.html"},{"title":"tempot – cloud_model","text":"public  subroutine tempot(i, j, k, dden0z, Fcal) Uses cant01 dimensions tempe01 constants dinamic_var_perturbation initial_z_state turbvar heat_force es el calor liberado por cambio de fase, por unidad de masa de aire Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k real, intent(in) :: dden0z real, intent(in) :: Fcal","tags":"","loc":"proc/tempot.html"},{"title":"turbu1 – cloud_model","text":"public  subroutine turbu1(kk) Uses cant01 dimensions turbvar1 constants dinamic_var_perturbation turbu1_vars Esta subrutina calcula los Dnm para cada plano Z Lectura de las velocidades necesarias Arguments Type Intent Optional Attributes Name integer, intent(in) :: kk","tags":"","loc":"proc/turbu1.html"},{"title":"turbu2 – cloud_model","text":"public  subroutine turbu2(i, j) Uses turbvar1 turbvar dimensions turbu2_vars Esta subrutina calcula las cantidades referida a los terminos de\n turbulencia: K, DK, DDij\n Dij viene de turbu1\nEn realidad para tener los valores de las 4 cantidades falta\nmultiplicarlas por:\n                 KMM : cteturb dx1/2\n                 DK  : cteturb/4\n                 Dij : 1/dx2 (simetrico)\n                 DDij: 1/dx2 *2 Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j Variables Type Visibility Attributes Name Initial real, public :: aux","tags":"","loc":"proc/turbu2.html"},{"title":"str_gen – cloud_model","text":"public  function str_gen(int_in) result(str_out) Arguments Type Intent Optional Attributes Name integer, intent(in) :: int_in Return Value character(len=4) Variables Type Visibility Attributes Name Initial character(len=3), public :: str_out_mid","tags":"","loc":"proc/str_gen.html"},{"title":"str_gen_aux – cloud_model","text":"public  function str_gen_aux(int_in) result(str_out) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: int_in Return Value character(len=3) Variables Type Visibility Attributes Name Initial character(len=99), public :: str_mid","tags":"","loc":"proc/str_gen_aux.html"},{"title":"str – cloud_model","text":"public interface str Module Procedures public  function str_gen (int_in) result(str_out) Arguments Type Intent Optional Attributes Name integer, intent(in) :: int_in Return Value character(len=4)","tags":"","loc":"interface/str.html"},{"title":"config – cloud_model","text":"Variables Type Visibility Attributes Name Initial real, public :: backup_time_minutes character(len=:), public, allocatable :: output_directory logical(kind=4), public :: restore_backup real, public :: save_lapse_minutes real, public :: sim_time_minutes real, public :: statistic_time_minutes Subroutines public  subroutine init_config (sim_time, save_lapse, statistic_time, backup_time, restore_from_backup, directory) Initializes the configuration for the simulation. Arguments Type Intent Optional Attributes Name real, intent(in) :: sim_time simulation time in minutes real, intent(in) :: save_lapse save lapse in minutes real, intent(in) :: statistic_time statistic time in minutes real, intent(in) :: backup_time backup time in minutes logical, intent(in) :: restore_from_backup restore backup character(len=*), intent(in) :: directory","tags":"","loc":"module/config.html"},{"title":"turbvar1 – cloud_model","text":"Variables usadas en turbulencia Uses dimensions Variables Type Visibility Attributes Name Initial real, public :: D (3,3,-3:nx1+2,-3:nx1+2,3)","tags":"","loc":"module/turbvar1.html"},{"title":"cant01 – cloud_model","text":"Cantidades auxiliares, pasos de tiempos, distancias, etc. Variables Type Visibility Attributes Name Initial real, public :: AA real, public :: cteqgot real, public :: cteqgra real, public :: cteqllu real, public :: cteqnie real, public :: cteturb real, public :: ctur real, public :: dx12 real, public :: dx2 real, public :: dx8 real, public :: ikapa integer, public :: lt2 integer, public :: lt3 real, public :: ltb total backup time real, public :: lte total statistic save time real, public :: ltg total save time real, public :: ltt total simulation time real, public :: pro1 real, public :: pro2 real, public :: pro3 real, public :: pro4 integer, public :: total_time","tags":"","loc":"module/cant01.html"},{"title":"turbvar – cloud_model","text":"Variables usadas en turbulencia Variables Type Visibility Attributes Name Initial real, public, dimension(3) :: D1 real, public, dimension(3) :: D2 real, public, dimension(3) :: D3 real, public, dimension(3, 3) :: DD real, public :: KM1 real, public :: KM2 real, public :: KM3 real, public :: KMM","tags":"","loc":"module/turbvar.html"},{"title":"advecs – cloud_model","text":"Terminos de adveccion Uses dimensions Variables Type Visibility Attributes Name Initial real, public, dimension(-2:nx1 + 2, -2:nx1 + 2) :: advaer1 real, public, dimension(-2:nx1 + 2, -2:nx1 + 2) :: advaer2 real, public, dimension(-2:nx1 + 2, -2:nx1 + 2) :: advcri1 real, public, dimension(-2:nx1 + 2, -2:nx1 + 2) :: advcri2 real, public, dimension(-2:nx1 + 2, -2:nx1 + 2) :: advgot1 real, public, dimension(-2:nx1 + 2, -2:nx1 + 2) :: advgot2 real, public, dimension(-2:nx1 + 2, -2:nx1 + 2) :: advgra1 real, public, dimension(-2:nx1 + 2, -2:nx1 + 2) :: advgra2 real, public, dimension(-2:nx1 + 2, -2:nx1 + 2) :: advllu1 real, public, dimension(-2:nx1 + 2, -2:nx1 + 2) :: advllu2 real, public, dimension(-2:nx1 + 2, -2:nx1 + 2) :: advnie1 real, public, dimension(-2:nx1 + 2, -2:nx1 + 2) :: advnie2 real, public, dimension(-2:nx1 + 2, -2:nx1 + 2) :: advvap1 real, public, dimension(-2:nx1 + 2, -2:nx1 + 2) :: advvap2","tags":"","loc":"module/advecs.html"},{"title":"initial_z_state – cloud_model","text":"Non perturbed quantities Uses dimensions Variables Type Visibility Attributes Name Initial real, public :: Pres00 (-3:nz1+3) Non perturbed pressure z initial real, public :: Presi0 (-3:nz1+3) Non perturbed pressure z initial real, public :: aerosol_z_initial (-3:nz1+3) Non perturbed aerosol z initial real, public :: aerosol_z_relative (nz1) Non perturbed Relative aerosol z initial real, public :: air_density_z_initial (-3:nz1+3) Non perturbed air density z initial real, public :: cc2 (-3:nz1+3) Non perturbed cc2 z initial real, public :: temperature_z_initial (-3:nz1+3) Non perturbed temperature z initial real, public :: theta_z_initial (-3:nz1+3) Non perturbed theta z initial real, public :: u_z_initial (-3:nz1+3) Non perturbed u z initial real, public :: v_z_initial (-3:nz1+3) Non perturbed v z initial real, public :: vapor_z_initial (-3:nz1+3) Non perturbed vapor z initial real, public :: vapor_z_relative (nz1) Non perturbed Relative vapor z initial","tags":"","loc":"module/initial_z_state.html"},{"title":"lmncri – cloud_model","text":"Posiciones en las cuales Qcri<0 Variables Type Visibility Attributes Name Initial integer, public, dimension(2) :: lcri integer, public, dimension(2) :: mcri integer, public, dimension(2) :: ncri","tags":"","loc":"module/lmncri.html"},{"title":"lmngot – cloud_model","text":"Posiciones en las cuales Qgot<0 Variables Type Visibility Attributes Name Initial integer, public, dimension(2) :: lgot integer, public, dimension(2) :: mgot integer, public, dimension(2) :: ngot","tags":"","loc":"module/lmngot.html"},{"title":"lmngra – cloud_model","text":"Posiciones en las cuales Qgra<0 Variables Type Visibility Attributes Name Initial integer, public, dimension(2) :: lgra integer, public, dimension(2) :: mgra integer, public, dimension(2) :: ngra","tags":"","loc":"module/lmngra.html"},{"title":"lmnllu – cloud_model","text":"Posiciones en las cuales Qllu<0 Variables Type Visibility Attributes Name Initial integer, public, dimension(2) :: lllu integer, public, dimension(2) :: mllu integer, public, dimension(2) :: nllu","tags":"","loc":"module/lmnllu.html"},{"title":"lmnnie – cloud_model","text":"Posiciones en las cuales Qnie<0 Variables Type Visibility Attributes Name Initial integer, public, dimension(2) :: lnie integer, public, dimension(2) :: mnie integer, public, dimension(2) :: nnie","tags":"","loc":"module/lmnnie.html"},{"title":"coraer_vars – cloud_model","text":"Correccion de vapor Variables Type Visibility Attributes Name Initial real, public :: dq integer, public :: i integer, public :: j integer, public :: k","tags":"","loc":"module/coraer_vars.html"},{"title":"corgot_vars – cloud_model","text":"Variables Type Visibility Attributes Name Initial real, public :: aux1 integer, public :: l integer, public :: m integer, public :: n real, public :: neg1 real, public :: pos1","tags":"","loc":"module/corgot_vars.html"},{"title":"corvap_vars – cloud_model","text":"Correccion de vapor Variables Type Visibility Attributes Name Initial real, public :: dq integer, public :: i integer, public :: j integer, public :: k","tags":"","loc":"module/corvap_vars.html"},{"title":"turbu1_vars – cloud_model","text":"Turbu Variables Type Visibility Attributes Name Initial real, public :: dv (3,3) integer, public :: i integer, public :: j integer, public :: k integer, public :: ldis integer, public :: lx integer, public :: ly integer, public :: lz integer, public :: m integer, public :: n real, public :: vel (3,-5:5,-5:5,-5:5)","tags":"","loc":"module/turbu1_vars.html"},{"title":"turbu2_vars – cloud_model","text":"Turbu Variables Type Visibility Attributes Name Initial real, public :: KM (-3:3,-3:3,-3:3) integer, public :: ldis integer, public :: lx integer, public :: ly integer, public :: lz integer, public :: m integer, public :: n real, public :: sum","tags":"","loc":"module/turbu2_vars.html"},{"title":"tempe01 – cloud_model","text":"Tempe Variables Type Visibility Attributes Name Initial real, public :: adv (3) real, public :: advec real, public :: calor real, public :: dtita (3) real, public :: escal real, public :: lapla real, public :: turbul real, public :: turden real, public :: verti","tags":"","loc":"module/tempe01.html"},{"title":"nuclea61 – cloud_model","text":"Nuclea Variables Type Visibility Attributes Name Initial real, public :: Acri real, public :: B real, public :: Bcri real, public :: F0 real, public :: F0p real, public :: Qliq1 real, public :: Rcri real, public :: Rgotmin real, public :: TT1 real, public :: TT2 real, public :: Tc real, public :: Ti real, public :: caux real, public :: ei real, public :: esli integer, public :: hhh Parametros de las particulas real, public :: mcri integer, public :: s Parametros de las particulas integer, public :: xxx Parametros de las particulas","tags":"","loc":"module/nuclea61.html"},{"title":"p3v3 – cloud_model","text":"Velocidades y las presiones Uses dimensions Variables Type Visibility Attributes Name Initial real, public, dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: Pres3 real, public, dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: U3 real, public, dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: V3 real, public, dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: W3","tags":"","loc":"module/p3v3.html"},{"title":"daeros_vars – cloud_model","text":"Variables Type Visibility Attributes Name Initial real, public :: adv (3) real, public :: advec real, public :: aux real, public :: daer (3) real, public :: escal real, public :: lapla real, public :: turbul real, public :: verti","tags":"","loc":"module/daeros_vars.html"},{"title":"dcrist_vars – cloud_model","text":"Variables Type Visibility Attributes Name Initial real, public :: adv (3) real, public :: advec real, public :: dqcri (3) real, public :: escal real, public :: lapla real, public :: turbul","tags":"","loc":"module/dcrist_vars.html"},{"title":"dgotit_vars – cloud_model","text":"Variables Type Visibility Attributes Name Initial real, public :: adv (3) real, public :: advec real, public :: dqgot (3) real, public :: escal real, public :: lapla real, public :: turbul","tags":"","loc":"module/dgotit_vars.html"},{"title":"dgrani_vars – cloud_model","text":"Variables Type Visibility Attributes Name Initial real, public :: Qgrai real, public :: Qgras real, public :: Rmi real, public :: Rmm real, public :: Rms real, public :: Vtgrai real, public :: Vtgras real, public :: adv (3) real, public :: advec real, public :: dqgra (3) real, public :: escal real, public :: lapla real, public :: sedim real, public :: turbul","tags":"","loc":"module/dgrani_vars.html"},{"title":"dimlee_vars – cloud_model","text":"Variables Type Visibility Attributes Name Initial integer, public :: nx2 integer, public :: ny2 integer, public :: nz2","tags":"","loc":"module/dimlee_vars.html"},{"title":"dlluvi_vars – cloud_model","text":"Variables Type Visibility Attributes Name Initial real, public :: Qllui real, public :: Qllus real, public :: Rmi real, public :: Rmm real, public :: Rms real, public :: Vtllui real, public :: Vtllus real, public :: adv (3) real, public :: advec real, public :: dqllu (3) real, public :: escal real, public :: lapla real, public :: sedim real, public :: turbul","tags":"","loc":"module/dlluvi_vars.html"},{"title":"dnieve_vars – cloud_model","text":"Variables Type Visibility Attributes Name Initial real, public :: Qniei real, public :: Qnies real, public :: adv (3) real, public :: advec real, public :: dqnie (3) real, public :: escal real, public :: lapla real, public :: sedim real, public :: turbul","tags":"","loc":"module/dnieve_vars.html"},{"title":"dvapor_vars – cloud_model","text":"Variables Type Visibility Attributes Name Initial real, public :: adv (3) real, public :: advec real, public :: aux real, public :: dqvap (3) real, public :: escal real, public :: lapla real, public :: turbul real, public :: verti","tags":"","loc":"module/dvapor_vars.html"},{"title":"filtro01 – cloud_model","text":"Uses dimensions Variables Type Visibility Attributes Name Initial real, public :: fact integer, public :: i integer, public :: j integer, public :: k real, public :: varia2 (-5:nx1+5,-5:nx1+5,-4:nz1+4) real, public :: varx real, public :: vary real, public :: varz","tags":"","loc":"module/filtro01.html"},{"title":"sv_inhomogeneous_velocities_and_speed_pressure – cloud_model","text":"Uses dimensions Variables Type Visibility Attributes Name Initial real, public, dimension(-1:nx1 + 2, -1:nx1 + 2, -1:nz1 + 2) :: fp real, public, dimension(-1:nx1 + 2, -1:nx1 + 2, -1:nz1 + 2) :: fu real, public, dimension(-1:nx1 + 2, -1:nx1 + 2, -1:nz1 + 2) :: fv real, public, dimension(-1:nx1 + 2, -1:nx1 + 2, -1:nz1 + 2) :: fw","tags":"","loc":"module/sv_inhomogeneous_velocities_and_speed_pressure.html"},{"title":"microphysics_perturbation – cloud_model","text":"Module declaration for the microphysics_perturbation module.\nThe microphysics_perturbation module defines variables related to cloud microphysics. Uses dimensions Variables Type Visibility Attributes Name Initial real, public :: Av (-3:2*nz1+5) Other related variables, real, public :: Vtgra0 (-3:2*nz1+5) Other related variables real, public :: Vtnie (-3:2*nz1+5) Other related variables, real, public :: aerosol_base (-3:nx1+3,-3:nx1+3,-2:nz1+2) Spray variables real, public :: aerosol_new (-3:nx1+3,-3:nx1+3,-2:nz1+2) Spray variables real, public :: crystal_base (-3:nx1+3,-3:nx1+3,-2:nz1+2) Crystal variables real, public :: crystal_new (-3:nx1+3,-3:nx1+3,-2:nz1+2) Crystal variables real, public :: drop_base (-3:nx1+3,-3:nx1+3,-2:nz1+2) Drop variable real, public :: drop_new (-3:nx1+3,-3:nx1+3,-2:nz1+2) Drop variable real, public :: hail_base (-3:nx1+3,-3:nx1+3,-2:nz1+2) Graupel (snow pellets) variables real, public :: hail_new (-3:nx1+3,-3:nx1+3,-2:nz1+2) Graupel (snow pellets) variables real, public :: rain_base (-3:nx1+3,-3:nx1+3,-2:nz1+2) Liquid cloud variables real, public :: rain_new (-3:nx1+3,-3:nx1+3,-2:nz1+2) Liquid cloud variables real, public :: snow_base (-3:nx1+3,-3:nx1+3,-2:nz1+2) Snow variables real, public :: snow_new (-3:nx1+3,-3:nx1+3,-2:nz1+2) Snow variables real, public :: vapor_base (-3:nx1+3,-3:nx1+3,-2:nz1+2) Vapor variable real, public :: vapor_new (-3:nx1+3,-3:nx1+3,-2:nz1+2) Vapor variable","tags":"","loc":"module/microphysics_perturbation.html"},{"title":"dinamic_var_perturbation – cloud_model","text":"Defines perturbation-related variables for numerical simulations.\nThese variables are used in the context of dynamic perturbations. Uses dimensions Variables Type Visibility Attributes Name Initial real, public :: heat_force (-3:nx1+3,-3:nx1+3,-2:nz1+2) Heat force real, public :: pressure_base (-3:nx1+3,-3:nx1+3,-2:nz1+2) Base perturbed pressure real, public :: pressure_new (-3:nx1+3,-3:nx1+3,-2:nz1+2) New perturbed pressure real, public :: temperature (-3:nx1+3,-3:nx1+3,-2:nz1+2) Ambient temperature real, public :: theta_base (-3:nx1+3,-3:nx1+3,-2:nz1+2) Potential temperature real, public :: theta_new (-3:nx1+3,-3:nx1+3,-2:nz1+2) Potential temperature real, public :: u_perturbed_base (-3:nx1+3,-3:nx1+3,-2:nz1+2) Original velocity component real, public :: u_perturbed_new (-3:nx1+3,-3:nx1+3,-2:nz1+2) Perturbed velocity component real, public :: v_perturbed_base (-3:nx1+3,-3:nx1+3,-2:nz1+2) Original velocity component real, public :: v_perturbed_new (-3:nx1+3,-3:nx1+3,-2:nz1+2) Perturbed velocity component real, public :: w_perturbed_base (-3:nx1+3,-3:nx1+3,-2:nz1+2) Original velocity component real, public :: w_perturbed_new (-3:nx1+3,-3:nx1+3,-2:nz1+2) Perturbed velocity component","tags":"","loc":"module/dinamic_var_perturbation.html"},{"title":"microf05 – cloud_model","text":"variables auxiliares Variables Type Visibility Attributes Name Initial real(kind=8), public :: A real, public :: A1 real, public :: A2 real, public :: A3 real, public :: A3b real, public :: A4 real, public :: Aalfa real, public :: Acri real, public :: B1 real, public :: B2b real, public :: B3 real, public :: B4 real, public :: BB real, public :: Balfa real, public :: Bcri real, public :: CC2 real, public :: CC3 real, public :: Dfaer real, public :: Efcaer real, public :: Fcalgra real(kind=8), public :: Intaer real(kind=8), public :: Intcri real(kind=8), public :: Intgot real(kind=8), public :: Intgra real(kind=8), public :: Intllu real(kind=8), public :: Intnie real(kind=8), public :: Intvap real(kind=8), public :: Naux variables de procesos microfisicos real, public :: Ncrgrgr real, public :: Ncrgrni real(kind=8), public :: Ncri real(kind=8), public :: Ngot real(kind=8), public :: Ngra real(kind=8), public :: Nllu real(kind=8), public :: Nnie real(kind=8), public :: Nre real(kind=8), public :: Nsc real, public :: Q1 real, public :: Q2 real, public :: Q3 real, public :: Q4 real, public :: Qt real, public :: Qvaux real, public :: Qvls real, public :: Qvls0 real, public :: Qvss real(kind=8), public :: Rcri real(kind=8), public :: Rgot real(kind=8), public :: Rgotmin real(kind=8), public :: Rgra real(kind=8), public :: Rllu real(kind=8), public :: Rnie real, public :: Taux real, public :: Tg real(kind=8), public :: Vtgra real(kind=8), public :: Vtm real(kind=8), public :: accrgra real(kind=8), public :: accrnie real(kind=8), public :: acgogra real(kind=8), public :: acgollu real(kind=8), public :: acgonie real(kind=8), public :: acllgra real(kind=8), public :: acnigra real, public :: agual real, public :: alfagra real(kind=8), public :: aux variables de procesos microfisicos real(kind=8), public :: ccnigra real(kind=8), public :: cfgotcri real(kind=8), public :: cfllugra real(kind=8), public :: cfllunie real(kind=8), public :: cfln1 real(kind=8), public :: cfln2 real(kind=8), public :: coaercri real(kind=8), public :: coaergot real(kind=8), public :: coaergra real(kind=8), public :: coaerllu real(kind=8), public :: coaernie real(kind=8), public :: coevcri real(kind=8), public :: coevgot real(kind=8), public :: coevgra real(kind=8), public :: coevllu real(kind=8), public :: coevnie real(kind=8), public :: colilc real(kind=8), public :: coliln real(kind=8), public :: congagua integer, public :: crecigra real, public :: dQt real, public :: esaux real, public :: fugra real(kind=8), public :: fugrallu real(kind=8), public :: fventgl real(kind=8), public :: fventgs real(kind=8), public :: fventl real(kind=8), public :: fventn real(kind=8), public :: hieconv real, public :: hielo integer, public :: i real(kind=8), public :: incrigra real(kind=8), public :: incrinie real(kind=8), public :: ingotcri real(kind=8), public :: ingotgra real(kind=8), public :: ingotllu real(kind=8), public :: ingotnie real(kind=8), public :: inllugra real(kind=8), public :: inllunie real(kind=8), public :: inniegra real(kind=8), public :: invapcri real(kind=8), public :: invapgot real(kind=8), public :: invapgra real(kind=8), public :: invapllu real(kind=8), public :: invapnie real(kind=8), public :: libaer real(kind=8), public :: liqconv real(kind=8), public :: mucrgrgr real(kind=8), public :: mucrgrni real(kind=8), public :: nieconv real(kind=8), public :: qauxl variables de procesos microfisicos real(kind=8), public :: qauxl0 variables de procesos microfisicos real(kind=8), public :: qauxs variables de procesos microfisicos real(kind=8), public :: qcriaux1 real(kind=8), public :: qgotaux1 real(kind=8), public :: qgraaux1 real(kind=8), public :: qlluaux1 real(kind=8), public :: qnieaux1 real(kind=8), public :: qvapaux1 integer, public :: s","tags":"","loc":"module/microf05.html"},{"title":"velpre01 – cloud_model","text":"Variables Type Visibility Attributes Name Initial real, public :: diver real, public :: dprex real, public :: dprey real, public :: dprez real, public :: dvx real, public :: dvy real, public :: dvz real, public :: facx real, public :: facy real, public :: facz integer, public :: i integer, public :: j integer, public :: k real, public :: kkk real, public :: nnn real, public :: presi real, public :: presix real, public :: presiy real, public :: presiz real, public :: presprom real, public :: prom real, public :: prom1 integer, public :: t real, public :: vel0 real, public :: vel1 real, public :: vel2 real, public :: vel3 Subroutines public  subroutine velpre01_init () Arguments None","tags":"","loc":"module/velpre01.html"},{"title":"model_initial_conditions – cloud_model","text":"Functions public  function TT_f (z_aux) Arguments Type Intent Optional Attributes Name real(kind=4), intent(in) :: z_aux Return Value real Subroutines public  subroutine PP (G, Rd, dx, nz1, Pres, Pres0) Arguments Type Intent Optional Attributes Name real :: G real :: Rd real :: dx integer :: nz1 real :: Pres (-3:nz1+3) real :: Pres0 public  subroutine PP2 (G, dx, air_density_z_initial, Pres00, Pres0) Arguments Type Intent Optional Attributes Name real :: G real :: dx real :: air_density_z_initial (-3:nz1+3) real :: Pres00 (-3:nz1+3) real :: Pres0 public  subroutine initial_conditions () condiciones de tiempo bueno\n TT_f not pure function, do concurrent not allowed Read more… Arguments None","tags":"","loc":"module/model_initial_conditions.html"},{"title":"model_var – cloud_model","text":"Variables Type Visibility Attributes Name Initial real, public :: Dv real, public :: Eaccn real, public :: Eacng real, public :: Eaucn real, public :: Fcal real, public :: Lsl real, public :: Lsl00 real, public :: Lvl real, public :: Lvs real, public :: Naer real, public :: P real, public :: Qliq real, public :: Qvap real(kind=8), public :: Qvapneg real, public :: T real(kind=8), public :: Taux real, public :: Vis real(kind=8), public :: Xnub (5000) real(kind=8), public :: Ynub (5000) integer, public :: actual_file actual file number real(kind=8), public :: aeraux real(kind=8), public :: aerneg real(kind=8), public :: aert1 real(kind=8), public :: aert2 real(kind=8), public :: aert3 real(kind=8), public :: aert4 real, public :: aux real, public :: aux1 real, public :: aux2 real, public :: aux3 real, public :: aux4 real(kind=8), public :: auxx real(kind=8), public :: auxy real(kind=8), public :: auxz real, public :: cks integer, public :: current_time real, public :: daer real, public :: daer2 real(kind=8), public :: daitot real, public :: dden0z real, public :: densi real, public :: dqcri real, public :: dqgot real, public :: e1 real, public :: elvs real(kind=8), public :: ener real(kind=8), public :: ener1 real(kind=8), public :: ener2 real(kind=8), public :: ener3 real(kind=8), public :: ener4 real(kind=8), public :: ener5 real, public :: esvs character(len=3), public :: file_number real(kind=8), public :: gott1 real(kind=8), public :: gott2 real(kind=8), public :: gott3 real(kind=8), public :: gott4 integer, public :: i integer, public :: iT integer, public :: j integer, public :: k integer, public :: l integer, public :: laerneg real, public :: lapla integer, public :: lcrineg integer, public :: lgraneg integer, public :: lll integer, public :: llluneg integer, public :: lnieneg integer, public :: lvapneg integer, public :: m integer, public :: n real, public :: nu integer, public :: posx (-3:5000) real, public :: posxx integer, public :: posy (-3:5000) real, public :: posyy real(kind=8), public :: qcriaux real(kind=8), public :: qg real(kind=8), public :: qgotaux real(kind=8), public :: qgraaux real(kind=8), public :: qlluaux real(kind=8), public :: qnieaux real(kind=8), public :: qv real(kind=8), public :: qvapaux real, public :: rl real, public :: rs integer, public :: s integer, public :: t2 real(kind=8), public :: totmic real(kind=8), public :: totnuc integer, public :: tte real, public :: turbu real(kind=8), public :: vapt1 real(kind=8), public :: vapt2 real(kind=8), public :: vapt3 real(kind=8), public :: vapt4 integer, public :: yy","tags":"","loc":"module/model_var.html"},{"title":"model_initialization – cloud_model","text":"Variables Type Visibility Attributes Name Initial real(kind=8), public :: Qagua real(kind=8), public :: Qaguat integer, public :: aermax real(kind=8), public :: impx real(kind=8), public :: impy integer, public :: laermax integer, public :: laux1 integer, public :: laux2 integer, public :: lqcrimax integer, public :: lqgotmax integer, public :: lqgramax integer, public :: lqllumax integer, public :: lqniemax integer, public :: lqvapmax integer, public :: lqvapmin integer, public :: ltitamax integer, public :: ltitamin integer, public :: lumax integer, public :: lumin integer, public :: lvmax integer, public :: lvmin integer, public :: lwmax integer, public :: lwmin integer, public :: maermax integer, public :: maux1 integer, public :: maux2 integer, public :: mqcrimax integer, public :: mqgotmax integer, public :: mqgramax integer, public :: mqllumax integer, public :: mqniemax integer, public :: mqvapmax integer, public :: mqvapmin integer, public :: mtitamax integer, public :: mtitamin integer, public :: mumax integer, public :: mumin integer, public :: mvmax integer, public :: mvmin integer, public :: mwmax integer, public :: mwmin integer, public :: naermax integer, public :: naux2 integer, public :: nqcrimax integer, public :: nqgotmax integer, public :: nqgramax integer, public :: nqllumax integer, public :: nqniemax integer, public :: nqvapmax integer, public :: nqvapmin integer, public :: ntitamax integer, public :: ntitamin integer, public :: numax integer, public :: numin integer, public :: nvmax integer, public :: nvmin integer, public :: nwmax integer, public :: nwmin integer, public :: qcrimax integer, public :: qcritot integer, public :: qgotmax integer, public :: qgottot integer, public :: qgramax integer, public :: qgratot integer, public :: qllumax integer, public :: qllutot integer, public :: qniemax integer, public :: qnietot integer, public :: qvapmax integer, public :: qvapmin integer, public :: spos integer, public :: titamax integer, public :: titamin integer, public :: umax integer, public :: umin integer, public :: vmax integer, public :: vmin integer, public :: wmax integer, public :: wmin real, public :: zmed Subroutines public  subroutine cloud_movement () desplazamiento de la nube\nRedefine el valor de todas las variables (deberian\nser las que se graban solamente)\ncalculo de la posicion media de la nube, es decir de las gotitas\nel centro esta inicialmente en nx1/2+.5, nx1/2+.5\nposxx y posyy son siempre en modulo menores que dx1\nEn posx y posy se guarda para cada current_time la posicion en\npuntos de red\n   corrimiento en x\n   corrimiento en y Arguments None public  subroutine cloud_position () desplazamientos horizontales a partir de la velocidad media de la nube\ncalculo la altura media de la nube, la velocidad media de la nube\nes tomada como la velocidad del aire sin perturbar a esa altura Arguments None public  subroutine initialize_model () Arguments None public  subroutine statistics () Arguments None","tags":"","loc":"module/model_initialization.html"},{"title":"model_aux – cloud_model","text":"Subroutines public  subroutine dinamics () calculo de la dinamica y de la termodinamica Arguments None public  subroutine filtro (varia1, facx, facy, facz) filtro para theta_base vapor_base\n Esta subrutina filtra componentes de alta frecuencia espacial.\n El valor de la variable del punto j se filtra con los valores\n extrapolados linalmente de los puntos j-3 y j-1 y similares,\n pasando un polinomio de grado 4 Read more… Arguments Type Intent Optional Attributes Name real, intent(inout), DIMENSION(-3:NX1 + 3, -3:NX1 + 3, -2:NZ1 + 2) :: varia1 real, intent(in) :: facx real, intent(in) :: facy real, intent(in) :: facz public  subroutine floor_and_ceiling_contour () contornos en el piso y en el techo Arguments None public  subroutine floor_and_ceiling_contour_redefinition () contornos en el piso y en el techo Arguments None public  subroutine floor_condition_redefinition () modificada las condiciones en el piso\nRedefinicion Arguments None public  subroutine lateral_contour () contornos laterales Arguments None public  subroutine lateral_contour_redefinition () contornos laterales Arguments None public  subroutine microphisics_substring () Sublazo Microfisico Arguments None public  subroutine negative_correction () Arguments None public  subroutine save_backup () Arguments None public  subroutine speed_pressure () calculo de la velocidad y la presion\n Calcula la evolucion del la presion y las velocidades con un paso de tiempo menor lt3\n Las cantidades 1 son las presentes en el paso grande y las 2 son las del paso futuro, las 3 son auxiliares\n Le resta la perturbacion promedio\n      redefiniciones y contornos Read more… Arguments None public  subroutine vapor_advection () Adveccion de vapores Arguments None public  subroutine vapour_negative_correction () correccion de negativos para el vapor Arguments None public  subroutine water_calculation () primer calculo de agua (sin laterales) Arguments None","tags":"","loc":"module/model_aux.html"},{"title":"cloud_model – cloud_model","text":"This module contains the cloud model implementation. Subroutines public  subroutine model () Incluye microfisica con vapor, gotitas, lluvia, cristales, nieve\ny granizos (por unidad de volumen)\nCon viento de corte.\nEste modelo simula una nube tridimensional, con diferencias\nfinitas adelantadas en el tiempo y centradas en el espacio\nEste modelo (asi como sus variantes) sirve de test\nLas grillas son las mismas para las cantidades dinamicas y\nmicrofisicas, como asi tambien los intervalos de tiempo.\nTodas las variables son reales*4\nCondiciones de contorno homogeneas para las variables microfisicas\nGraba el valor de todas las variables cada ltb segundos.\nGraba el valor de las variables para analisis cada ltg segundos.\nCondicion de contorno nula para el vapor\nContempla el desplazamiento de la nube.\nMejora la condicion en el piso para los aerosoles cuando hay agua (815) Arguments None","tags":"","loc":"module/cloud_model.html"},{"title":"dimensions – cloud_model","text":"Defines parameters related to grid dimensions and intervals.\n              These parameters are used in numerical simulations. Variables Type Visibility Attributes Name Initial real, public, parameter :: dt1 = 2.0 Time interval for the main simulation real, public, parameter :: dt2 = 1.0 Time interval for microphysics real, public, parameter :: dt3 = 0.2 Time interval for speed-pressure real, public, parameter :: dx1 = 300.0 Spatial interval (grid spacing) in the x-direction integer, public, parameter :: nx1 = 50 Number of points in the x-direction integer, public, parameter :: nz = 64 Number of points in the z-direction (possibly a different grid) integer, public, parameter :: nz1 = 45 Number of points in the z-direction (first grid)","tags":"","loc":"module/dimensions.html"},{"title":"constants – cloud_model","text":"constants\nDefines mathematical and physical constants relevant to precipitation.\nThese constants are used in numerical simulations and atmospheric modeling. Variables Type Visibility Attributes Name Initial real, public, parameter :: Av0 = 1455. Terminal fall velocity of ice crystals (m/s) real, public, parameter :: Cp = 1003. Specific heat capacities (constant pressure) real, public, parameter :: Cv = 716. Specific heat capacities (constant volume) real, public, parameter :: Cwi = 2106. Specific heat capacities (ice) real, public, parameter :: Cwl = 4218. Specific heat capacities (liquid water) real, public, parameter :: Cwv = 1839. Specific heat capacities (water vapor) real, public, parameter :: Dv0 = 2.11e-5 Diffusivity of water vapor in air (m&#94;2/s) real, public :: Eacrcn (210:320) Equilibrium constants (solid-liquid) real, public :: Eautcn (210:320) Equilibrium constants (liquid-vapor) real, public, parameter :: Efcol = 0.8 Efficiency factor for collision real, public, parameter :: Efcolgn = 0.7 Efficiency factor for collision (graupel) real, public, parameter :: Eps = 0.622646 Ratio of molecular weights (water vapor to dry air) real, public, parameter :: G = 9.8 Acceleration due to gravity (m/s&#94;2) real, public, parameter :: Kair = 2.40e-2 Kinematic viscosity of air (m&#94;2/s) real, public, parameter :: Kapa = 0.2857 Ratio of specific heats (dry air) real, public, parameter :: Lsl0 = 79.7 Latent heats (solid-liquid) real, public, parameter :: Lvl0 = 2.500e6 Latent heats (vapor-liquid) real, public, parameter :: Lvs0 = 2.835e6 Latent heats (vapor-solid) real, public, parameter :: N0got = 2.9e24 Number concentrations (cloud droplets) real, public, parameter :: N0gra = 310. Number concentrations (graupel) real, public, parameter :: N0llu = 4912189. Number concentrations (raindrops) real, public, parameter :: N0nie = 1.66e5 Number concentrations (ice crystals) real, public, parameter :: P00 = 101300 Reference pressure (Pa) real, public, parameter :: Rd = 287.04 Specific gas constants (dry air and water vapor) real, public, parameter :: Rv = 461.05 Specific gas constants (dry air and water vapor) real, public, parameter :: T0 = 273.15 Reference temperature (Kelvin) real, public :: Telvs (210:320) Temperature profile (equilibrium liquid-vapor-solid) real, public :: Tesvs (210:320) Temperature profile (equilibrium solid-vapor-solid) real, public :: Tlsl (210:320) Temperature profile (solid-liquid) real, public :: Tlvl (210:320) Temperature profile (liquid) real, public :: Tlvs (210:320) Temperature profile (liquid-vapor-solid) real, public :: Tvis (210:320) Temperature profile (viscous) real, public, parameter :: Vis0 = 1.718e-5 Kinematic viscosity of air (m&#94;2/s) real, public, parameter :: Vtnie0 = 0.5 Threshold velocity for ice crystal nucleation (m/s) real, public, parameter :: elvs0 = 610.78 Saturation vapor pressures (liquid vapor solid) real, public, parameter :: esvs0 = 610.918 Saturation vapor pressures (solid vapor solid) real, public, parameter :: gam1p8 = 0.9134 Constant related to gamma function real, public, parameter :: gam2p8 = 1.6765 Constant related to gamma function real, public, parameter :: gam3p8 = 4.6941742 Constant related to gamma function real, public, parameter :: gam4p8 = 17.837862 Constant related to gamma function real, public, parameter :: pi = 3.1415926 Mathematical constants real, public, parameter :: rhocri = 900. Densities of crystals (kg/m&#94;3) real, public, parameter :: rhogra = 500. Densities of hail (kg/m&#94;3) real, public, parameter :: rhonie = 100. Densities of snow (kg/m&#94;3) real, public, parameter :: rhow = 1000. Density of water (kg/m&#94;3)","tags":"","loc":"module/constants.html"},{"title":"microphysics – cloud_model","text":"Subroutines public  subroutine microfis (els, ess, Lvl, Lvs, Lsl, T, Dv, Eaccn, Eaucn, Eacng, Lsl00, Fcal, n, qvapaux, qgotaux, qlluaux, qcriaux, qnieaux, qgraaux, Naer, daer2, nu, yy) Esta subrutina resuelve lo que le pasa a las gotitas,las gotas,\n los cristales, la nieve, el granizo  y al vapor entre si.\n Si hay nucleacion de gotitas no hay condensacion de agua liquida\n Se ha modificado la parte de evaporacion teniendo en cuenta que\n se debe tender a alcanzar el nivel de saturacion\n    Parametros comunes Read more… Arguments Type Intent Optional Attributes Name real, intent(in) :: els real, intent(in) :: ess real, intent(in) :: Lvl real, intent(in) :: Lvs real, intent(in) :: Lsl real, intent(in) :: T real, intent(in) :: Dv real, intent(in) :: Eaccn real, intent(in) :: Eaucn real, intent(in) :: Eacng real, intent(in) :: Lsl00 real, intent(inout) :: Fcal integer, intent(in) :: n real(kind=8), intent(inout) :: qvapaux real(kind=8), intent(inout) :: qgotaux real(kind=8), intent(inout) :: qlluaux real(kind=8), intent(inout) :: qcriaux real(kind=8), intent(inout) :: qnieaux real(kind=8), intent(inout) :: qgraaux real, intent(in) :: Naer real, intent(inout) :: daer2 real, intent(in) :: nu integer, intent(in) :: yy","tags":"","loc":"module/microphysics.html"},{"title":"graba – cloud_model","text":"Subroutines public  subroutine graba120 (air_density_z_initial, temperature_z_initial, theta_z_initial, Pres00, vapor_z_initial, cc2, aerosol_z_initial, u_z_initial, v_z_initial, u_perturbed_base, u_perturbed_new, v_perturbed_base, v_perturbed_new, w_perturbed_base, w_perturbed_new, theta_base, theta_new, pressure_base, pressure_new, vapor_base, vapor_new, drop_base, drop_new, rain_base, rain_new, crystal_base, crystal_new, snow_base, snow_new, hail_base, hail_new, aerosol_base, aerosol_new, heat_force, Tvis, Tlvl, Tlsl, Tlvs, Telvs, Tesvs, Av, Vtnie, Vtgra0, vapor_z_relative, aerosol_z_relative, Eautcn, Eacrcn) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-3:nz1 + 3) :: air_density_z_initial real, intent(in), dimension(-3:nz1 + 3) :: temperature_z_initial real, intent(in), dimension(-3:nz1 + 3) :: theta_z_initial real, intent(in), dimension(-3:nz1 + 3) :: Pres00 real, intent(in), dimension(-3:nz1 + 3) :: vapor_z_initial real, intent(in), dimension(-3:nz1 + 3) :: cc2 real, intent(in), dimension(-3:nz1 + 3) :: aerosol_z_initial real, intent(in), dimension(-3:nz1 + 3) :: u_z_initial real, intent(in), dimension(-3:nz1 + 3) :: v_z_initial real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: u_perturbed_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: u_perturbed_new real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: v_perturbed_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: v_perturbed_new real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: w_perturbed_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: w_perturbed_new real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: theta_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: theta_new real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: pressure_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: pressure_new real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: vapor_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: vapor_new real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: drop_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: drop_new real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: rain_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: rain_new real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: crystal_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: crystal_new real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: snow_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: snow_new real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: hail_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: hail_new real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: aerosol_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: aerosol_new real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: heat_force real, intent(in), dimension(210:320) :: Tvis real, intent(in), dimension(210:320) :: Tlvl real, intent(in), dimension(210:320) :: Tlsl real, intent(in), dimension(210:320) :: Tlvs real, intent(in), dimension(210:320) :: Telvs real, intent(in), dimension(210:320) :: Tesvs real, intent(in), dimension(-3:2*nz1 + 5) :: Av real, intent(in), dimension(-3:2*nz1 + 5) :: Vtnie real, intent(in), dimension(-3:2*nz1 + 5) :: Vtgra0 real, intent(in), dimension(nz1) :: vapor_z_relative real, intent(in), dimension(nz1) :: aerosol_z_relative real, intent(in), dimension(210:320) :: Eautcn real, intent(in), dimension(210:320) :: Eacrcn public  subroutine graba231 (k, w_perturbed_new, theta_base, vapor_base, rain_base, hail_base, aerosol_base, vapor_z_initial, aerosol_z_initial, file_number) Grabacion 2D Arguments Type Intent Optional Attributes Name integer, intent(in) :: k real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: w_perturbed_new real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: theta_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: vapor_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: rain_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: hail_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: aerosol_base real, intent(in), dimension(-3:nz1 + 3) :: vapor_z_initial real, intent(in), dimension(-3:nz1 + 3) :: aerosol_z_initial character(len=3), intent(in) :: file_number public  subroutine graba320 (u_perturbed_base, v_perturbed_base, w_perturbed_base, theta_base, pressure_base, vapor_base, drop_base, rain_base, crystal_base, snow_base, hail_base, aerosol_base, file_number) Grabacion 3D Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: u_perturbed_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: v_perturbed_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: w_perturbed_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: theta_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: pressure_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: vapor_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: drop_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: rain_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: crystal_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: snow_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: hail_base real, intent(in), dimension(-3:nx1 + 3, -3:nx1 + 3, -2:nz1 + 2) :: aerosol_base character(len=3), intent(in) :: file_number","tags":"","loc":"module/graba.html"},{"title":"extra_subrut – cloud_model","text":"Subroutines public  subroutine coraer (aerneg) Esta subrutina corrige los lugares en donde la dinamica da\nnegativa la cantidad de aerosoles Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: aerneg public  subroutine corcri () Esta subrutina corrige los lugares en donde la dinamica da\nnegativa la cantidad de cristales Arguments None public  subroutine corgot () Esta subrutina corrige los lugares en donde la dinamica da\nnegativa la cantidad de gotitas Arguments None public  subroutine corgra () Esta subrutina corrige los lugares en donde la dinamica da\nnegativa la cantidad de granizos Arguments None public  subroutine corllu () Esta subrutina corrige los lugares en donde la dinamica da\nnegativa la cantidad de gotas Arguments None public  subroutine cornie () Esta subrutina corrige los lugares en donde la dinamica da\nnegativa la cantidad de nieve Arguments None public  subroutine corvap (Qvapneg) Esta subrutina corrige los lugares en donde la dinamica da\nnegativa la cantidad de vapor Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Qvapneg public  subroutine daeros (l, m, n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: l integer, intent(in) :: m integer, intent(in) :: n public  subroutine dcrist (l, m, n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: l integer, intent(in) :: m integer, intent(in) :: n public  subroutine dgotit (l, m, n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: l integer, intent(in) :: m integer, intent(in) :: n public  subroutine dgrani (l, m, n) **  termino de sedimentacion\n** Arguments Type Intent Optional Attributes Name integer, intent(in) :: l integer, intent(in) :: m integer, intent(in) :: n public  subroutine dlluvi (l, m, n) **  termino de sedimentacion Arguments Type Intent Optional Attributes Name integer, intent(in) :: l integer, intent(in) :: m integer, intent(in) :: n public  subroutine dnieve (l, m, n) **  termino de sedimentacion Arguments Type Intent Optional Attributes Name integer, intent(in) :: l integer, intent(in) :: m integer, intent(in) :: n public  subroutine dvapor (l, m, n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: l integer, intent(in) :: m integer, intent(in) :: n public  subroutine inhomogeneous_velocities (i, j, k, dden0z) Esta subrutina calcula los terminos inomogeneos para las velocidades Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k real, intent(in) :: dden0z public  subroutine nuclea (Qvap, Qliq, Naer, TT, rhoa, e1, esl, ess, rl, rs, Lvl, Lvs, Naux, auxl, auxs) variacion en los aerosoles\nconsiderando que las nuevas gotitas tienen un radio Rgotmin Arguments Type Intent Optional Attributes Name real, intent(inout) :: Qvap real, intent(inout) :: Qliq real, intent(in) :: Naer real, intent(inout) :: TT real, intent(in) :: rhoa real, intent(inout) :: e1 real, intent(inout) :: esl real, intent(inout) :: ess real, intent(inout) :: rl real, intent(in) :: rs real, intent(in) :: Lvl real, intent(in) :: Lvs real, intent(inout) :: Naux real, intent(inout) :: auxl real, intent(inout) :: auxs public  subroutine suma (sum, a1, a2, a3) Arguments Type Intent Optional Attributes Name real :: sum real :: a1 real :: a2 real :: a3 public  subroutine tempot (i, j, k, dden0z, Fcal) heat_force es el calor liberado por cambio de fase, por unidad de masa de aire Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k real, intent(in) :: dden0z real, intent(in) :: Fcal public  subroutine turbu1 (kk) Esta subrutina calcula los Dnm para cada plano Z Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: kk public  subroutine turbu2 (i, j) Esta subrutina calcula las cantidades referida a los terminos de\n turbulencia: K, DK, DDij\n Dij viene de turbu1\nEn realidad para tener los valores de las 4 cantidades falta\nmultiplicarlas por:\n                 KMM : cteturb dx1/2\n                 DK  : cteturb/4\n                 Dij : 1/dx2 (simetrico)\n                 DDij: 1/dx2 *2 Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j","tags":"","loc":"module/extra_subrut.html"},{"title":"io – cloud_model","text":"I/O related procedures Interfaces public        interface str public  function str_gen (int_in) result(str_out) Arguments Type Intent Optional Attributes Name integer, intent(in) :: int_in Return Value character(len=4) Functions public  function str_gen (int_in) result(str_out) Arguments Type Intent Optional Attributes Name integer, intent(in) :: int_in Return Value character(len=4) public  function str_gen_aux (int_in) result(str_out) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: int_in Return Value character(len=3)","tags":"","loc":"module/io.html"},{"title":"config.f90 – cloud_model","text":"Source Code module config character ( len = :), allocatable :: output_directory real :: sim_time_minutes , save_lapse_minutes real :: statistic_time_minutes , backup_time_minutes logical ( 4 ) :: restore_backup contains subroutine init_config ( sim_time , save_lapse , statistic_time , backup_time , & restore_from_backup , directory ) !! Initializes the configuration for the simulation. character ( len =* ), intent ( in ) :: directory real , intent ( in ) :: sim_time !! simulation time in minutes real , intent ( in ) :: save_lapse !! save lapse in minutes real , intent ( in ) :: statistic_time !! statistic time in minutes real , intent ( in ) :: backup_time !! backup time in minutes logical , intent ( in ) :: restore_from_backup !! restore backup sim_time_minutes = sim_time save_lapse_minutes = save_lapse statistic_time_minutes = statistic_time backup_time_minutes = backup_time restore_backup = restore_from_backup output_directory = directory end subroutine init_config end module config","tags":"","loc":"sourcefile/config.f90.html"},{"title":"var_dec.f90 – cloud_model","text":"Source Code module turbvar1 !! Variables usadas en turbulencia use dimensions real :: D ( 3 , 3 , - 3 : nx1 + 2 , - 3 : nx1 + 2 , 3 ) end module turbvar1 module cant01 !! Cantidades auxiliares, pasos de tiempos, distancias, etc. implicit none real :: ltt !! total simulation time real :: ltg !! total save time real :: lte !! total statistic save time real :: ltb !! total backup time real :: ctur , cteturb , dx2 , dx8 , dx12 , AA , ikapa , pro1 , & pro2 , pro3 , pro4 , cteqgot , cteqllu , cteqnie , cteqgra integer :: total_time , lt2 , lt3 end module cant01 module turbvar !! Variables usadas en turbulencia real :: KMM , KM1 , KM2 , KM3 real , dimension ( 3 , 3 ) :: DD real , dimension ( 3 ) :: D1 , D2 , D3 end module turbvar module advecs !! Terminos de adveccion use dimensions real , dimension ( - 2 : nx1 + 2 , - 2 : nx1 + 2 ) :: advaer1 , advaer2 , advgot1 , advgot2 , advllu1 , & advllu2 , advcri1 , advcri2 , advnie1 , advnie2 , advgra1 , advgra2 , advvap1 , advvap2 end module advecs module initial_z_state !! Non perturbed quantities use dimensions real :: temperature_z_initial ( - 3 : nz1 + 3 ) !! Non perturbed temperature z initial real :: theta_z_initial ( - 3 : nz1 + 3 ) !! Non perturbed theta z initial real :: Pres00 ( - 3 : nz1 + 3 ) !! Non perturbed pressure z initial real :: Presi0 ( - 3 : nz1 + 3 ) !! Non perturbed pressure z initial real :: u_z_initial ( - 3 : nz1 + 3 ) !! Non perturbed u z initial real :: v_z_initial ( - 3 : nz1 + 3 ) !! Non perturbed v z initial real :: cc2 ( - 3 : nz1 + 3 ) !! Non perturbed cc2 z initial real :: air_density_z_initial ( - 3 : nz1 + 3 ) !! Non perturbed air density z initial real :: aerosol_z_initial ( - 3 : nz1 + 3 ) !! Non perturbed aerosol z initial real :: vapor_z_initial ( - 3 : nz1 + 3 ) !! Non perturbed vapor z initial real :: vapor_z_relative ( nz1 ) !! Non perturbed Relative vapor z initial real :: aerosol_z_relative ( nz1 ) !! Non perturbed Relative aerosol z initial end module initial_z_state module lmncri !! Posiciones en las cuales Qcri<0 integer , dimension ( 2 ) :: lcri , mcri , ncri end module lmncri module lmngot !! Posiciones en las cuales Qgot<0 integer , dimension ( 2 ) :: lgot , mgot , ngot end module lmngot module lmngra !! Posiciones en las cuales Qgra<0 integer , dimension ( 2 ) :: lgra , mgra , ngra end module lmngra module lmnllu !! Posiciones en las cuales Qllu<0 integer , dimension ( 2 ) :: lllu , mllu , nllu end module lmnllu module lmnnie !! Posiciones en las cuales Qnie<0 integer , dimension ( 2 ) :: lnie , mnie , nnie end module lmnnie module coraer_vars !! Correccion de vapor integer i , j , k real dq end module coraer_vars module corgot_vars integer l , m , n real aux1 , pos1 , neg1 end module corgot_vars module corvap_vars !! Correccion de vapor integer i , j , k real dq end module corvap_vars module turbu1_vars !! Turbu real dv ( 3 , 3 ) real vel ( 3 , - 5 : 5 , - 5 : 5 , - 5 : 5 ) integer lx , ly , lz , ldis , i , j , k , n , m end module turbu1_vars module turbu2_vars !! Turbu real sum real KM ( - 3 : 3 , - 3 : 3 , - 3 : 3 ) integer lx , ly , lz , n , m , ldis end module turbu2_vars module tempe01 !! Tempe real dtita ( 3 ), adv ( 3 ) real advec , verti , escal , lapla , turden , turbul , calor end module tempe01 module nuclea61 !! Nuclea real Qliq1 , TT1 , TT2 , B , Tc , Ti , ei , esli , F0 , F0p , mcri , Rcri , caux integer hhh , s , xxx !! Parametros de las particulas real Rgotmin , Acri , Bcri parameter ( Rgotmin = 5e-6 , Acri = 1e-11 , Bcri = . 6 ) !A en cm&#94;-3 end module nuclea61 module p3v3 !! Velocidades y las presiones use dimensions real , dimension ( - 3 : nx1 + 3 , - 3 : nx1 + 3 , - 2 : nz1 + 2 ) :: U3 , V3 , W3 , Pres3 end module p3v3 module daeros_vars real daer ( 3 ), adv ( 3 ) real advec , verti , escal , lapla , turbul , aux end module daeros_vars module dcrist_vars real dqcri ( 3 ), adv ( 3 ) real advec , escal , lapla , turbul end module dcrist_vars module dgotit_vars real dqgot ( 3 ), adv ( 3 ) real advec , escal , lapla , turbul end module dgotit_vars module dgrani_vars real dqgra ( 3 ), adv ( 3 ) real advec , escal , lapla , turbul , sedim , Qgras , Qgrai , Rms , Rmm , Rmi , Vtgras , Vtgrai end module dgrani_vars module dimlee_vars integer nx2 , ny2 , nz2 parameter ( nx2 = 32 , ny2 = 32 , nz2 = 32 ) end module dimlee_vars module dlluvi_vars real dqllu ( 3 ), adv ( 3 ) real advec , escal , lapla , turbul , sedim , Qllus , Qllui , Rms , Rmm , Rmi , Vtllus , Vtllui end module dlluvi_vars module dnieve_vars real dqnie ( 3 ), adv ( 3 ) real advec , escal , lapla , turbul , sedim , Qnies , Qniei end module dnieve_vars module dvapor_vars real dqvap ( 3 ), adv ( 3 ) real advec , verti , escal , lapla , turbul , aux end module dvapor_vars module filtro01 use dimensions real varia2 ( - 5 : nx1 + 5 , - 5 : nx1 + 5 , - 4 : nz1 + 4 ) real varx , vary , varz , fact integer i , j , k end module filtro01 module sv_inhomogeneous_velocities_and_speed_pressure use dimensions real , dimension ( - 1 : nx1 + 2 , - 1 : nx1 + 2 , - 1 : nz1 + 2 ) :: fu , fv , fw , fp end module sv_inhomogeneous_velocities_and_speed_pressure module microphysics_perturbation !! Module declaration for the microphysics_perturbation module. !! The microphysics_perturbation module defines variables related to cloud microphysics. use dimensions real :: vapor_base ( - 3 : nx1 + 3 , - 3 : nx1 + 3 , - 2 : nz1 + 2 ) !! Vapor variable real :: vapor_new ( - 3 : nx1 + 3 , - 3 : nx1 + 3 , - 2 : nz1 + 2 ) !! Vapor variable real :: drop_base ( - 3 : nx1 + 3 , - 3 : nx1 + 3 , - 2 : nz1 + 2 ) !! Drop variable real :: drop_new ( - 3 : nx1 + 3 , - 3 : nx1 + 3 , - 2 : nz1 + 2 ) !! Drop variable real :: aerosol_base ( - 3 : nx1 + 3 , - 3 : nx1 + 3 , - 2 : nz1 + 2 ) !! Spray variables real :: aerosol_new ( - 3 : nx1 + 3 , - 3 : nx1 + 3 , - 2 : nz1 + 2 ) !! Spray variables real :: rain_base ( - 3 : nx1 + 3 , - 3 : nx1 + 3 , - 2 : nz1 + 2 ) !! Liquid cloud variables real :: rain_new ( - 3 : nx1 + 3 , - 3 : nx1 + 3 , - 2 : nz1 + 2 ) !! Liquid cloud variables real :: crystal_base ( - 3 : nx1 + 3 , - 3 : nx1 + 3 , - 2 : nz1 + 2 ) !! Crystal variables real :: crystal_new ( - 3 : nx1 + 3 , - 3 : nx1 + 3 , - 2 : nz1 + 2 ) !! Crystal variables real :: snow_base ( - 3 : nx1 + 3 , - 3 : nx1 + 3 , - 2 : nz1 + 2 ) !! Snow variables real :: snow_new ( - 3 : nx1 + 3 , - 3 : nx1 + 3 , - 2 : nz1 + 2 ) !! Snow variables real :: hail_base ( - 3 : nx1 + 3 , - 3 : nx1 + 3 , - 2 : nz1 + 2 ) !! Graupel (snow pellets) variables real :: hail_new ( - 3 : nx1 + 3 , - 3 : nx1 + 3 , - 2 : nz1 + 2 ) !! Graupel (snow pellets) variables real :: Av ( - 3 : 2 * nz1 + 5 ) !! Other related variables, real :: Vtnie ( - 3 : 2 * nz1 + 5 ) !! Other related variables, real :: Vtgra0 ( - 3 : 2 * nz1 + 5 ) !! Other related variables end module microphysics_perturbation module dinamic_var_perturbation !! Defines perturbation-related variables for numerical simulations. !! These variables are used in the context of dynamic perturbations. use dimensions real :: u_perturbed_base ( - 3 : nx1 + 3 , - 3 : nx1 + 3 , - 2 : nz1 + 2 ) !! Original velocity component real :: v_perturbed_base ( - 3 : nx1 + 3 , - 3 : nx1 + 3 , - 2 : nz1 + 2 ) !! Original velocity component real :: w_perturbed_base ( - 3 : nx1 + 3 , - 3 : nx1 + 3 , - 2 : nz1 + 2 ) !! Original velocity component real :: u_perturbed_new ( - 3 : nx1 + 3 , - 3 : nx1 + 3 , - 2 : nz1 + 2 ) !! Perturbed velocity component real :: v_perturbed_new ( - 3 : nx1 + 3 , - 3 : nx1 + 3 , - 2 : nz1 + 2 ) !! Perturbed velocity component real :: w_perturbed_new ( - 3 : nx1 + 3 , - 3 : nx1 + 3 , - 2 : nz1 + 2 ) !! Perturbed velocity component real :: pressure_base ( - 3 : nx1 + 3 , - 3 : nx1 + 3 , - 2 : nz1 + 2 ) !! Base perturbed pressure real :: pressure_new ( - 3 : nx1 + 3 , - 3 : nx1 + 3 , - 2 : nz1 + 2 ) !! New perturbed pressure real :: temperature ( - 3 : nx1 + 3 , - 3 : nx1 + 3 , - 2 : nz1 + 2 ) !! Ambient temperature real :: theta_base ( - 3 : nx1 + 3 , - 3 : nx1 + 3 , - 2 : nz1 + 2 ) !! Potential temperature real :: theta_new ( - 3 : nx1 + 3 , - 3 : nx1 + 3 , - 2 : nz1 + 2 ) !! Potential temperature real :: heat_force ( - 3 : nx1 + 3 , - 3 : nx1 + 3 , - 2 : nz1 + 2 ) !! Heat force end module dinamic_var_perturbation module microf05 !!     variables auxiliares real ( 8 ) qauxl , qauxs , aux , qauxl0 , Naux !!     variables de procesos microfisicos real ( 8 ) coevgot , coevllu , coevcri , coevnie , coevgra , liqconv , hieconv , nieconv , acgollu , & acgonie , accrnie , acgogra , acllgra , accrgra , acnigra , cfgotcri , cfllunie , cfllugra , & fugrallu , libaer , coaergot , coaerllu , coaercri , coaernie , coaergra , ccnigra , colilc , & coliln , congagua , mucrgrni , mucrgrgr , invapgot , invapllu , invapcri , invapnie , invapgra , & ingotllu , ingotcri , ingotnie , ingotgra , incrinie , incrigra , inllunie , inllugra , inniegra , & Intvap , Intgot , Intllu , Intcri , Intnie , Intgra , Intaer , cfln1 , cfln2 !     numero de cristales por colision real Ncrgrni , Ncrgrgr parameter ( Ncrgrni = 2 0. , Ncrgrgr = 2 0. ) !     variables para la evaporacion y la condensacion real Qvls , Qvss , Qvls0 !     parametros de las particulas real ( 8 ) Rgot , Ngot , Rllu , Nllu , Rcri , Ncri , Rnie , Nnie , Rgra , Ngra , Vtm , Vtgra , Nre , Nsc , A , fventl , & fventn , fventgs , fventgl , Rgotmin , qvapaux1 , qgotaux1 , qlluaux1 , qcriaux1 , qnieaux1 , qgraaux1 parameter ( Rgotmin = 5e-6 ) integer s !     variables para tgra real Tg , agual , hielo , alfagra , fugra , Aalfa , Balfa , A1 , A2 , A3 , A3b , A4 , B1 , B2b , B3 , B4 , BB , CC2 , CC3 , & Q1 , Q2 , Q3 , Q4 , Qt , dQt , Qvaux , esaux , Taux , Fcalgra integer crecigra , i !     parametros para los cristales real Acri , Bcri parameter ( Acri = 1e-2 , Bcri = . 6 ) !A en m&#94;-3 !     difusion de aerosoles real Dfaer , Efcaer parameter ( Dfaer = 1e-10 , Efcaer = . 01 ) end module microf05","tags":"","loc":"sourcefile/var_dec.f90.html"},{"title":"initials.f90 – cloud_model","text":"Source Code module velpre01 integer :: t , i , j , k real :: dvx , dvy , dvz , diver , dprex , dprey , dprez , vel0 , vel1 , vel2 , & vel3 , presi , presix , presiy , presiz , facx , facy , facz , prom1 , prom , & kkk , presprom , nnn contains subroutine velpre01_init () use dimensions implicit none facx = . 05 facy = . 05 facz = . 05 prom = . 3 / 6. * ( dt3 / . 2 ) prom1 = 1. - prom * 6. kkk = . 01 nnn = ( nx1 + 2 ) ** 2. * ( nz1 + 1 ) end subroutine velpre01_init end module velpre01 module model_initial_conditions contains subroutine initial_conditions () !!     Condiciones iniciales para las variables dinamicas !!     Corresponde a una nube con hielo !!     Calcula la presion inicial en forma iterativa, primero supone aire !!      seco y luego integra considerando la densidad total, incluyendo el !!      vapor. !!     Solo hay una perturbacion en temperatura para iniciar la conveccion !!     Incluye viento de corte, tipo frente use cant01 use dimensions use microphysics_perturbation use dinamic_var_perturbation use constants use initial_z_state use config implicit none real aux , x_aux , y_aux , z_aux , sat_press_lv_aux , relative_humidity_aux , & latent_heat_exponent_aux , celcius_temperature_aux , temperature_aux real vapor_total , aerosol_total , base_horizontal_velocity , z_reference , & gaussian real :: initial_x_perturbation = ( nx1 + 1. ) * dx1 / 2. !! Initial disturbance’s x-coordinate real :: initial_y_perturbation = ( nx1 + 1. ) * dx1 / 2. !! Initial disturbance’s y-coordinate real :: initial_z_perturbation = 0. !! Initial disturbance’s z-coordinate real :: sigma_t = 2 * 100 0. ** 2. !! z decay of the perturbation in T real :: sigma_a = 20 0. ** 2. !! z decay of the perturbation in A real :: perturbation_width = 200 0. !! perturbation_width real :: temperature_max_perturbation = . 7 !! Maximum temperature perturbation real :: aerosol_max_perturbation = 1000 0. !! Maximum aerosol perturbation real intercept_lv_saturation , slope_lv_saturation , quadratic_lv_saturation , & cubic_lv_saturation , quartic_lv_saturation , quintic_lv_saturation , & sextic_lv_saturation real intercept_sv_saturation , slope_sv_saturation , quadratic_sv_saturation , & cubic_sv_saturation , quartic_sv_saturation , quintic_sv_saturation , & sextic_sv_saturation integer i , j , k , n , unit intercept_lv_saturation = 6.10780 slope_lv_saturation = 4.43652e-1 quadratic_lv_saturation = 1.42895e-2 cubic_lv_saturation = 2.65065e-4 quartic_lv_saturation = 3.03124e-6 quintic_lv_saturation = 2.03408e-8 sextic_lv_saturation = 6.13682e-11 intercept_sv_saturation = 6.10918 slope_sv_saturation = 5.03470e-1 quadratic_sv_saturation = 1.88601e-2 cubic_sv_saturation = 4.17622e-4 quartic_sv_saturation = 5.82472e-6 quintic_sv_saturation = 4.83880e-8 sextic_sv_saturation = 1.83883e-10 call PP ( G , Rd , dx1 , nz , Presi0 , P00 ) do concurrent ( k = 0 : nz1 ) z_aux = k * dx1 if ( z_aux <= 50 0. ) then u_z_initial ( k ) = 0. v_z_initial ( k ) = 0. elseif ( z_aux <= 200 0. ) then z_reference = z_aux - 50 0. aux = 4. * ( z_reference / 150 0. ) ** 2. u_z_initial ( k ) = aux v_z_initial ( k ) = 0. elseif ( z_aux <= 900 0. ) then z_reference = z_aux - 200 0. base_horizontal_velocity = z_reference / 700 0. u_z_initial ( k ) = 4. - 1 0. * base_horizontal_velocity ** 2. v_z_initial ( k ) = 3. * base_horizontal_velocity ** . 5 ! else z_reference = z_aux - 900 0. u_z_initial ( k ) = 4. * ( z_reference / 900 0. ) ** 2. - 6. v_z_initial ( k ) = 3. - 5. * ( z_reference / 900 0. ) ** . 5 ! end if u_z_initial ( k ) = u_z_initial ( k ) * 0.7 v_z_initial ( k ) = v_z_initial ( k ) * 0. end do !**   calculo de 'constantes' que dependen de T open ( newunit = unit , file = output_directory // \"ccc\" , access = 'append' ) do concurrent ( k = 210 : 313 ) celcius_temperature_aux = k - T0 Tvis ( k ) = 4.9e-8 * celcius_temperature_aux + Vis0 if ( k < 27 3.15 ) Tvis ( k ) = Tvis ( k ) - 1.2e-10 * celcius_temperature_aux ** 2. !calores latentes de evaporacion, fusion y sublimacion latent_heat_exponent_aux = . 167 + 3.67e-4 * k Tlvl ( k ) = Lvl0 * ( T0 / k ) ** latent_heat_exponent_aux Tlsl ( k ) = ( Lsl0 + 0.485 * celcius_temperature_aux & - 2.5e-3 * celcius_temperature_aux ** 2. ) * 418 0. Tlvs ( k ) = Tlvl ( k ) + Tlsl ( k ) !tension de vapor de saturacion liquido y solido aux = cubic_lv_saturation + celcius_temperature_aux * ( & quartic_lv_saturation + celcius_temperature_aux * ( & quintic_lv_saturation + celcius_temperature_aux * sextic_lv_saturation )) aux = intercept_lv_saturation + celcius_temperature_aux * ( & slope_lv_saturation + celcius_temperature_aux * ( & quadratic_lv_saturation + celcius_temperature_aux * aux )) Telvs ( k ) = aux * 10 0. aux = cubic_sv_saturation + celcius_temperature_aux * ( & quartic_sv_saturation + celcius_temperature_aux * ( & quintic_sv_saturation + celcius_temperature_aux * sextic_sv_saturation )) aux = intercept_sv_saturation + celcius_temperature_aux * ( & slope_sv_saturation + celcius_temperature_aux * ( & quadratic_sv_saturation + celcius_temperature_aux * aux )) Tesvs ( k ) = aux * 10 0. if ( k < 220 ) then aux = Tlvl ( 220 ) / Rv * ( 1. / 22 0. - 1. / k ) Telvs ( k ) = Telvs ( 220 ) * exp ( aux ) aux = Tlvs ( 220 ) / Rv * ( 1. / 22 0. - 1. / k ) Tesvs ( k ) = Tesvs ( 220 ) * exp ( aux ) end if !cambio por las expresiones de Straka Eautcn ( k ) = 1 0. ** (. 035 * ( celcius_temperature_aux ) - . 7 ) Eacrcn ( k ) = exp (. 09 * celcius_temperature_aux ) write ( unit , * ) k , Tvis ( k ), Tlvl ( k ), Tlsl ( k ), Tlvs ( k ), Telvs ( k ), Tesvs ( k ), & Eautcn ( k ), Eacrcn ( k ) end do close ( unit ) !**   condiciones de tiempo bueno ! TT_f not pure function, do concurrent not allowed do k = - 1 , nz1 + 2 ! cantidades base z_aux = k * dx1 temperature_z_initial ( k ) = TT_f ( z_aux ) air_density_z_initial ( k ) = Presi0 ( k ) / Rd / temperature_z_initial ( k ) theta_z_initial ( k ) = temperature_z_initial ( k ) * ( P00 / Presi0 ( k )) ** Kapa Pres00 ( k ) = temperature_z_initial ( k ) / theta_z_initial ( k ) aerosol_z_initial ( k ) = 1000 0. * exp ( - z_aux / 250 0. ) end do temperature_z_initial ( - 1 ) = temperature_z_initial ( 0 ) air_density_z_initial ( - 1 ) = air_density_z_initial ( 0 ) theta_z_initial ( - 1 ) = theta_z_initial ( 0 ) Pres00 ( - 1 ) = Pres00 ( 0 ) aerosol_z_initial ( - 1 ) = - aerosol_z_initial ( 0 ) do concurrent ( k = 0 : nz1 ) do concurrent ( i = 1 : nx1 , j = 1 : nx1 ) !perturbaciones iniciales en la temperatura y en los aerosoles z_aux = k * dx1 x_aux = i * dx1 y_aux = j * dx1 gaussian = exp ( - (( initial_x_perturbation - x_aux ) ** 2. & + ( initial_y_perturbation - y_aux ) ** 2. ) * . 5 / perturbation_width ** 2. ) theta_base ( i , j , k ) = temperature_max_perturbation * exp ( - ( z_aux & - initial_z_perturbation ) ** 2. / sigma_t ) * gaussian if ( theta_base ( i , j , k ) < 1e-5 ) theta_base ( i , j , k ) = 0. aerosol_base ( i , j , k ) = aerosol_max_perturbation * exp ( & - z_aux ** 2. / sigma_a ) * gaussian end do !vapor base temperature_aux = temperature_z_initial ( k ) if ( z_aux <= 500 ) then relative_humidity_aux = . 55 + . 05 * z_aux / 50 0. else if ( z_aux <= 150 0. ) then relative_humidity_aux = . 6 else if ( z_aux <= 4000 ) then relative_humidity_aux = . 6 - ( z_aux - 1500 ) / 250 0. * . 25 else if ( z_aux <= 7000 ) then relative_humidity_aux = . 35 - ( z_aux - 400 0. ) / 300 0. * . 25 else if ( z_aux > 7000 ) then relative_humidity_aux = . 1 - ( z_aux - 7000 ) / 300 0. * . 02 end if n = int ( temperature_aux ) aux = temperature_aux - n sat_press_lv_aux = Telvs ( n ) * ( 1 - aux ) + Telvs ( n + 1 ) * aux vapor_z_initial ( k ) = relative_humidity_aux * sat_press_lv_aux / Rv / temperature_aux !recalculo de la densidad air_density_z_initial ( k ) = air_density_z_initial ( k ) + vapor_z_initial ( k ) end do !**   Velocidad terminal para gota de lluvia, cte que depende de P do concurrent ( k = 1 : nz1 + 1 ) Av ( 2 * k - 1 ) = Av0 * (( P00 / Presi0 ( k - 1 )) ** . 286 + ( P00 / Presi0 ( k )) ** . 286 ) / 2. !puntos intermedios Av ( 2 * k ) = Av0 * ( P00 / Presi0 ( k )) ** . 286 end do !**   Velocidad terminal para la nieve, cte que depende de P do concurrent ( k = 1 : nz1 + 1 ) Vtnie ( 2 * k - 1 ) = Vtnie0 * (( P00 / Presi0 ( k - 1 )) ** . 3 + ( P00 / Presi0 ( k )) ** . 3 ) / 2. !puntos intermedios& Vtnie ( 2 * k ) = Vtnie0 * ( P00 / Presi0 ( k )) ** . 3 end do !**   Velocidad terminal para el granizo, cte que depende de z do concurrent ( k = 0 : nz1 + 1 ) aux = 2.754 * rhogra ** . 605 Vtgra0 ( 2 * k ) = aux / Tvis ( int ( temperature_z_initial ( k ))) ** . 21 / air_density_z_initial ( k ) ** . 395 end do do concurrent ( k = 1 : nz1 + 1 ) Vtgra0 ( 2 * k - 1 ) = ( Vtgra0 ( 2 * k - 2 ) + Vtgra0 ( 2 * k )) / 2. ! punto intermedio end do !************************************************************** !    Recalculo de la Presion y de Tita !    Recalculo de la Presion a partir de la densidad call PP2 ( G , dx1 , air_density_z_initial , Presi0 , P00 ) open ( newunit = unit , file = output_directory // \"inic03.sa\" , access = 'append' ) do concurrent ( k = 0 : nz1 ) theta_z_initial ( k ) = temperature_z_initial ( k ) * ( P00 / Presi0 ( k )) ** Kapa Pres00 ( k ) = temperature_z_initial ( k ) / theta_z_initial ( k ) cc2 ( k ) = Cp * Rd * theta_z_initial ( k ) * Pres00 ( k ) / Cv write ( unit , 210 ) k , temperature_z_initial ( k ), theta_z_initial ( k ), & Presi0 ( k ), Pres00 ( k ), air_density_z_initial ( k ), aerosol_z_initial ( k ), & vapor_z_initial ( k ), u_z_initial ( k ), v_z_initial ( k ) end do close ( unit ) theta_z_initial ( - 1 ) = theta_z_initial ( 0 ) Pres00 ( - 1 ) = Pres00 ( 0 ) air_density_z_initial ( - 1 ) = air_density_z_initial ( 0 ) vapor_z_initial ( - 1 ) = 0 do concurrent ( i = 1 : nx1 , j = 1 : nx1 ) pressure_base ( i , j , 0 ) = pressure_base ( i , j , 1 ) pressure_base ( i , j , - 1 ) = pressure_base ( i , j , 1 ) pressure_new ( i , j , 0 ) = pressure_base ( i , j , 1 ) pressure_new ( i , j , - 1 ) = pressure_base ( i , j , 1 ) theta_base ( i , j , 0 ) = theta_base ( i , j , 1 ) theta_base ( i , j , - 1 ) = theta_base ( i , j , 1 ) vapor_base ( i , j , 0 ) = vapor_base ( i , j , 1 ) vapor_base ( i , j , - 1 ) = vapor_base ( i , j , 1 ) end do ! calculo del vapor_z_relative vapor_total = 0. do concurrent ( k = 1 : nz1 ) vapor_total = vapor_total + vapor_z_initial ( k ) end do do concurrent ( k = 1 : nz1 ) vapor_z_relative ( k ) = vapor_z_initial ( k ) / vapor_total end do !     calculo del aerosol_z_relative aerosol_total = 0. do concurrent ( k = 1 : nz1 ) aerosol_total = aerosol_total + aerosol_z_initial ( k ) end do do concurrent ( k = 1 : nz1 ) aerosol_z_relative ( k ) = aerosol_z_initial ( k ) / aerosol_total end do 210 format ( I3 , 9E12 . 4 ) return end subroutine initial_conditions function TT_f ( z_aux ) real ( 4 ), intent ( in ) :: z_aux real :: a , xx , TT_f a = 29 8.15 if ( z_aux <= 2000 ) then TT_f = a - 9.e-3 * z_aux elseif ( z_aux <= 5500 ) then xx = z_aux - 200 0. TT_f = a - 1 8. - xx * ( 9.e-3 - 2e-3 * xx / 350 0. / 2. ) elseif ( z_aux <= 9000 ) then xx = z_aux - 550 0. TT_f = a - 4 6. - 7e-3 * xx elseif ( z_aux <= 11000 ) then xx = z_aux - 9000 TT_f = a - 7 0.5 - 7e-3 * xx + 1.75e-6 * xx ** 2. elseif ( z_aux <= 12000 ) then TT_f = a - 7 7.5 else xx = z_aux - 12000 TT_f = a - 7 7.5 + 5 0. * ( xx / 900 0. ) ** 2. end if end function TT_f subroutine PP ( G , Rd , dx , nz1 , Pres , Pres0 ) integer k , nz1 , nx4 parameter ( nx4 = 500 ) real Pres ( - 3 : nz1 + 3 ) real integ ( - 2 : nx4 + 2 ) real Pres0 real G , Rd , dx , dx4 real zetaa , zetam , zetad real ya , ym , yd dx4 = dx / 4. integ ( 0 ) = 0 ! TT_f not pure function, do concurrent not allowed do k = 1 , nx4 zetaa = ( 2 * k - 2 ) * dx4 zetam = ( 2 * k - 1 ) * dx4 zetad = ( 2 * k ) * dx4 ya = 1 / TT_f ( zetaa ) ym = 1 / TT_f ( zetam ) yd = 1 / TT_f ( zetad ) integ ( k ) = integ ( k - 1 ) + ya + 4 * ym + yd end do do concurrent ( k = 1 : nz1 + 2 ) Pres ( k ) = Pres0 * exp ( - G / Rd * ( integ ( 2 * k ) * dx4 / 3 )) end do Pres ( 0 ) = Pres0 Pres ( - 1 ) = Pres0 return end subroutine PP subroutine PP2 ( G , dx , air_density_z_initial , Pres00 , Pres0 ) use dimensions integer k real Pres00 ( - 3 : nz1 + 3 ) real air_density_z_initial ( - 3 : nz1 + 3 ) real Den00 ( - 3 : 3 * nz1 + 3 ) real integ ( - 3 : 3 * nz1 + 3 ) real Pres0 real G , dx real ya , ym , yd do concurrent ( k = 0 : nz1 - 1 ) Den00 ( 2 * k ) = air_density_z_initial ( k ) Den00 ( 2 * k + 1 ) = ( air_density_z_initial ( k ) + air_density_z_initial ( k + 1 )) / 2. end do Den00 ( 2 * nz1 ) = air_density_z_initial ( nz1 ) Den00 ( 2 * nz1 + 1 ) = 2. * air_density_z_initial ( nz1 ) - Den00 ( 2 * nz1 - 1 ) integ ( 0 ) = 0 do concurrent ( k = 1 : nz1 ) ya = Den00 ( 2 * k - 1 ) ym = Den00 ( 2 * k ) yd = Den00 ( 2 * k + 1 ) integ ( k ) = integ ( k - 1 ) + ya + 4 * ym + yd end do do concurrent ( k = 1 : nz1 ) Pres00 ( k ) = Pres0 - G * integ ( k ) * dx / 6. end do Pres00 ( 0 ) = Pres0 Pres00 ( - 1 ) = Pres0 return end subroutine PP2 end module model_initial_conditions module model_var real :: T , P , Dv , Lvl , Lvs , Lsl , Vis , Qvap , Qliq , densi , nu , Lsl00 , Eaucn , & Eaccn , Eacng , Naer , dqgot , dqcri , daer , daer2 , Fcal , elvs , esvs , e1 , rl , & rs , dden0z , aux , aux1 , aux2 , aux3 , aux4 , posxx , posyy , cks , turbu , lapla real ( 8 ) :: qgotaux , qvapaux , qlluaux , qcriaux , qnieaux , qgraaux , aeraux , & auxx , auxy , auxz , Taux , Qvapneg , aerneg , ener , ener1 , ener2 , ener3 , & ener4 , ener5 , qv , qg , daitot , vapt1 , vapt2 , vapt3 , vapt4 , gott1 , gott2 , & gott3 , gott4 , aert1 , aert2 , aert3 , aert4 , totnuc , totmic real ( 8 ) :: Xnub ( 5000 ), Ynub ( 5000 ) integer :: posx ( - 3 : 5000 ), posy ( - 3 : 5000 ) character ( len = 3 ) :: file_number integer :: current_time integer :: actual_file !! actual file number integer :: t2 , n , m , l , i , j , k , lll , s , iT , tte , lvapneg , & llluneg , lcrineg , laerneg , lnieneg , lgraneg , yy end module model_var module model_initialization implicit none real :: zmed real ( 8 ) :: impx , impy , Qagua , Qaguat integer :: spos , laux1 , laux2 , maux1 , maux2 , naux2 , umax , umin , & titamin , qvapmax , qvapmin , qgotmax , qllumax , qcrimax , qniemax , & qgramax , aermax , lumax , mumax , numax , lumin , mumin , numin , lvmax , & mvmax , nvmax , lvmin , mvmin , nvmin , lwmax , mwmax , nwmax , lwmin , & mwmin , nwmin , ltitamax , mtitamax , ntitamax , ltitamin , mtitamin , & ntitamin , lqvapmax , mqvapmax , nqvapmax , lqvapmin , mqvapmin , nqvapmin , & lqgotmax , mqgotmax , nqgotmax , lqllumax , mqllumax , nqllumax , laermax , & maermax , naermax , lqcrimax , mqcrimax , nqcrimax , lqniemax , mqniemax , & nqniemax , lqgramax , mqgramax , nqgramax , qgottot , qllutot , qcritot , & vmax , vmin , wmax , wmin , titamax , qnietot , qgratot contains subroutine initialize_model () use model_var use cant01 , only : total_time , lt2 , lt3 , cteturb , dx2 , dx8 , dx12 , & AA , ikapa , cteqgot , cteqllu , cteqnie , cteqgra , ltt , ltg , lte , & ltb , ctur , pro1 , pro2 , pro3 , pro4 , cteqnie use dimensions use constants use config , only : sim_time_minutes , save_lapse_minutes , statistic_time_minutes , & output_directory , backup_time_minutes , restore_backup use initial_z_state , only : air_density_z_initial , temperature_z_initial , & theta_z_initial , Pres00 , vapor_z_initial , cc2 , & aerosol_z_initial , u_z_initial , v_z_initial , & vapor_z_relative , aerosol_z_relative use dinamic_var_perturbation , only : w_perturbed_new , u_perturbed_new , & v_perturbed_new , heat_force , theta_new , theta_base , pressure_new , & pressure_base , u_perturbed_base , v_perturbed_base , w_perturbed_base use microphysics_perturbation , only : aerosol_base , drop_new , & rain_new , crystal_new , snow_new , & hail_new , vapor_new , aerosol_new , & vapor_base , drop_base , rain_base , crystal_base , snow_base , hail_base , & Av , Vtgra0 , Vtnie use model_initial_conditions , only : initial_conditions implicit none integer :: unit_number ltt = sim_time_minutes * 6 0. * 2. ltg = save_lapse_minutes * 6 0. * 2. lte = statistic_time_minutes * 6 0. * 2. ltb = backup_time_minutes * 6 0. * 2. ctur = 0.5 pro1 = 1. - 2e-2 * ( dt1 / 5. ) pro2 = ( 1. - pro1 ) / 6. pro3 = 1. - 2e-2 * ( dt1 / 5. ) pro4 = ( 1. - pro1 ) / 4. total_time = nint ( ltt / dt1 ) lt2 = nint ( dt1 / dt2 ) lt3 = 2 * nint ( dt1 / dt3 ) cteturb = ctur / 2. ** . 5 cks = cteturb * 2. dx2 = 2. * dx1 dx8 = 8. * dx1 dx12 = 1 2. * dx1 AA = 1. / Eps - 1. ikapa = 1. / Kapa cteqgot = 16 0. / 3 ** 6. * pi * rhow * N0got cteqllu = 8. * pi * rhow * N0llu cteqnie = 0.6 * pi * rhonie * N0nie cteqgra = 8. * pi * rhogra * N0gra spos = 0 posxx = 0. posyy = 0. posx ( 0 ) = 0 posy ( 0 ) = 0 tte = 0 if (. not . restore_backup ) then actual_file = 1 call initial_conditions () else open ( newunit = unit_number , file = output_directory // \"inis.da\" , status = & 'unknown' , form = 'unformatted' ) read ( unit_number , * ) air_density_z_initial , temperature_z_initial , & theta_z_initial , Pres00 , vapor_z_initial , cc2 , & aerosol_z_initial , u_z_initial , v_z_initial close ( unit_number ) open ( newunit = unit_number , file = output_directory // \"velos.da\" , status = & 'unknown' , form = 'unformatted' ) rewind unit_number read ( unit_number ) u_perturbed_base , u_perturbed_new , v_perturbed_base , & v_perturbed_new , w_perturbed_base , w_perturbed_new , & theta_base , theta_new , pressure_base , pressure_new , vapor_base , & vapor_new , drop_base , drop_new , rain_base , rain_new , crystal_base , & crystal_new , snow_base , snow_new , hail_base , hail_new , aerosol_base , & aerosol_new , heat_force close ( unit_number ) open ( newunit = unit_number , file = output_directory // \"varconz.da\" , & status = 'unknown' , form = 'unformatted' ) rewind unit_number read ( unit_number ) Tvis , Tlvl , Tlsl , Tlvs , Telvs , Tesvs , Av , Vtnie , & Vtgra0 , vapor_z_relative , aerosol_z_relative , Eautcn , Eacrcn close ( unit_number ) end if !definicion de calores y presiones de vapor a 0 K Lsl00 = Lsl0 * 418 0. end subroutine initialize_model subroutine statistics () use model_var use microphysics_perturbation use dinamic_var_perturbation use config integer :: unit_number umax = 0. lumax = 0 mumax = 0 numax = 0 vmax = 0. lvmax = 0 mvmax = 0 nvmax = 0 wmax = 0. lwmax = 0 mwmax = 0 nwmax = 0 titamax = 0. ltitamax = 0 mtitamax = 0 ntitamax = 0 qvapmax = 0. lqvapmax = 0 mqvapmax = 0 nqvapmax = 0 qgotmax = 0. lqgotmax = 0 mqgotmax = 0 nqgotmax = 0 qllumax = 0. lqllumax = 0 mqllumax = 0 nqllumax = 0 qcrimax = 0. lqcrimax = 0 mqcrimax = 0 nqcrimax = 0 qniemax = 0. lqniemax = 0 mqniemax = 0 nqniemax = 0 qgramax = 0. lqgramax = 0 mqgramax = 0 nqgramax = 0 aermax = 0. laermax = 0 maermax = 0 naermax = 0 umin = 0. lumin = 0 mumin = 0 numin = 0 vmin = 0. lvmin = 0 mvmin = 0 nvmin = 0 wmin = 0. lwmin = 0 mwmin = 0 nwmin = 0 titamin = 0. ltitamin = 0 mtitamin = 0 ntitamin = 0 qvapmin = 0. lqvapmin = 0 mqvapmin = 0 nqvapmin = 0 qgottot = 0. qllutot = 0. qcritot = 0. qnietot = 0. qgratot = 0. do concurrent ( k = 1 : nz1 , i = 1 : nx1 , j = 1 : nx1 ) if ( umax < u_perturbed_base ( i , j , k ) * 100 ) then umax = u_perturbed_base ( i , j , k ) * 100 lumax = i mumax = j numax = k end if if ( umin > u_perturbed_base ( i , j , k ) * 100 ) then umin = u_perturbed_base ( i , j , k ) * 100 lumin = i mumin = j numin = k end if if ( vmax < v_perturbed_base ( i , j , k ) * 100 ) then vmax = v_perturbed_base ( i , j , k ) * 100 lvmax = i mvmax = j nvmax = k end if if ( vmin > v_perturbed_base ( i , j , k ) * 100 ) then vmin = v_perturbed_base ( i , j , k ) * 100 lvmin = i mvmin = j nvmin = k end if if ( wmax < w_perturbed_base ( i , j , k ) * 100 ) then wmax = w_perturbed_base ( i , j , k ) * 100 lwmax = i mwmax = j nwmax = k end if if ( wmin > w_perturbed_base ( i , j , k ) * 100 ) then wmin = w_perturbed_base ( i , j , k ) * 100 lwmin = i mwmin = j nwmin = k end if if ( titamax < theta_base ( i , j , k ) * 1000 ) then titamax = theta_base ( i , j , k ) * 1000 ltitamax = i mtitamax = j ntitamax = k end if if ( titamin > theta_base ( i , j , k ) * 1000 ) then titamin = theta_base ( i , j , k ) * 1000 ltitamin = i mtitamin = j ntitamin = k end if if ( qvapmax < vapor_base ( i , j , k ) * 1e6 ) then qvapmax = vapor_base ( i , j , k ) * 1e6 lqvapmax = i mqvapmax = j nqvapmax = k end if if ( qvapmin > vapor_base ( i , j , k ) * 1e6 ) then qvapmin = vapor_base ( i , j , k ) * 1e6 lqvapmin = i mqvapmin = j nqvapmin = k end if if ( qgotmax < drop_base ( i , j , k ) * 1e6 ) then qgotmax = drop_base ( i , j , k ) * 1e6 lqgotmax = i mqgotmax = j nqgotmax = k end if qgottot = qgottot + drop_base ( i , j , k ) * 1e6 if ( qllumax < rain_base ( i , j , k ) * 1e6 ) then qllumax = rain_base ( i , j , k ) * 1e6 lqllumax = i mqllumax = j nqllumax = k end if qllutot = qllutot + rain_base ( i , j , k ) * 1e6 if ( qcrimax < crystal_base ( i , j , k ) * 1e6 ) then qcrimax = crystal_base ( i , j , k ) * 1e6 lqcrimax = i mqcrimax = j nqcrimax = k end if qcritot = qcritot + crystal_base ( i , j , k ) * 1e6 if ( qniemax < snow_base ( i , j , k ) * 1e6 ) then qniemax = snow_base ( i , j , k ) * 1e6 lqniemax = i mqniemax = j nqniemax = k end if qnietot = qnietot + snow_base ( i , j , k ) * 1e6 if ( qgramax < hail_base ( i , j , k ) * 1e6 ) then qgramax = hail_base ( i , j , k ) * 1e6 lqgramax = i mqgramax = j nqgramax = k end if qgratot = qgratot + hail_base ( i , j , k ) * 1e6 if ( aermax < aerosol_base ( i , j , k ) / 1000 ) then aermax = aerosol_base ( i , j , k ) / 1000 laermax = i maermax = j naermax = k end if end do qgotmax = 0. qcrimax = 0. qniemax = 0. do concurrent ( i =- 1 : 1 , j =- 1 : 1 , k =- 1 : 1 ) qgotmax = qgotmax + 1e5 * drop_base ( lqgotmax + i , mqgotmax + j , nqgotmax + k ) qcrimax = qcrimax + 1e5 * crystal_base ( lqcrimax + i , mqcrimax + j , nqcrimax + k ) qniemax = qniemax + 1e5 * snow_base ( lqniemax + i , mqniemax + j , nqniemax + k ) end do qgotmax = qgotmax / 2 7. qcrimax = qcrimax / 2 7. qniemax = qniemax / 2 7. umax = umax / 10 umin = umin / 10 vmax = vmax / 10 vmin = vmin / 10 wmax = wmax / 10 wmin = wmin / 10 titamax = titamax / 10 titamin = titamin / 10 qvapmax = qvapmax / 10 qvapmin = qvapmin / 10 qgottot = qgottot / 1000 qllutot = qllutot / 1000 qcritot = qcritot / 1000 qnietot = qnietot / 1000 qgratot = qgratot / 1000 open ( newunit = unit_number , file = output_directory // \"esta\" , ACCESS = \"append\" ) write ( unit_number , 710 ) umax , umin , vmax , vmin , wmax , wmin , titamax , titamin , & qvapmax , qvapmin , qgotmax , qllumax , qcrimax , qniemax , qgramax , aermax , & lumax , mumax , numax , lumin , mumin , numin , lvmax , mvmax , nvmax , lvmin , mvmin , & nvmin , lwmax , mwmax , nwmax , lwmin , mwmin , nwmin , ltitamax , mtitamax , ntitamax , & ltitamin , mtitamin , ntitamin , lqvapmax , mqvapmax , nqvapmax , lqvapmin , mqvapmin , & nqvapmin , lqgotmax , mqgotmax , nqgotmax , lqllumax , mqllumax , nqllumax , lqcrimax , & mqcrimax , nqcrimax , lqniemax , mqniemax , nqniemax , lqgramax , mqgramax , nqgramax , & laermax , maermax , naermax close ( unit_number ) open ( newunit = unit_number , file = output_directory // \"est\" , ACCESS = \"append\" ) write ( unit_number , 715 ) qgottot , qllutot , qcritot , qnietot , qgratot close ( unit_number ) 710 format ( 16 i5 , 48 i4 ) 715 format ( 5 i9 ) end subroutine statistics subroutine cloud_position () !! desplazamientos horizontales a partir de la velocidad media de la nube !! calculo la altura media de la nube, la velocidad media de la nube !! es tomada como la velocidad del aire sin perturbar a esa altura use model_var use lmngot use lmncri use microphysics_perturbation use initial_z_state use cant01 if ( ngot ( 2 ) >= 1 . or . ncri ( 2 ) > 1 ) then impx = 0. impy = 0. zmed = 0. Qaguat = 0. spos = 1 Xnub ( tte ) = Xnub ( tte - 1 ) Ynub ( tte ) = Ynub ( tte - 1 ) laux1 = min ( lgot ( 1 ), lcri ( 1 )) laux2 = max ( lgot ( 2 ), lcri ( 2 )) maux1 = min ( mgot ( 1 ), mcri ( 1 )) maux2 = max ( mgot ( 2 ), mcri ( 2 )) naux2 = max ( ngot ( 2 ), ncri ( 2 )) do concurrent ( k = 1 : naux2 , i = laux1 : laux2 , j = maux1 : maux2 ) Qagua = drop_base ( i , j , k ) + crystal_base ( i , j , k ) + rain_base ( i , j , k ) + & snow_base ( i , j , k ) + hail_base ( i , j , k ) zmed = zmed + k * Qagua Qaguat = Qaguat + Qagua end do if ( Qaguat > 1e-3 ) then zmed = zmed / Qaguat Xnub ( tte ) = Xnub ( tte ) + u_z_initial ( nint ( zmed )) * lte Ynub ( tte ) = Ynub ( tte ) + v_z_initial ( nint ( zmed )) * lte end if end if end subroutine cloud_position subroutine cloud_movement () !! desplazamiento de la nube !! Redefine el valor de todas las variables (deberian !! ser las que se graban solamente) !! calculo de la posicion media de la nube, es decir de las gotitas !! el centro esta inicialmente en nx1/2+.5, nx1/2+.5 !! posxx y posyy son siempre en modulo menores que dx1 !! En posx y posy se guarda para cada current_time la posicion en !! puntos de red use model_var use dinamic_var_perturbation use microphysics_perturbation if ( spos == 1 ) then posxx = Xnub ( tte ) posyy = Ynub ( tte ) else posxx = 0. posyy = 0. end if posx ( tte ) = posx ( tte - 1 ) posy ( tte ) = posy ( tte - 1 ) !*    corrimiento en x if ( posxx > dx1 ) then posx ( tte ) = posx ( tte ) + 1 Xnub ( tte ) = Xnub ( tte ) - dx1 do concurrent ( k = 0 : nz1 + 1 ) do concurrent ( j = 0 : nx1 + 1 ) do concurrent ( i = 1 : nx1 + 1 ) u_perturbed_base ( i - 1 , j , k ) = u_perturbed_base ( i , j , k ) v_perturbed_base ( i - 1 , j , k ) = v_perturbed_base ( i , j , k ) w_perturbed_base ( i - 1 , j , k ) = w_perturbed_base ( i , j , k ) pressure_base ( i - 1 , j , k ) = pressure_base ( i , j , k ) u_perturbed_new ( i - 1 , j , k ) = u_perturbed_new ( i , j , k ) v_perturbed_new ( i - 1 , j , k ) = v_perturbed_new ( i , j , k ) w_perturbed_new ( i - 1 , j , k ) = w_perturbed_new ( i , j , k ) pressure_new ( i - 1 , j , k ) = pressure_new ( i , j , k ) theta_base ( i - 1 , j , k ) = theta_base ( i , j , k ) vapor_base ( i - 1 , j , k ) = vapor_base ( i , j , k ) drop_base ( i - 1 , j , k ) = drop_base ( i , j , k ) rain_base ( i - 1 , j , k ) = rain_base ( i , j , k ) crystal_base ( i - 1 , j , k ) = crystal_base ( i , j , k ) aerosol_base ( i - 1 , j , k ) = aerosol_base ( i , j , k ) heat_force ( i - 1 , j , k ) = heat_force ( i , j , k ) end do i = nx1 + 1 u_perturbed_base ( i , j , k ) = u_perturbed_base ( i - 1 , j , k ) v_perturbed_base ( i , j , k ) = v_perturbed_base ( i - 1 , j , k ) w_perturbed_base ( i , j , k ) = w_perturbed_base ( i - 1 , j , k ) pressure_base ( i , j , k ) = pressure_base ( i - 1 , j , k ) u_perturbed_new ( i , j , k ) = u_perturbed_new ( i - 1 , j , k ) v_perturbed_new ( i , j , k ) = v_perturbed_new ( i - 1 , j , k ) w_perturbed_new ( i , j , k ) = w_perturbed_new ( i - 1 , j , k ) pressure_new ( i , j , k ) = pressure_new ( i - 1 , j , k ) theta_base ( i , j , k ) = theta_base ( i - 1 , j , k ) vapor_base ( i , j , k ) = vapor_base ( i - 1 , j , k ) drop_base ( i , j , k ) = drop_base ( i - 1 , j , k ) rain_base ( i , j , k ) = rain_base ( i - 1 , j , k ) crystal_base ( i , j , k ) = crystal_base ( i - 1 , j , k ) aerosol_base ( i , j , k ) = aerosol_base ( i - 1 , j , k ) heat_force ( i , j , k ) = 0. end do i = nx1 j = 0 u_perturbed_base ( i , j , k ) = ( u_perturbed_base ( i - 1 , j , k ) & + u_perturbed_base ( i , j + 1 , k )) / 2. v_perturbed_base ( i , j , k ) = ( v_perturbed_base ( i - 1 , j , k ) & + v_perturbed_base ( i , j + 1 , k )) / 2. w_perturbed_base ( i , j , k ) = ( w_perturbed_base ( i - 1 , j , k ) & + w_perturbed_base ( i , j + 1 , k )) / 2. pressure_base ( i , j , k ) = ( pressure_base ( i - 1 , j , k ) & + pressure_base ( i , j + 1 , k )) / 2. u_perturbed_new ( i , j , k ) = ( u_perturbed_new ( i - 1 , j , k ) & + u_perturbed_new ( i , j + 1 , k )) / 2. v_perturbed_new ( i , j , k ) = ( v_perturbed_new ( i - 1 , j , k ) & + v_perturbed_new ( i , j + 1 , k )) / 2. w_perturbed_new ( i , j , k ) = ( w_perturbed_new ( i - 1 , j , k ) & + w_perturbed_new ( i , j + 1 , k )) / 2. pressure_new ( i , j , k ) = ( pressure_new ( i - 1 , j , k ) & + pressure_new ( i , j + 1 , k )) / 2. theta_base ( i , j , k ) = ( theta_base ( i - 1 , j , k ) & + theta_base ( i , j + 1 , k )) / 2. vapor_base ( i , j , k ) = ( vapor_base ( i - 1 , j , k ) & + vapor_base ( i , j + 1 , k )) / 2. drop_base ( i , j , k ) = ( drop_base ( i - 1 , j , k ) & + drop_base ( i , j + 1 , k )) / 2. rain_base ( i , j , k ) = ( rain_base ( i - 1 , j , k ) & + rain_base ( i , j + 1 , k )) / 2. crystal_base ( i , j , k ) = ( crystal_base ( i - 1 , j , k ) & + crystal_base ( i , j + 1 , k )) / 2. aerosol_base ( i , j , k ) = ( aerosol_base ( i - 1 , j , k ) & + aerosol_base ( i , j + 1 , k )) / 2. heat_force ( i , j , k ) = 0. j = nx1 + 1 u_perturbed_base ( i , j , k ) = ( u_perturbed_base ( i - 1 , j , k ) + u_perturbed_base ( i , j - 1 , k )) / 2. v_perturbed_base ( i , j , k ) = ( v_perturbed_base ( i - 1 , j , k ) + v_perturbed_base ( i , j - 1 , k )) / 2. w_perturbed_base ( i , j , k ) = ( w_perturbed_base ( i - 1 , j , k ) + w_perturbed_base ( i , j - 1 , k )) / 2. pressure_base ( i , j , k ) = ( pressure_base ( i - 1 , j , k ) + pressure_base ( i , j - 1 , k )) / 2. u_perturbed_new ( i , j , k ) = ( u_perturbed_new ( i - 1 , j , k ) + u_perturbed_new ( i , j - 1 , k )) / 2. v_perturbed_new ( i , j , k ) = ( v_perturbed_new ( i - 1 , j , k ) + v_perturbed_new ( i , j - 1 , k )) / 2. w_perturbed_new ( i , j , k ) = ( w_perturbed_new ( i - 1 , j , k ) + w_perturbed_new ( i , j - 1 , k )) / 2. pressure_new ( i , j , k ) = ( pressure_new ( i - 1 , j , k ) + pressure_new ( i , j - 1 , k )) / 2. theta_base ( i , j , k ) = ( theta_base ( i - 1 , j , k ) + theta_base ( i , j - 1 , k )) / 2. vapor_base ( i , j , k ) = ( vapor_base ( i - 1 , j , k ) + vapor_base ( i , j - 1 , k )) / 2. drop_base ( i , j , k ) = ( drop_base ( i - 1 , j , k ) + drop_base ( i , j - 1 , k )) / 2. rain_base ( i , j , k ) = ( rain_base ( i - 1 , j , k ) + rain_base ( i , j - 1 , k )) / 2. crystal_base ( i , j , k ) = ( crystal_base ( i - 1 , j , k ) + crystal_base ( i , j - 1 , k )) / 2. aerosol_base ( i , j , k ) = ( aerosol_base ( i - 1 , j , k ) + aerosol_base ( i , j - 1 , k )) / 2. heat_force ( i , j , k ) = 0. end do end if if ( posxx < - dx1 ) then posx ( tte ) = posx ( tte ) - 1 Xnub ( tte ) = Xnub ( tte ) + dx1 do concurrent ( k = 0 : nz1 + 1 ) do concurrent ( j = 0 : nx1 + 1 ) do concurrent ( i = nx1 : 0 ) ! TODO Test this loop u_perturbed_base ( i + 1 , j , k ) = u_perturbed_base ( i , j , k ) v_perturbed_base ( i + 1 , j , k ) = v_perturbed_base ( i , j , k ) w_perturbed_base ( i + 1 , j , k ) = w_perturbed_base ( i , j , k ) pressure_base ( i + 1 , j , k ) = pressure_base ( i , j , k ) u_perturbed_new ( i + 1 , j , k ) = u_perturbed_new ( i , j , k ) v_perturbed_new ( i + 1 , j , k ) = v_perturbed_new ( i , j , k ) w_perturbed_new ( i + 1 , j , k ) = w_perturbed_new ( i , j , k ) pressure_new ( i + 1 , j , k ) = pressure_new ( i , j , k ) theta_base ( i + 1 , j , k ) = theta_base ( i , j , k ) vapor_base ( i + 1 , j , k ) = vapor_base ( i , j , k ) drop_base ( i + 1 , j , k ) = drop_base ( i , j , k ) rain_base ( i + 1 , j , k ) = rain_base ( i , j , k ) crystal_base ( i + 1 , j , k ) = crystal_base ( i , j , k ) aerosol_base ( i + 1 , j , k ) = aerosol_base ( i , j , k ) heat_force ( i + 1 , j , k ) = heat_force ( i , j , k ) end do i = 0 u_perturbed_base ( i , j , k ) = u_perturbed_base ( i + 1 , j , k ) v_perturbed_base ( i , j , k ) = v_perturbed_base ( i + 1 , j , k ) w_perturbed_base ( i , j , k ) = w_perturbed_base ( i + 1 , j , k ) pressure_base ( i , j , k ) = pressure_base ( i + 1 , j , k ) u_perturbed_new ( i , j , k ) = u_perturbed_new ( i + 1 , j , k ) v_perturbed_new ( i , j , k ) = v_perturbed_new ( i + 1 , j , k ) w_perturbed_new ( i , j , k ) = w_perturbed_new ( i + 1 , j , k ) pressure_new ( i , j , k ) = pressure_new ( i + 1 , j , k ) theta_base ( i , j , k ) = theta_base ( i + 1 , j , k ) vapor_base ( i , j , k ) = vapor_base ( i + 1 , j , k ) drop_base ( i , j , k ) = drop_base ( i + 1 , j , k ) rain_base ( i , j , k ) = rain_base ( i + 1 , j , k ) crystal_base ( i , j , k ) = crystal_base ( i + 1 , j , k ) aerosol_base ( i , j , k ) = aerosol_base ( i + 1 , j , k ) heat_force ( i , j , k ) = 0. end do i = 1 j = 0 u_perturbed_base ( i , j , k ) = ( u_perturbed_base ( i + 1 , j , k ) & + u_perturbed_base ( i , j + 1 , k )) / 2. v_perturbed_base ( i , j , k ) = ( v_perturbed_base ( i + 1 , j , k ) & + v_perturbed_base ( i , j + 1 , k )) / 2. w_perturbed_base ( i , j , k ) = ( w_perturbed_base ( i + 1 , j , k ) & + w_perturbed_base ( i , j + 1 , k )) / 2. pressure_base ( i , j , k ) = ( pressure_base ( i + 1 , j , k ) & + pressure_base ( i , j + 1 , k )) / 2. u_perturbed_new ( i , j , k ) = ( u_perturbed_new ( i + 1 , j , k ) & + u_perturbed_new ( i , j + 1 , k )) / 2. v_perturbed_new ( i , j , k ) = ( v_perturbed_new ( i + 1 , j , k ) & + v_perturbed_new ( i , j + 1 , k )) / 2. w_perturbed_new ( i , j , k ) = ( w_perturbed_new ( i + 1 , j , k ) & + w_perturbed_new ( i , j + 1 , k )) / 2. pressure_new ( i , j , k ) = ( pressure_new ( i + 1 , j , k ) & + pressure_new ( i , j + 1 , k )) / 2. theta_base ( i , j , k ) = ( theta_base ( i + 1 , j , k ) & + theta_base ( i , j + 1 , k )) / 2. vapor_base ( i , j , k ) = ( vapor_base ( i + 1 , j , k ) & + vapor_base ( i , j + 1 , k )) / 2. drop_base ( i , j , k ) = ( drop_base ( i + 1 , j , k ) & + drop_base ( i , j + 1 , k )) / 2. rain_base ( i , j , k ) = ( rain_base ( i + 1 , j , k ) & + rain_base ( i , j + 1 , k )) / 2. crystal_base ( i , j , k ) = ( crystal_base ( i + 1 , j , k ) & + crystal_base ( i , j + 1 , k )) / 2. aerosol_base ( i , j , k ) = ( aerosol_base ( i + 1 , j , k ) & + aerosol_base ( i , j + 1 , k )) / 2. heat_force ( i , j , k ) = 0. j = nx1 + 1 u_perturbed_base ( i , j , k ) = ( u_perturbed_base ( i + 1 , j , k ) & + u_perturbed_base ( i , j - 1 , k )) / 2. v_perturbed_base ( i , j , k ) = ( v_perturbed_base ( i + 1 , j , k ) & + v_perturbed_base ( i , j - 1 , k )) / 2. w_perturbed_base ( i , j , k ) = ( w_perturbed_base ( i + 1 , j , k ) & + w_perturbed_base ( i , j - 1 , k )) / 2. pressure_base ( i , j , k ) = ( pressure_base ( i + 1 , j , k ) & + pressure_base ( i , j - 1 , k )) / 2. u_perturbed_new ( i , j , k ) = ( u_perturbed_new ( i + 1 , j , k ) & + u_perturbed_new ( i , j - 1 , k )) / 2. v_perturbed_new ( i , j , k ) = ( v_perturbed_new ( i + 1 , j , k ) & + v_perturbed_new ( i , j - 1 , k )) / 2. w_perturbed_new ( i , j , k ) = ( w_perturbed_new ( i + 1 , j , k ) & + w_perturbed_new ( i , j - 1 , k )) / 2. pressure_new ( i , j , k ) = ( pressure_new ( i + 1 , j , k ) & + pressure_new ( i , j - 1 , k )) / 2. theta_base ( i , j , k ) = ( theta_base ( i + 1 , j , k ) & + theta_base ( i , j - 1 , k )) / 2. vapor_base ( i , j , k ) = ( vapor_base ( i + 1 , j , k ) & + vapor_base ( i , j - 1 , k )) / 2. drop_base ( i , j , k ) = ( drop_base ( i + 1 , j , k ) & + drop_base ( i , j - 1 , k )) / 2. rain_base ( i , j , k ) = ( rain_base ( i + 1 , j , k ) & + rain_base ( i , j - 1 , k )) / 2. crystal_base ( i , j , k ) = ( crystal_base ( i + 1 , j , k ) & + crystal_base ( i , j - 1 , k )) / 2. aerosol_base ( i , j , k ) = ( aerosol_base ( i + 1 , j , k ) & + aerosol_base ( i , j - 1 , k )) / 2. heat_force ( i , j , k ) = 0. end do end if !*    corrimiento en y if ( posyy > dx1 ) then posy ( tte ) = posy ( tte ) + 1 Ynub ( tte ) = Ynub ( tte ) - dx1 do concurrent ( k = 0 : nz1 + 1 ) do concurrent ( i = 0 : nx1 + 1 ) do concurrent ( j = 1 : nx1 + 1 ) u_perturbed_base ( i , j - 1 , k ) = u_perturbed_base ( i , j , k ) v_perturbed_base ( i , j - 1 , k ) = v_perturbed_base ( i , j , k ) w_perturbed_base ( i , j - 1 , k ) = w_perturbed_base ( i , j , k ) pressure_base ( i , j - 1 , k ) = pressure_base ( i , j , k ) u_perturbed_new ( i , j - 1 , k ) = u_perturbed_new ( i , j , k ) v_perturbed_new ( i , j - 1 , k ) = v_perturbed_new ( i , j , k ) w_perturbed_new ( i , j - 1 , k ) = w_perturbed_new ( i , j , k ) pressure_new ( i , j - 1 , k ) = pressure_new ( i , j , k ) theta_base ( i , j - 1 , k ) = theta_base ( i , j , k ) vapor_base ( i , j - 1 , k ) = vapor_base ( i , j , k ) drop_base ( i , j - 1 , k ) = drop_base ( i , j , k ) rain_base ( i , j - 1 , k ) = rain_base ( i , j , k ) crystal_base ( i , j - 1 , k ) = crystal_base ( i , j , k ) aerosol_base ( i , j - 1 , k ) = aerosol_base ( i , j , k ) heat_force ( i , j - 1 , k ) = heat_force ( i , j , k ) end do j = nx1 + 1 u_perturbed_base ( i , j , k ) = u_perturbed_base ( i , j - 1 , k ) v_perturbed_base ( i , j , k ) = v_perturbed_base ( i , j - 1 , k ) w_perturbed_base ( i , j , k ) = w_perturbed_base ( i , j - 1 , k ) pressure_base ( i , j , k ) = pressure_base ( i , j - 1 , k ) u_perturbed_new ( i , j , k ) = u_perturbed_new ( i , j - 1 , k ) v_perturbed_new ( i , j , k ) = v_perturbed_new ( i , j - 1 , k ) w_perturbed_new ( i , j , k ) = w_perturbed_new ( i , j - 1 , k ) pressure_new ( i , j , k ) = pressure_new ( i , j - 1 , k ) theta_base ( i , j , k ) = theta_base ( i , j - 1 , k ) vapor_base ( i , j , k ) = vapor_base ( i , j - 1 , k ) drop_base ( i , j , k ) = drop_base ( i , j - 1 , k ) rain_base ( i , j , k ) = rain_base ( i , j - 1 , k ) crystal_base ( i , j , k ) = crystal_base ( i , j - 1 , k ) aerosol_base ( i , j , k ) = aerosol_base ( i , j - 1 , k ) heat_force ( i , j , k ) = 0. end do j = nx1 i = 0 u_perturbed_base ( i , j , k ) = ( u_perturbed_base ( i , j - 1 , k ) & + u_perturbed_base ( i + 1 , j , k )) / 2. v_perturbed_base ( i , j , k ) = ( v_perturbed_base ( i , j - 1 , k ) & + v_perturbed_base ( i + 1 , j , k )) / 2. w_perturbed_base ( i , j , k ) = ( w_perturbed_base ( i , j - 1 , k ) & + w_perturbed_base ( i + 1 , j , k )) / 2. pressure_base ( i , j , k ) = ( pressure_base ( i , j - 1 , k ) & + pressure_base ( i + 1 , j , k )) / 2. u_perturbed_new ( i , j , k ) = ( u_perturbed_new ( i , j - 1 , k ) & + u_perturbed_new ( i + 1 , j , k )) / 2. v_perturbed_new ( i , j , k ) = ( v_perturbed_new ( i , j - 1 , k ) & + v_perturbed_new ( i + 1 , j , k )) / 2. w_perturbed_new ( i , j , k ) = ( w_perturbed_new ( i , j - 1 , k ) & + w_perturbed_new ( i + 1 , j , k )) / 2. pressure_new ( i , j , k ) = ( pressure_new ( i , j - 1 , k ) & + pressure_new ( i + 1 , j , k )) / 2. theta_base ( i , j , k ) = ( theta_base ( i , j - 1 , k ) & + theta_base ( i + 1 , j , k )) / 2. vapor_base ( i , j , k ) = ( vapor_base ( i , j - 1 , k ) & + vapor_base ( i + 1 , j , k )) / 2. drop_base ( i , j , k ) = ( drop_base ( i , j - 1 , k ) & + drop_base ( i + 1 , j , k )) / 2. rain_base ( i , j , k ) = ( rain_base ( i , j - 1 , k ) & + rain_base ( i + 1 , j , k )) / 2. crystal_base ( i , j , k ) = ( crystal_base ( i , j - 1 , k ) & + crystal_base ( i + 1 , j , k )) / 2. aerosol_base ( i , j , k ) = ( aerosol_base ( i , j - 1 , k ) & + aerosol_base ( i + 1 , j , k )) / 2. heat_force ( i , j , k ) = 0. i = nx1 + 1 u_perturbed_base ( i , j , k ) = ( u_perturbed_base ( i , j - 1 , k ) & + u_perturbed_base ( i - 1 , j , k )) / 2. v_perturbed_base ( i , j , k ) = ( v_perturbed_base ( i , j - 1 , k ) & + v_perturbed_base ( i - 1 , j , k )) / 2. w_perturbed_base ( i , j , k ) = ( w_perturbed_base ( i , j - 1 , k ) & + w_perturbed_base ( i - 1 , j , k )) / 2. pressure_base ( i , j , k ) = ( pressure_base ( i , j - 1 , k ) & + pressure_base ( i - 1 , j , k )) / 2. u_perturbed_new ( i , j , k ) = ( u_perturbed_new ( i , j - 1 , k ) & + u_perturbed_new ( i - 1 , j , k )) / 2. v_perturbed_new ( i , j , k ) = ( v_perturbed_new ( i , j - 1 , k ) & + v_perturbed_new ( i - 1 , j , k )) / 2. w_perturbed_new ( i , j , k ) = ( w_perturbed_new ( i , j - 1 , k ) & + w_perturbed_new ( i - 1 , j , k )) / 2. pressure_new ( i , j , k ) = ( pressure_new ( i , j - 1 , k ) & + pressure_new ( i - 1 , j , k )) / 2. theta_base ( i , j , k ) = ( theta_base ( i , j - 1 , k ) & + theta_base ( i - 1 , j , k )) / 2. vapor_base ( i , j , k ) = ( vapor_base ( i , j - 1 , k ) & + vapor_base ( i - 1 , j , k )) / 2. drop_base ( i , j , k ) = ( drop_base ( i , j - 1 , k ) & + drop_base ( i - 1 , j , k )) / 2. rain_base ( i , j , k ) = ( rain_base ( i , j - 1 , k ) & + rain_base ( i - 1 , j , k )) / 2. crystal_base ( i , j , k ) = ( crystal_base ( i , j - 1 , k ) & + crystal_base ( i - 1 , j , k )) / 2. aerosol_base ( i , j , k ) = ( aerosol_base ( i , j - 1 , k ) & + aerosol_base ( i - 1 , j , k )) / 2. heat_force ( i , j , k ) = 0. end do end if if ( posyy < - dx1 ) then posy ( tte ) = posy ( tte ) - 1 Xnub ( tte ) = Xnub ( tte ) + dx1 do concurrent ( k = 0 : nz1 + 1 ) do concurrent ( i = 0 : nx1 + 1 ) do concurrent ( j = nx1 : 0 ) ! TODO Test this loop u_perturbed_base ( i , j + 1 , k ) = u_perturbed_base ( i , j , k ) v_perturbed_base ( i , j + 1 , k ) = v_perturbed_base ( i , j , k ) w_perturbed_base ( i , j + 1 , k ) = w_perturbed_base ( i , j , k ) pressure_base ( i , j + 1 , k ) = pressure_base ( i , j , k ) u_perturbed_new ( i , j + 1 , k ) = u_perturbed_new ( i , j , k ) v_perturbed_new ( i , j + 1 , k ) = v_perturbed_new ( i , j , k ) w_perturbed_new ( i , j + 1 , k ) = w_perturbed_new ( i , j , k ) pressure_new ( i , j + 1 , k ) = pressure_new ( i , j , k ) theta_base ( i , j + 1 , k ) = theta_base ( i , j , k ) vapor_base ( i , j + 1 , k ) = vapor_base ( i , j , k ) drop_base ( i , j + 1 , k ) = drop_base ( i , j , k ) rain_base ( i , j + 1 , k ) = rain_base ( i , j , k ) crystal_base ( i , j + 1 , k ) = crystal_base ( i , j , k ) aerosol_base ( i , j + 1 , k ) = aerosol_base ( i , j , k ) heat_force ( i , j + 1 , k ) = heat_force ( i , j , k ) end do j = 0 u_perturbed_base ( i , j , k ) = u_perturbed_base ( i , j - 1 , k ) v_perturbed_base ( i , j , k ) = v_perturbed_base ( i , j - 1 , k ) w_perturbed_base ( i , j , k ) = w_perturbed_base ( i , j - 1 , k ) pressure_base ( i , j , k ) = pressure_base ( i , j - 1 , k ) u_perturbed_new ( i , j , k ) = u_perturbed_new ( i , j - 1 , k ) v_perturbed_new ( i , j , k ) = v_perturbed_new ( i , j - 1 , k ) w_perturbed_new ( i , j , k ) = w_perturbed_new ( i , j - 1 , k ) pressure_new ( i , j , k ) = pressure_new ( i , j - 1 , k ) theta_base ( i , j , k ) = theta_base ( i , j - 1 , k ) vapor_base ( i , j , k ) = vapor_base ( i , j - 1 , k ) drop_base ( i , j , k ) = drop_base ( i , j - 1 , k ) rain_base ( i , j , k ) = rain_base ( i , j - 1 , k ) crystal_base ( i , j , k ) = crystal_base ( i , j - 1 , k ) aerosol_base ( i , j , k ) = aerosol_base ( i , j - 1 , k ) heat_force ( i , j , k ) = 0. end do j = 1 i = 0 u_perturbed_base ( i , j , k ) = ( u_perturbed_base ( i , j + 1 , k ) & + u_perturbed_base ( i + 1 , j , k )) / 2. v_perturbed_base ( i , j , k ) = ( v_perturbed_base ( i , j + 1 , k ) & + v_perturbed_base ( i + 1 , j , k )) / 2. w_perturbed_base ( i , j , k ) = ( w_perturbed_base ( i , j + 1 , k ) & + w_perturbed_base ( i + 1 , j , k )) / 2. pressure_base ( i , j , k ) = ( pressure_base ( i , j + 1 , k ) & + pressure_base ( i + 1 , j , k )) / 2. u_perturbed_new ( i , j , k ) = ( u_perturbed_new ( i , j + 1 , k ) & + u_perturbed_new ( i + 1 , j , k )) / 2. v_perturbed_new ( i , j , k ) = ( v_perturbed_new ( i , j + 1 , k ) & + v_perturbed_new ( i + 1 , j , k )) / 2. w_perturbed_new ( i , j , k ) = ( w_perturbed_new ( i , j + 1 , k ) & + w_perturbed_new ( i + 1 , j , k )) / 2. pressure_new ( i , j , k ) = ( pressure_new ( i , j + 1 , k ) & + pressure_new ( i + 1 , j , k )) / 2. theta_base ( i , j , k ) = ( theta_base ( i , j + 1 , k ) & + theta_base ( i + 1 , j , k )) / 2. vapor_base ( i , j , k ) = ( vapor_base ( i , j + 1 , k ) & + vapor_base ( i + 1 , j , k )) / 2. drop_base ( i , j , k ) = ( drop_base ( i , j + 1 , k ) & + drop_base ( i + 1 , j , k )) / 2. rain_base ( i , j , k ) = ( rain_base ( i , j + 1 , k ) & + rain_base ( i + 1 , j , k )) / 2. crystal_base ( i , j , k ) = ( crystal_base ( i , j + 1 , k ) & + crystal_base ( i + 1 , j , k )) / 2. aerosol_base ( i , j , k ) = ( aerosol_base ( i , j + 1 , k ) & + aerosol_base ( i + 1 , j , k )) / 2. heat_force ( i , j , k ) = 0. i = nx1 + 1 u_perturbed_base ( i , j , k ) = ( u_perturbed_base ( i , j + 1 , k ) & + u_perturbed_base ( i - 1 , j , k )) / 2. v_perturbed_base ( i , j , k ) = ( v_perturbed_base ( i , j + 1 , k ) & + v_perturbed_base ( i - 1 , j , k )) / 2. w_perturbed_base ( i , j , k ) = ( w_perturbed_base ( i , j + 1 , k ) & + w_perturbed_base ( i - 1 , j , k )) / 2. pressure_base ( i , j , k ) = ( pressure_base ( i , j + 1 , k ) & + pressure_base ( i - 1 , j , k )) / 2. u_perturbed_new ( i , j , k ) = ( u_perturbed_new ( i , j + 1 , k ) & + u_perturbed_new ( i - 1 , j , k )) / 2. v_perturbed_new ( i , j , k ) = ( v_perturbed_new ( i , j + 1 , k ) & + v_perturbed_new ( i - 1 , j , k )) / 2. w_perturbed_new ( i , j , k ) = ( w_perturbed_new ( i , j + 1 , k ) & + w_perturbed_new ( i - 1 , j , k )) / 2. pressure_new ( i , j , k ) = ( pressure_new ( i , j + 1 , k ) & + pressure_new ( i - 1 , j , k )) / 2. theta_base ( i , j , k ) = ( theta_base ( i , j + 1 , k ) & + theta_base ( i - 1 , j , k )) / 2. vapor_base ( i , j , k ) = ( vapor_base ( i , j + 1 , k ) & + vapor_base ( i - 1 , j , k )) / 2. drop_base ( i , j , k ) = ( drop_base ( i , j + 1 , k ) & + drop_base ( i - 1 , j , k )) / 2. rain_base ( i , j , k ) = ( rain_base ( i , j + 1 , k ) & + rain_base ( i - 1 , j , k )) / 2. crystal_base ( i , j , k ) = ( crystal_base ( i , j + 1 , k ) & + crystal_base ( i - 1 , j , k )) / 2. aerosol_base ( i , j , k ) = ( aerosol_base ( i , j + 1 , k ) & + aerosol_base ( i - 1 , j , k )) / 2. heat_force ( i , j , k ) = 0. end do end if posxx = posx ( tte ) * dx1 + Xnub ( tte ) posyy = posy ( tte ) * dx1 + Ynub ( tte ) end subroutine cloud_movement end module model_initialization","tags":"","loc":"sourcefile/initials.f90.html"},{"title":"model_aux.f90 – cloud_model","text":"Source Code module model_aux contains subroutine vapor_advection () !!Adveccion de vapores use advecs , only : advllu1 , advaer1 , advnie1 , advgra1 , advvap1 , advgot1 , & advcri1 , advaer1 use microphysics_perturbation , only : aerosol_base , vapor_base , rain_base , snow_base , hail_base use dinamic_var_perturbation , only : w_perturbed_new use dimensions , only : nx1 implicit none integer :: i , j do concurrent ( i = 0 : nx1 + 1 , j = 0 : nx1 + 1 ) advvap1 ( i , j ) = w_perturbed_new ( i , j , 1 ) * ( vapor_base ( i , j , 1 ) + vapor_base ( i , j , 0 )) / 4. advgot1 ( i , j ) = 0. advllu1 ( i , j ) = w_perturbed_new ( i , j , 1 ) * rain_base ( i , j , 1 ) if ( w_perturbed_new ( i , j , 1 ) > 0 ) advllu1 ( i , j ) = 0. advaer1 ( i , j ) = w_perturbed_new ( i , j , 1 ) * ( aerosol_base ( i , j , 1 ) + aerosol_base ( i , j , 0 )) / 4. if ( w_perturbed_new ( i , j , 1 ) < 0 ) advaer1 ( i , j ) = advaer1 ( i , j ) * 1.5 advcri1 ( i , j ) = 0. advnie1 ( i , j ) = w_perturbed_new ( i , j , 1 ) * snow_base ( i , j , 1 ) if ( w_perturbed_new ( i , j , 1 ) > 0 ) advnie1 ( i , j ) = 0. advgra1 ( i , j ) = w_perturbed_new ( i , j , 1 ) * hail_base ( i , j , 1 ) if ( w_perturbed_new ( i , j , 1 ) > 0 ) advgra1 ( i , j ) = 0. end do end subroutine vapor_advection subroutine dinamics () !! calculo de la dinamica y de la termodinamica use dimensions , only : dt1 , dx1 , nx1 , nz1 use model_var , only : dden0z , ener1 , s , llluneg , lcrineg , lnieneg , lgraneg , & lvapneg , laerneg , Qvapneg , aerneg use initial_z_state , only : air_density_z_initial , vapor_z_initial , aerosol_z_initial use dinamic_var_perturbation , only : w_perturbed_new , u_perturbed_new , v_perturbed_new , heat_force use advecs , only : advllu1 , advaer1 , advnie1 , advgra1 , advvap1 , advgot1 , & advcri1 , advvap2 , advgot2 , advllu2 , advcri2 , advnie2 , advgra2 , advaer1 , & advaer2 use microphysics_perturbation , only : drop_new , rain_new , & crystal_new , snow_new , hail_new , vapor_new , & aerosol_new use lmngot , only : lgot , mgot , ngot use lmnllu , only : lllu , mllu , nllu use lmncri , only : lcri , mcri , ncri use lmnnie , only : lnie , mnie , nnie use lmngra , only : lgra , mgra , ngra use extra_subrut , only : turbu1 , turbu2 , inhomogeneous_velocities , & tempot , dvapor , dgotit , dlluvi , dcrist , dnieve , dgrani , daeros implicit none integer :: i , j , k , l , m , n s = 0 Qvapneg = 0. lvapneg = 0 aerneg = 0. laerneg = 0 llluneg = 0 lcrineg = 0. lnieneg = 0. lgraneg = 0. ener1 = 0. lgot ( 1 ) = nx1 lgot ( 2 ) = 0 mgot ( 1 ) = nx1 mgot ( 2 ) = 0 ngot ( 1 ) = nz1 ngot ( 2 ) = 0 lllu ( 1 ) = nx1 lllu ( 2 ) = 0 mllu ( 1 ) = nx1 mllu ( 2 ) = 0 nllu ( 1 ) = nz1 nllu ( 2 ) = 0 lcri ( 1 ) = nx1 lcri ( 2 ) = 0 mcri ( 1 ) = nx1 mcri ( 2 ) = 0 ncri ( 1 ) = nz1 ncri ( 2 ) = 0 lnie ( 1 ) = nx1 lnie ( 2 ) = 0 mnie ( 1 ) = nx1 mnie ( 2 ) = 0 nnie ( 1 ) = nz1 nnie ( 2 ) = 0 lgra ( 1 ) = nx1 lgra ( 2 ) = 0 mgra ( 1 ) = nx1 mgra ( 2 ) = 0 ngra ( 1 ) = nz1 ngra ( 2 ) = 0 do k = 1 , nz1 - 1 n = k dden0z = ( air_density_z_initial ( k + 1 ) - air_density_z_initial ( k - 1 )) / air_density_z_initial ( k ) call turbu1 ( n ) do i = 1 , nx1 l = i do j = 1 , nx1 m = j !calculo del coeficiente de turbulencia y derivadas call turbu2 ( l , m ) !calculo de las inhomogeneidades para las velocidades call inhomogeneous_velocities ( l , m , n , dden0z ) !calculo de la energia cinetica ener1 = . 5 * air_density_z_initial ( k ) * ( & u_perturbed_new ( i , j , k ) ** 2. + & v_perturbed_new ( i , j , k ) ** 2. + & w_perturbed_new ( i , j , k ) ** 2. ) + ener1 !calculo de la temperatura potencial call tempot ( l , m , n , dden0z , heat_force ( i , j , k )) heat_force ( i , j , k ) = 0. !dinamica del vapor y de las gotitas call dvapor ( l , m , n ) advvap1 ( i , j ) = advvap2 ( i , j ) call dgotit ( l , m , n ) advgot1 ( i , j ) = advgot2 ( i , j ) call dlluvi ( l , m , n ) advllu1 ( i , j ) = advllu2 ( i , j ) call dcrist ( l , m , n ) advcri1 ( i , j ) = advcri2 ( i , j ) call dnieve ( l , m , n ) advnie1 ( i , j ) = advnie2 ( i , j ) call dgrani ( l , m , n ) advgra1 ( i , j ) = advgra2 ( i , j ) call daeros ( l , m , n ) advaer1 ( i , j ) = advaer2 ( i , j ) !limites de la nube if ( drop_new ( i , j , k ) /= 0 ) then if ( i < lgot ( 1 )) lgot ( 1 ) = i if ( i > lgot ( 2 )) lgot ( 2 ) = i if ( j < mgot ( 1 )) mgot ( 1 ) = j if ( j > mgot ( 2 )) mgot ( 2 ) = j if ( k < ngot ( 1 )) ngot ( 1 ) = k if ( k > ngot ( 2 )) ngot ( 2 ) = k s = s + 1 end if !limites de la lluvia if ( rain_new ( i , j , k ) /= 0 ) then if ( i < lllu ( 1 )) lllu ( 1 ) = i if ( i > lllu ( 2 )) lllu ( 2 ) = i if ( j < mllu ( 1 )) mllu ( 1 ) = j if ( j > mllu ( 2 )) mllu ( 2 ) = j if ( k < nllu ( 1 )) nllu ( 1 ) = k if ( k > nllu ( 2 )) nllu ( 2 ) = k llluneg = 1 end if !limites de los cristales if ( crystal_new ( i , j , k ) /= 0 ) then if ( i < lcri ( 1 )) lcri ( 1 ) = i if ( i > lcri ( 2 )) lcri ( 2 ) = i if ( j < mcri ( 1 )) mcri ( 1 ) = j if ( j > mcri ( 2 )) mcri ( 2 ) = j if ( k < ncri ( 1 )) ncri ( 1 ) = k if ( k > ncri ( 2 )) ncri ( 2 ) = k lcrineg = 1 end if !limites de la nieve if ( snow_new ( i , j , k ) /= 0 ) then if ( i < lnie ( 1 )) lnie ( 1 ) = i if ( i > lnie ( 2 )) lnie ( 2 ) = i if ( j < mnie ( 1 )) mnie ( 1 ) = j if ( j > mnie ( 2 )) mnie ( 2 ) = j if ( k < nnie ( 1 )) nnie ( 1 ) = k if ( k > nnie ( 2 )) nnie ( 2 ) = k lnieneg = 1 end if !limites del granizo if ( hail_new ( i , j , k ) /= 0 ) then if ( i < lgra ( 1 )) lgra ( 1 ) = i if ( i > lgra ( 2 )) lgra ( 2 ) = i if ( j < mgra ( 1 )) mgra ( 1 ) = j if ( j > mgra ( 2 )) mgra ( 2 ) = j if ( k < ngra ( 1 )) ngra ( 1 ) = k if ( k > ngra ( 2 )) ngra ( 2 ) = k lgraneg = 1 end if if ( vapor_z_initial ( k ) + vapor_new ( i , j , k ) < 0 ) then Qvapneg = Qvapneg + vapor_z_initial ( k ) + vapor_new ( i , j , k ) lvapneg = 1 end if if ( aerosol_z_initial ( k ) + aerosol_new ( i , j , k ) < 0 ) then aerneg = aerneg + aerosol_z_initial ( k ) + aerosol_new ( i , j , k ) laerneg = 1 end if end do end do end do end subroutine dinamics subroutine negative_correction use model_var , only : s , llluneg , lcrineg , lnieneg , lgraneg , lvapneg , laerneg , & Qvapneg , aerneg use extra_subrut , only : corgot , corllu , corcri , cornie , corgra , corvap , coraer implicit none if ( s >= 1 ) call corgot if ( llluneg == 1 ) call corllu if ( lcrineg == 1 ) call corcri if ( lnieneg == 1 ) call cornie if ( lgraneg == 1 ) call corgra if ( lvapneg == 1 ) call corvap ( Qvapneg ) if ( laerneg == 1 ) call coraer ( aerneg ) end subroutine negative_correction subroutine water_calculation !! primer calculo de agua (sin laterales) use dimensions , only : nx1 , nz1 use model_var , only : vapt1 , gott1 , aert1 use microphysics_perturbation , only : vapor_new , drop_new , aerosol_new use initial_z_state , only : vapor_z_initial implicit none integer :: i , j , k vapt1 = 0. gott1 = 0. aert1 = 0. do concurrent ( i = 1 : nx1 , j = 1 : nx1 , k = 1 : nz1 - 1 ) vapt1 = vapt1 + vapor_new ( i , j , k ) gott1 = gott1 + drop_new ( i , j , k ) aert1 = aert1 + aerosol_new ( i , j , k ) end do end subroutine water_calculation subroutine microphisics_substring !! Sublazo Microfisico use dimensions , only : nx1 , nz1 , dt1 , dx1 use model_var , only : aux , P , T , Qvap , Naer , densi , Dv , iT , aux2 , Vis , & esvs , elvs , Lvl , Lsl , Lvs , Eaccn , Eaucn , Eacng , nu , lll , current_time , & Qliq , e1 , rl , rs , yy , daer , dqgot , dqcri , Taux , totnuc , vapt2 , gott2 , & aert2 , qgotaux , qvapaux , qlluaux , qcriaux , qnieaux , qgraaux , t2 , Lsl00 , & Fcal , daer2 , totmic , vapt3 , gott3 , aert3 , ener2 , ener3 , ener4 , ener5 , & qv , qg , daitot use dinamic_var_perturbation , only : theta_new , pressure_new , & temperature , heat_force use initial_z_state , only : vapor_z_initial , aerosol_z_initial , theta_z_initial , temperature_z_initial , Pres00 use cant01 , only : ikapa , AA , lt2 use constants , only : P00 , Rd , Dv0 , Tvis , Telvs , Tesvs , Tlvl , Tlsl , Tlvs , & Eacrcn , Eautcn , T0 , Rv , G , Cp use microphysics_perturbation , only : vapor_new , aerosol_new , & drop_new , rain_new , crystal_new , & snow_new , hail_new use extra_subrut , only : nuclea use microphysics , only : microfis implicit none integer :: k , n , i , l , j , m totnuc = 0. vapt2 = 0. gott2 = 0. aert2 = 0. totmic = 0. vapt3 = 0. gott3 = 0. aert3 = 0. ener2 = 0. ener3 = 0. ener4 = 0. ener5 = 0. qv = 0. qg = 0. daitot = 0. do k = 1 , nz1 - 1 n = k do i = 1 , nx1 l = i do j = 1 , nx1 m = j !calculo de T,P,Densi,Dv,Vis aux = Pres00 ( k ) + pressure_new ( i , j , k ) P = aux ** ikapa * P00 T = ( theta_z_initial ( k ) + theta_new ( i , j , k )) * aux temperature ( i , j , k ) = T - temperature_z_initial ( k ) Qvap = vapor_z_initial ( k ) + vapor_new ( i , j , k ) Naer = aerosol_z_initial ( k ) + aerosol_new ( i , j , k ) densi = P / T / Rd - AA * Qvap Dv = Dv0 * ( T / 27 3.15 ) ** 1.94 * ( P00 / P ) !calculo de Vis, Lvl, Lsl, Lvs, elvs y  esvs iT = int ( T ) aux2 = T - iT Vis = Tvis ( iT ) * ( 1 - aux2 ) + Tvis ( iT + 1 ) * aux2 elvs = Telvs ( iT ) * ( 1 - aux2 ) + Telvs ( iT + 1 ) * aux2 esvs = Tesvs ( iT ) * ( 1 - aux2 ) + Tesvs ( iT + 1 ) * aux2 Lvl = Tlvl ( iT ) * ( 1 - aux2 ) + Tlvl ( iT + 1 ) * aux2 Lsl = Tlsl ( iT ) * ( 1 - aux2 ) + Tlsl ( iT + 1 ) * aux2 Lvs = Tlvs ( iT ) * ( 1 - aux2 ) + Tlvs ( iT + 1 ) * aux2 Eaccn = Eacrcn ( iT ) * ( 1 - aux2 ) + Eacrcn ( iT + 1 ) * aux2 Eaucn = Eautcn ( iT ) * ( 1 - aux2 ) + Eautcn ( iT + 1 ) * aux2 if ( T >= T0 ) then Eacng = 1. else Eacng = exp (. 08 * ( T - T0 )) end if nu = Vis / densi !nucleacion (de ser necesario tiene otro paso de tiempo) lll = current_time Qliq = drop_new ( i , j , k ) e1 = Qvap * Rv * T rl = ( e1 - elvs ) / elvs rs = ( e1 - esvs ) / esvs yy = 0 if (( rl > 1e-3 . or . rs > 1e-3 ) . and . Naer > 0 ) then call nuclea ( Qvap , Qliq , Naer , T , densi , e1 , elvs , esvs , rl , rs , Lvl , Lvs , daer , dqgot , dqcri ) Taux = T - temperature_z_initial ( k ) - temperature ( i , j , k ) theta_new ( i , j , k ) = T / aux - theta_z_initial ( k ) if ( dqgot > 0 ) yy = 1 else Taux = 0. dqgot = 0. dqcri = 0. daer = 0. end if totnuc = totnuc + daer !segundo calculo de agua (sin laterales) vapt2 = vapt2 + vapor_new ( i , j , k ) gott2 = gott2 + drop_new ( i , j , k ) aert2 = aert2 + aerosol_new ( i , j , k ) if ( drop_new ( i , j , k ) > 0 & . or . dqgot > 0 & . or . rain_new ( i , j , k ) > 0 & . or . crystal_new ( i , j , k ) > 0 & . or . snow_new ( i , j , k ) > 0 ) then qgotaux = drop_new ( i , j , k ) if ( drop_new ( i , j , k ) == 0 ) qgotaux = 0 d0 qvapaux = vapor_new ( i , j , k ) + vapor_z_initial ( k ) qlluaux = rain_new ( i , j , k ) if ( rain_new ( i , j , k ) == 0 ) qlluaux = 0 d0 qcriaux = crystal_new ( i , j , k ) if ( crystal_new ( i , j , k ) == 0 ) then qcriaux = 0 d0 end if qnieaux = snow_new ( i , j , k ) if ( snow_new ( i , j , k ) == 0 ) qnieaux = 0 d0 qgraaux = hail_new ( i , j , k ) if ( hail_new ( i , j , k ) == 0 ) qgraaux = 0 d0 Naer = aerosol_new ( i , j , k ) + aerosol_z_initial ( k ) T = temperature ( i , j , k ) + temperature_z_initial ( k ) do t2 = 1 , lt2 qgotaux = qgotaux + dqgot / float ( lt2 ) qcriaux = qcriaux + dqcri / float ( lt2 ) qvapaux = qvapaux - ( dqgot + dqcri ) / float ( lt2 ) Naer = Naer + daer / float ( lt2 ) T = T + Taux / float ( lt2 ) !calculo de elvs y esvs iT = int ( T ) aux2 = T - iT elvs = Telvs ( iT ) * ( 1 - aux2 ) + Telvs ( iT + 1 ) * aux2 esvs = Tesvs ( iT ) * ( 1 - aux2 ) + Tesvs ( iT + 1 ) * aux2 call microfis ( elvs , esvs , Lvl , Lvs , Lsl , T , Dv , Eaccn , & Eaucn , Eacng , Lsl00 , Fcal , n , qvapaux , qgotaux , qlluaux , & qcriaux , qnieaux , qgraaux , Naer , daer2 , nu , yy ) heat_force ( l , m , n ) = heat_force ( l , m , n ) + Fcal / dt1 / densi Naer = Naer + daer2 totmic = totmic + daer2 end do drop_new ( i , j , k ) = qgotaux rain_new ( i , j , k ) = qlluaux crystal_new ( i , j , k ) = qcriaux snow_new ( i , j , k ) = qnieaux hail_new ( i , j , k ) = qgraaux vapor_new ( i , j , k ) = qvapaux - vapor_z_initial ( k ) aerosol_new ( i , j , k ) = Naer - aerosol_z_initial ( k ) temperature ( i , j , k ) = T - temperature_z_initial ( k ) end if if ( aerosol_new ( i , j , k ) + aerosol_z_initial ( k ) <= 0 ) then aerosol_new ( i , j , k ) = - aerosol_z_initial ( k ) end if !tercer calculo de agua (sin laterales) vapt3 = vapt3 + vapor_new ( i , j , k ) gott3 = gott3 + drop_new ( i , j , k ) aert3 = aert3 + aerosol_new ( i , j , k ) !calculo de la energia ener2 = densi * G * k * dx1 + ener2 ener3 = densi * ( Cp - Rd ) * T + ener3 ener4 = P + ener4 ener5 = ( vapor_new ( i , j , k ) + drop_new ( i , j , k )) * G * k * dx1 + ener5 qv = vapor_new ( i , j , k ) + qv qg = drop_new ( i , j , k ) + qg daitot = densi + daitot end do end do end do end subroutine microphisics_substring subroutine floor_and_ceiling_contour !! contornos en el piso y en el techo use dimensions , only : nx1 , nz1 , dt1 , dx1 use dinamic_var_perturbation , only : theta_new , theta_base , & w_perturbed_new , u_perturbed_new , v_perturbed_new use cant01 , only : dx2 use initial_z_state , only : theta_z_initial , vapor_z_initial , aerosol_z_initial use model_var , only : auxx , auxy , auxz , turbu , aeraux , lapla , cks , Qvap , & qv , qg use microphysics_perturbation , only : vapor_base , vapor_new , & drop_new , crystal_new , rain_new , & snow_new , hail_new , aerosol_base , aerosol_new implicit none integer :: i , j Qvap = ( qv + qg ) / nx1 ** 2. * nz1 * . 1 do concurrent ( i = 1 : nx1 , j = 1 : nx1 ) theta_new ( i , j , 0 ) = theta_base ( i , j , 0 ) - & w_perturbed_new ( i , j , 1 ) * ( theta_z_initial ( 0 ) + theta_z_initial ( 1 )) * dt1 / dx2 theta_new ( i , j , nz1 ) = theta_new ( i , j , nz1 - 1 ) !suponemos que las velocidades horizontales a nivel de piso son !iguales a 1/4 de la correspondiente en el nivel 1 auxx = (( u_perturbed_new ( i + 1 , j , 1 ) + u_perturbed_new ( i , j , 1 )) * ( vapor_base ( i + 1 , j , 0 ) + vapor_base ( i , j , 0 )) & - ( u_perturbed_new ( i - 1 , j , 1 ) + u_perturbed_new ( i , j , 1 )) * ( vapor_base ( i - 1 , j , 0 ) + vapor_base ( i , j , 0 ))) & / 4. * . 25 auxy = (( v_perturbed_new ( i , j + 1 , 1 ) + v_perturbed_new ( i , j , 1 )) * ( vapor_base ( i , j + 1 , 0 ) + vapor_base ( i , j , 0 )) & - ( v_perturbed_new ( i , j - 1 , 1 ) + v_perturbed_new ( i , j , 1 )) * ( vapor_base ( i , j - 1 , 0 ) + vapor_base ( i , j , 0 ))) & / 4. * . 25 auxz = w_perturbed_new ( i , j , 1 ) & * (( vapor_base ( i , j , 1 ) + vapor_base ( i , j , 0 )) + vapor_z_initial ( 1 ) + vapor_z_initial ( 0 )) / 2. * . 5 vapor_new ( i , j , nz1 ) = vapor_new ( i , j , nz1 - 1 ) drop_new ( i , j , 0 ) = drop_new ( i , j , 1 ) drop_new ( i , j , nz1 ) = drop_new ( i , j , nz1 - 1 ) crystal_new ( i , j , 0 ) = crystal_new ( i , j , 1 ) crystal_new ( i , j , nz1 ) = crystal_new ( i , j , nz1 - 1 ) !Para que no se acumulen el piso rain_new ( i , j , 0 ) = rain_new ( i , j , 1 ) / 2. rain_new ( i , j , nz1 ) = rain_new ( i , j , nz1 - 1 ) snow_new ( i , j , 0 ) = snow_new ( i , j , 1 ) snow_new ( i , j , nz1 ) = snow_new ( i , j , nz1 - 1 ) !Para que no se acumulen el piso hail_new ( i , j , 0 ) = hail_new ( i , j , 1 ) / 2. hail_new ( i , j , nz1 ) = hail_new ( i , j , nz1 - 1 ) !suponemos que las velocidades horizontales a nivel de piso son !iguales a 1/4 de la correspondiente en el nivel 1 auxx = (( u_perturbed_new ( i + 1 , j , 1 ) + u_perturbed_new ( i , j , 1 )) * ( aerosol_base ( i + 1 , j , 0 ) + aerosol_base ( i , j , 0 )) & - ( u_perturbed_new ( i - 1 , j , 1 ) + u_perturbed_new ( i , j , 1 )) * ( aerosol_base ( i - 1 , j , 0 ) + aerosol_base ( i , j , 0 ))) & / 4. * . 25 auxy = (( v_perturbed_new ( i , j + 1 , 1 ) + v_perturbed_new ( i , j , 1 )) * ( aerosol_base ( i , j + 1 , 0 ) + aerosol_base ( i , j , 0 )) & - ( v_perturbed_new ( i , j - 1 , 1 ) + v_perturbed_new ( i , j , 1 )) * ( aerosol_base ( i , j - 1 , 0 ) + aerosol_base ( i , j , 0 ))) & / 4. * . 25 auxz = w_perturbed_new ( i , j , 1 ) * & (( aerosol_base ( i , j , 1 ) + aerosol_base ( i , j , 0 )) + aerosol_z_initial ( 1 ) + aerosol_z_initial ( 0 )) / 2. * . 5 if ( w_perturbed_new ( i , j , 0 ) > 0 ) then aeraux = - (( auxx + auxy ) + 2. * auxz ) * dt1 / dx1 else !se refleja un 25 % de los aerosoles que caen aeraux = - (( auxx + auxy ) + . 25 * 2. * auxz ) * dt1 / dx1 end if !agregamos un termino de turbulencia para los aerosoles !a nivel de piso turbu = cks / dx1 * . 25 * ( abs ( u_perturbed_new ( i , j , 1 )) & + abs ( v_perturbed_new ( i , j , 1 )) & + 2. * abs ( w_perturbed_new ( i , j , 1 ))) lapla = (( aerosol_base ( i + 1 , j , 0 ) + aerosol_base ( i - 1 , j , 0 )) & + ( aerosol_base ( i , j + 1 , 0 ) + aerosol_base ( i , j - 1 , 0 ) & + aerosol_base ( i , j , 1 ))) & - 5. * aerosol_base ( i , j , 0 ) lapla = lapla + ( aerosol_z_initial ( 1 ) - aerosol_z_initial ( 0 )) aerosol_new ( i , j , 0 ) = aeraux + aerosol_base ( i , j , 0 ) + turbu * lapla aerosol_new ( i , j , nz1 ) = aerosol_new ( i , j , nz1 - 1 ) end do end subroutine floor_and_ceiling_contour subroutine lateral_contour !! contornos laterales use dimensions , only : nx1 , nz1 use dinamic_var_perturbation , only : theta_new use microphysics_perturbation , only : vapor_new , drop_new , & rain_new , crystal_new , snow_new , & hail_new , aerosol_new implicit none integer :: j , k do concurrent ( k = 1 : nz1 - 1 , j = 1 : nx1 ) theta_new ( 0 , j , k ) = theta_new ( 1 , j , k ) theta_new ( nx1 + 1 , j , k ) = theta_new ( nx1 , j , k ) theta_new ( j , 0 , k ) = theta_new ( j , 1 , k ) theta_new ( j , nx1 + 1 , k ) = theta_new ( j , nx1 , k ) vapor_new ( 0 , j , k ) = 0. vapor_new ( nx1 + 1 , j , k ) = 0. vapor_new ( j , 0 , k ) = 0. vapor_new ( j , nx1 + 1 , k ) = 0. drop_new ( 0 , j , k ) = drop_new ( 1 , j , k ) drop_new ( nx1 + 1 , j , k ) = drop_new ( nx1 , j , k ) drop_new ( j , 0 , k ) = drop_new ( j , 1 , k ) drop_new ( j , nx1 + 1 , k ) = drop_new ( j , nx1 , k ) rain_new ( 0 , j , k ) = 0. rain_new ( nx1 + 1 , j , k ) = 0. rain_new ( j , 0 , k ) = 0. rain_new ( j , nx1 + 1 , k ) = 0. crystal_new ( 0 , j , k ) = crystal_new ( 1 , j , k ) crystal_new ( nx1 + 1 , j , k ) = crystal_new ( nx1 , j , k ) crystal_new ( j , 0 , k ) = crystal_new ( j , 1 , k ) crystal_new ( j , nx1 + 1 , k ) = crystal_new ( j , nx1 , k ) snow_new ( 0 , j , k ) = snow_new ( 1 , j , k ) snow_new ( nx1 + 1 , j , k ) = snow_new ( nx1 , j , k ) snow_new ( j , 0 , k ) = snow_new ( j , 1 , k ) snow_new ( j , nx1 + 1 , k ) = snow_new ( j , nx1 , k ) hail_new ( 0 , j , k ) = 0. hail_new ( nx1 + 1 , j , k ) = 0. hail_new ( j , 0 , k ) = 0. hail_new ( j , nx1 + 1 , k ) = 0. aerosol_new ( 0 , j , k ) = aerosol_new ( 1 , j , k ) aerosol_new ( nx1 + 1 , j , k ) = aerosol_new ( nx1 , j , k ) aerosol_new ( j , 0 , k ) = aerosol_new ( j , 1 , k ) aerosol_new ( j , nx1 + 1 , k ) = aerosol_new ( j , nx1 , k ) end do end subroutine lateral_contour subroutine speed_pressure () !! calculo de la velocidad y la presion !! Calcula la evolucion del la presion y las velocidades con un paso de tiempo menor lt3 !! Las cantidades 1 son las presentes en el paso grande y las 2 son las del paso futuro, las 3 son auxiliares !! Le resta la perturbacion promedio use cant01 use dimensions use dinamic_var_perturbation use constants use initial_z_state use velpre01 use p3v3 use sv_inhomogeneous_velocities_and_speed_pressure , only : fu , fv , fw , fp implicit none call velpre01_init () do concurrent ( i = 0 : nx1 + 1 , j = 0 : nx1 + 1 , k = 0 : nz1 ) u_perturbed_new ( i , j , k ) = u_perturbed_base ( i , j , k ) v_perturbed_new ( i , j , k ) = v_perturbed_base ( i , j , k ) w_perturbed_new ( i , j , k ) = w_perturbed_base ( i , j , k ) pressure_new ( i , j , k ) = pressure_base ( i , j , k ) end do do concurrent ( t = 1 : lt3 ) do concurrent ( k = 1 : nz1 - 1 ) presi = - Cp * theta_z_initial ( k ) * ( 1. + . 61 * vapor_z_initial ( k ) / air_density_z_initial ( k )) vel0 = theta_z_initial ( k ) * ( air_density_z_initial ( k ) + . 61 * vapor_z_initial ( k )) vel1 = theta_z_initial ( k - 1 ) * ( air_density_z_initial ( k - 1 ) + . 61 * vapor_z_initial ( k - 1 )) vel2 = theta_z_initial ( k + 1 ) * ( air_density_z_initial ( k + 1 ) + . 61 * vapor_z_initial ( k + 1 )) vel3 = cc2 ( k ) / presi / vel0 do concurrent ( i = 1 : nx1 , j = 1 : nx1 ) dprex = pressure_new ( i + 1 , j , k ) - pressure_new ( i - 1 , j , k ) dprey = pressure_new ( i , j + 1 , k ) - pressure_new ( i , j - 1 , k ) dprez = pressure_new ( i , j , k + 1 ) - pressure_new ( i , j , k - 1 ) presix = presi * dprex / dx2 presiy = presi * dprey / dx2 presiz = presi * dprez / dx2 U3 ( i , j , k ) = dt3 * ( presix + fu ( i , j , k )) + u_perturbed_new ( i , j , k ) V3 ( i , j , k ) = dt3 * ( presiy + fv ( i , j , k )) + v_perturbed_new ( i , j , k ) W3 ( i , j , k ) = dt3 * ( presiz + fw ( i , j , k )) + w_perturbed_new ( i , j , k ) dvx = vel0 * ( u_perturbed_new ( i + 1 , j , k ) - u_perturbed_new ( i - 1 , j , k )) dvy = vel0 * ( v_perturbed_new ( i , j + 1 , k ) - v_perturbed_new ( i , j - 1 , k )) if ( k == 1 ) then !      dvz = tiene 80% de (w_perturbed_new(2)-w_perturbed_new(1) y 20% de (w_perturbed_new(1)-w_perturbed_new(0) dvz = (. 8 * vel2 * w_perturbed_new ( i , j , k + 1 ) - . 8 * vel1 * w_perturbed_new ( i , j , k )) * 2. else dvz = vel2 * w_perturbed_new ( i , j , k + 1 ) - vel1 * w_perturbed_new ( i , j , k - 1 ) end if diver = vel3 * (( dvx + dvy ) + dvz ) / dx2 !      modificado para agrega turbulencia en la P 23/8/97 Pres3 ( i , j , k ) = dt3 * ( diver + fp ( i , j , k )) + pressure_new ( i , j , k ) end do end do !*      redefiniciones y contornos do concurrent ( i = 1 : nx1 , j = 1 : nx1 ) Pres3 ( i , j , 0 ) = Pres3 ( i , j , 1 ) Pres3 ( i , j , nz1 ) = Pres3 ( i , j , nz1 - 1 ) end do do concurrent ( i = 1 : nx1 , k = 0 : nz1 ) Pres3 ( i , 0 , k ) = Pres3 ( i , 1 , k ) Pres3 ( i , nx1 + 1 , k ) = Pres3 ( i , nx1 , k ) Pres3 ( 0 , i , k ) = Pres3 ( 1 , i , k ) Pres3 ( nx1 + 1 , i , k ) = Pres3 ( nx1 , i , k ) end do presprom = 0. do concurrent ( i = 1 : nx1 , j = 1 : nx1 ) do k = 1 , nz1 - 1 if ( k == 1 ) then u_perturbed_new ( i , j , k ) = U3 ( i , j , k ) - kkk * & ( 2. * U3 ( i , j , k ) - U3 ( i , j , k + 1 )) v_perturbed_new ( i , j , k ) = V3 ( i , j , k ) - kkk * & ( 2. * V3 ( i , j , k ) - V3 ( i , j , k + 1 )) w_perturbed_new ( i , j , k ) = W3 ( i , j , k ) - kkk * & ( 2. * W3 ( i , j , k ) - W3 ( i , j , k + 1 )) else u_perturbed_new ( i , j , k ) = U3 ( i , j , k ) v_perturbed_new ( i , j , k ) = V3 ( i , j , k ) w_perturbed_new ( i , j , k ) = W3 ( i , j , k ) end if pressure_new ( i , j , k ) = prom1 * Pres3 ( i , j , k ) + prom * ( & (( Pres3 ( i + 1 , j , k ) + Pres3 ( i - 1 , j , k )) + & ( Pres3 ( i , j + 1 , k ) + Pres3 ( i , j - 1 , k ))) + & Pres3 ( i , j , k + 1 ) + Pres3 ( i , j , k - 1 )) presprom = pressure_new ( i , j , k ) + presprom end do u_perturbed_new ( i , j , 0 ) = 0 v_perturbed_new ( i , j , 0 ) = 0 w_perturbed_new ( i , j , 0 ) = 0 pressure_new ( i , j , 0 ) = pressure_new ( i , j , 1 ) u_perturbed_new ( i , j , nz1 ) = u_perturbed_new ( i , j , nz1 - 1 ) v_perturbed_new ( i , j , nz1 ) = v_perturbed_new ( i , j , nz1 - 1 ) w_perturbed_new ( i , j , nz1 ) = w_perturbed_new ( i , j , nz1 - 1 ) pressure_new ( i , j , nz1 ) = pressure_new ( i , j , nz1 - 1 ) end do do concurrent ( i = 1 : nx1 , k = 0 : nz1 ) u_perturbed_new ( 0 , i , k ) = u_perturbed_new ( 1 , i , k ) v_perturbed_new ( 0 , i , k ) = v_perturbed_new ( 1 , i , k ) w_perturbed_new ( 0 , i , k ) = w_perturbed_new ( 1 , i , k ) pressure_new ( 0 , i , k ) = pressure_new ( 1 , i , k ) u_perturbed_new ( nx1 + 1 , i , k ) = u_perturbed_new ( nx1 , i , k ) v_perturbed_new ( nx1 + 1 , i , k ) = v_perturbed_new ( nx1 , i , k ) w_perturbed_new ( nx1 + 1 , i , k ) = w_perturbed_new ( nx1 , i , k ) pressure_new ( nx1 + 1 , i , k ) = pressure_new ( nx1 , i , k ) u_perturbed_new ( i , 0 , k ) = u_perturbed_new ( i , 1 , k ) v_perturbed_new ( i , 0 , k ) = v_perturbed_new ( i , 1 , k ) w_perturbed_new ( i , 0 , k ) = w_perturbed_new ( i , 1 , k ) pressure_new ( i , 0 , k ) = pressure_new ( i , 1 , k ) u_perturbed_new ( i , nx1 + 1 , k ) = u_perturbed_new ( i , nx1 , k ) v_perturbed_new ( i , nx1 + 1 , k ) = v_perturbed_new ( i , nx1 , k ) w_perturbed_new ( i , nx1 + 1 , k ) = w_perturbed_new ( i , nx1 , k ) pressure_new ( i , nx1 + 1 , k ) = pressure_new ( i , nx1 , k ) end do presprom = presprom / nnn do concurrent ( i = 0 : nx1 + 1 , j = 0 : nx1 + 1 , k = 0 : nz1 ) pressure_new ( i , j , k ) = pressure_new ( i , j , k ) - presprom end do if ( t == lt3 / 2 ) then do concurrent ( i = 0 : nx1 + 1 , j = 0 : nx1 + 1 , k = 0 : nz1 ) u_perturbed_base ( i , j , k ) = u_perturbed_new ( i , j , k ) v_perturbed_base ( i , j , k ) = v_perturbed_new ( i , j , k ) w_perturbed_base ( i , j , k ) = w_perturbed_new ( i , j , k ) pressure_base ( i , j , k ) = pressure_new ( i , j , k ) end do end if end do !********************************************************** !*    suavizado call filtro ( pressure_base , . 15 , . 15 , . 1 ) call filtro ( pressure_new , . 15 , . 15 , . 1 ) call filtro ( u_perturbed_base , facx , facy , facz ) call filtro ( u_perturbed_new , facx , facy , facz ) call filtro ( v_perturbed_base , facx , facy , facz ) call filtro ( v_perturbed_new , facx , facy , facz ) call filtro ( w_perturbed_base , facx , facy , facz ) call filtro ( w_perturbed_new , facx , facy , facz ) do concurrent ( i = 1 : nx1 , j = 1 : nx1 ) pressure_base ( i , j , 0 ) = pressure_base ( i , j , 1 ) pressure_new ( i , j , 0 ) = pressure_new ( i , j , 1 ) end do !********************************************************** return end subroutine speed_pressure subroutine filtro ( varia1 , facx , facy , facz ) !! filtro para theta_base vapor_base !! Esta subrutina filtra componentes de alta frecuencia espacial. !! El valor de la variable del punto j se filtra con los valores !! extrapolados linalmente de los puntos j-3 y j-1 y similares, !! pasando un polinomio de grado 4 use dimensions use filtro01 implicit none character * 50 text REAL , DIMENSION ( - 3 : NX1 + 3 , - 3 : NX1 + 3 , - 2 : NZ1 + 2 ), intent ( inout ) :: varia1 real , intent ( in ) :: facx , facy , facz fact = 1. - ( facx + facy + facz ) !********************************************************** !     Redefiniciones y contornos do concurrent ( i = 0 : nx1 + 1 , j = 0 : nx1 + 1 , k = 0 : nz1 ) varia2 ( i , j , k ) = varia1 ( i , j , k ) end do do concurrent ( k = 0 : nz1 , i = 0 : nx1 ) varia2 ( i , - 1 , k ) = varia2 ( i , 1 , k ) varia2 ( i , - 2 , k ) = varia2 ( i , 1 , k ) varia2 ( i , nx1 + 2 , k ) = varia2 ( i , nx1 , k ) varia2 ( i , nx1 + 3 , k ) = varia2 ( i , nx1 , k ) varia2 ( - 1 , i , k ) = varia2 ( 1 , i , k ) varia2 ( - 2 , i , k ) = varia2 ( 1 , i , k ) varia2 ( nx1 + 2 , i , k ) = varia2 ( nx1 , i , k ) varia2 ( nx1 + 3 , i , k ) = varia2 ( nx1 , i , k ) end do do concurrent ( i = 1 : nx1 , j = 1 : nx1 ) varia2 ( i , j , - 1 ) = varia2 ( i , j , 0 ) varia2 ( i , j , - 2 ) = varia2 ( i , j , 0 ) varia2 ( i , j , nz1 + 1 ) = varia2 ( i , j , nz1 ) varia2 ( i , j , nz1 + 2 ) = varia2 ( i , j , nz1 ) end do !********************************************************** !     Filtro do concurrent ( i = 1 : nx1 , j = 1 : nx1 , k = 1 : nz1 - 1 ) varx = ( 9. * ( varia2 ( i - 1 , j , k ) + varia2 ( i + 1 , j , k )) - & ( varia2 ( i - 3 , j , k ) + varia2 ( i + 3 , j , k ))) / 1 6. vary = ( 9. * ( varia2 ( i , j - 1 , k ) + varia2 ( i , j + 1 , k )) - & ( varia2 ( i , j - 3 , k ) + varia2 ( i , j + 3 , k ))) / 1 6. varz = ( 9. * ( varia2 ( i , j , k - 1 ) + varia2 ( i , j , k + 1 )) - & ( varia2 ( i , j , k - 3 ) + varia2 ( i , j , k + 3 ))) / 1 6. varia1 ( i , j , k ) = (( facx * varx + facy * vary ) + facz * varz ) + & fact * varia2 ( i , j , k ) end do do concurrent ( k = 1 : nz1 - 1 , i = 1 : nx1 ) varia1 ( i , 0 , k ) = varia1 ( i , 1 , k ) varia1 ( i , nx1 + 1 , k ) = varia1 ( i , nx1 , k ) varia1 ( 0 , i , k ) = varia1 ( 1 , i , k ) varia1 ( nx1 + 1 , i , k ) = varia1 ( nx1 , i , k ) end do do concurrent ( i = 1 : nx1 , j = 1 : nx1 ) varia1 ( i , j , nz1 ) = varia1 ( i , j , nz1 - 1 ) end do !********************************************************** return end subroutine filtro subroutine floor_condition_redefinition () !! modificada las condiciones en el piso !! Redefinicion use dimensions , only : nx1 , nz1 , dt1 , dx1 use dinamic_var_perturbation , only : theta_new , theta_base , & w_perturbed_new use cant01 , only : pro3 , pro4 , pro1 , pro2 use microphysics_perturbation , only : vapor_base , vapor_new , & drop_new , rain_new , crystal_new , & snow_new , hail_new , aerosol_base , aerosol_new , & drop_base , rain_base , crystal_base , snow_base , hail_base use initial_z_state , only : aerosol_z_initial use model_var , only : aeraux implicit none integer :: i , j , k do concurrent ( i = 1 : nx1 , j = 1 : nx1 ) k = 0 theta_base ( i , j , k ) = pro3 * theta_new ( i , j , k ) + & pro4 * ( & ( theta_new ( i + 1 , j , k ) + theta_new ( i - 1 , j , k )) + & ( theta_new ( i , j + 1 , k ) + theta_new ( i , j - 1 , k ))) if ( abs ( theta_base ( i , j , k )) < 1e-10 ) theta_base ( i , j , k ) = 0 vapor_base ( i , j , k ) = pro3 * vapor_new ( i , j , k ) & + pro4 * ( & ( vapor_new ( i + 1 , j , k ) + vapor_new ( i - 1 , j , k )) + & ( vapor_new ( i , j + 1 , k ) + vapor_new ( i , j - 1 , k ))) if ( abs ( vapor_base ( i , j , k )) < 1e-10 ) vapor_base ( i , j , k ) = 0 drop_base ( i , j , k ) = pro3 * drop_new ( i , j , k ) + & pro4 * ( & ( drop_new ( i + 1 , j , k ) + drop_new ( i - 1 , j , k )) + & ( drop_new ( i , j + 1 , k ) + drop_new ( i , j - 1 , k ))) if ( drop_base ( i , j , k ) < 1e-10 ) drop_base ( i , j , k ) = 0 rain_base ( i , j , k ) = rain_new ( i , j , k ) if ( rain_base ( i , j , k ) < 1e-10 ) rain_base ( i , j , k ) = 0 crystal_base ( i , j , k ) = pro3 * crystal_new ( i , j , k ) + & pro4 * ( & ( crystal_new ( i + 1 , j , k ) + crystal_new ( i - 1 , j , k )) + & ( crystal_new ( i , j + 1 , k ) + crystal_new ( i , j - 1 , k ))) if ( crystal_base ( i , j , k ) < 1e-10 ) crystal_base ( i , j , k ) = 0 snow_base ( i , j , k ) = pro3 * snow_new ( i , j , k ) + & pro4 * ( & ( snow_new ( i + 1 , j , k ) + snow_new ( i - 1 , j , k )) + & ( snow_new ( i , j + 1 , k ) + snow_new ( i , j - 1 , k ))) if ( snow_base ( i , j , k ) < 1e-10 ) snow_base ( i , j , k ) = 0 hail_base ( i , j , k ) = hail_new ( i , j , k ) if ( hail_base ( i , j , k ) < 1e-10 ) hail_base ( i , j , k ) = 0 aerosol_base ( i , j , k ) = pro3 * aerosol_new ( i , j , k ) + & pro4 * ( & ( aerosol_new ( i + 1 , j , k ) + aerosol_new ( i - 1 , j , k )) + & ( aerosol_new ( i , j + 1 , k ) + aerosol_new ( i , j - 1 , k ))) !correccion cambiando la absorcion de aerosoles if (( rain_base ( i , j , 1 ) + hail_base ( i , j , 1 )) > 1e-6 . and . w_perturbed_new ( i , j , 1 ) < 0 ) then aeraux = - w_perturbed_new ( i , j , 1 ) * . 5 * dt1 / ( dx1 / 2 ) aerosol_base ( i , j , k ) = aerosol_base ( i , j , k ) - ( aerosol_base ( i , j , k ) + aerosol_z_initial ( k )) * aeraux end if if ( abs ( aerosol_base ( i , j , k )) < 1e-10 ) aerosol_base ( i , j , k ) = 0 do concurrent ( k = 1 : nz1 - 1 ) theta_base ( i , j , k ) = pro1 * theta_new ( i , j , k ) + & pro2 * ( & ( theta_new ( i + 1 , j , k ) + theta_new ( i - 1 , j , k )) + & ( theta_new ( i , j + 1 , k ) + theta_new ( i , j - 1 , k )) + & theta_new ( i , j , k + 1 ) + & theta_new ( i , j , k - 1 )) if ( abs ( theta_base ( i , j , k )) < 1e-10 ) theta_base ( i , j , k ) = 0 vapor_base ( i , j , k ) = pro1 * vapor_new ( i , j , k ) + & pro2 * ( & ( vapor_new ( i + 1 , j , k ) + vapor_new ( i - 1 , j , k )) + & ( vapor_new ( i , j + 1 , k ) + vapor_new ( i , j - 1 , k )) + & vapor_new ( i , j , k + 1 ) + & vapor_new ( i , j , k - 1 )) if ( abs ( vapor_base ( i , j , k )) < 1e-10 ) vapor_base ( i , j , k ) = 0 drop_base ( i , j , k ) = pro1 * drop_new ( i , j , k ) + & pro2 * ( & ( drop_new ( i + 1 , j , k ) + drop_new ( i - 1 , j , k )) + & ( drop_new ( i , j + 1 , k ) + drop_new ( i , j - 1 , k )) + & drop_new ( i , j , k + 1 ) + & drop_new ( i , j , k - 1 )) if ( drop_base ( i , j , k ) < 1e-10 ) drop_base ( i , j , k ) = 0 rain_base ( i , j , k ) = pro1 * rain_new ( i , j , k ) + & pro2 * ( & ( rain_new ( i + 1 , j , k ) + rain_new ( i - 1 , j , k )) + & ( rain_new ( i , j + 1 , k ) + rain_new ( i , j - 1 , k )) + & rain_new ( i , j , k + 1 ) + & rain_new ( i , j , k - 1 )) if ( rain_base ( i , j , k ) < 1e-10 ) rain_base ( i , j , k ) = 0 crystal_base ( i , j , k ) = pro1 * crystal_new ( i , j , k ) + & pro2 * ( & ( crystal_new ( i + 1 , j , k ) + crystal_new ( i - 1 , j , k )) + & ( crystal_new ( i , j + 1 , k ) + crystal_new ( i , j - 1 , k )) + & crystal_new ( i , j , k + 1 ) + & crystal_new ( i , j , k - 1 )) if ( crystal_base ( i , j , k ) < 1e-10 ) crystal_base ( i , j , k ) = 0 snow_base ( i , j , k ) = pro1 * snow_new ( i , j , k ) + & pro2 * ( & ( snow_new ( i + 1 , j , k ) + snow_new ( i - 1 , j , k )) + & ( snow_new ( i , j + 1 , k ) + snow_new ( i , j - 1 , k )) + & snow_new ( i , j , k + 1 ) + & snow_new ( i , j , k - 1 )) if ( snow_base ( i , j , k ) < 1e-10 ) snow_base ( i , j , k ) = 0 hail_base ( i , j , k ) = pro1 * hail_new ( i , j , k ) + & pro2 * ( & ( hail_new ( i + 1 , j , k ) + hail_new ( i - 1 , j , k )) + & ( hail_new ( i , j + 1 , k ) + hail_new ( i , j - 1 , k )) + & hail_new ( i , j , k + 1 ) + & hail_new ( i , j , k - 1 )) if ( hail_base ( i , j , k ) < 1e-10 ) hail_base ( i , j , k ) = 0 aerosol_base ( i , j , k ) = pro1 * aerosol_new ( i , j , k ) + & pro2 * ( & ( aerosol_new ( i + 1 , j , k ) + aerosol_new ( i - 1 , j , k )) + & ( aerosol_new ( i , j + 1 , k ) + aerosol_new ( i , j - 1 , k )) + & aerosol_new ( i , j , k + 1 ) + & aerosol_new ( i , j , k - 1 )) if ( abs ( aerosol_base ( i , j , k )) < 1e-10 ) aerosol_base ( i , j , k ) = 0 end do end do end subroutine floor_condition_redefinition subroutine floor_and_ceiling_contour_redefinition () !! contornos en el piso y en el techo use dimensions , only : nx1 , nz1 use dinamic_var_perturbation , only : theta_base use microphysics_perturbation , only : vapor_base , aerosol_base , drop_base , & rain_base , crystal_base , snow_base , hail_base use initial_z_state , only : vapor_z_initial , aerosol_z_initial implicit none integer :: i , j do concurrent ( i = 1 : nx1 , j = 1 : nx1 ) theta_base ( i , j , 0 ) = theta_base ( i , j , 0 ) if ( theta_base ( i , j , 0 ) > 0.5 ) theta_base ( i , j , 0 ) = . 5 if ( - theta_base ( i , j , 0 ) > 0.5 ) theta_base ( i , j , 0 ) = - . 5 theta_base ( i , j , nz1 ) = theta_base ( i , j , nz1 - 1 ) !corregido para el vapor if ( vapor_base ( i , j , 0 ) > vapor_z_initial ( 0 ) * . 5 ) then vapor_base ( i , j , 0 ) = . 8 * vapor_z_initial ( 0 ) end if if ( - vapor_base ( i , j , 0 ) > vapor_z_initial ( 0 ) * . 5 ) then vapor_base ( i , j , 0 ) = - . 8 * vapor_z_initial ( 0 ) end if vapor_base ( i , j , nz1 ) = vapor_base ( i , j , nz1 - 1 ) drop_base ( i , j , 0 ) = 0. drop_base ( i , j , nz1 ) = drop_base ( i , j , nz1 - 1 ) rain_base ( i , j , 0 ) = rain_base ( i , j , 0 ) rain_base ( i , j , nz1 ) = rain_base ( i , j , nz1 - 1 ) crystal_base ( i , j , 0 ) = 0. crystal_base ( i , j , nz1 ) = crystal_base ( i , j , nz1 - 1 ) snow_base ( i , j , 0 ) = 0. snow_base ( i , j , nz1 ) = snow_base ( i , j , nz1 - 1 ) hail_base ( i , j , 0 ) = hail_base ( i , j , 0 ) hail_base ( i , j , nz1 ) = hail_base ( i , j , nz1 - 1 ) !corregido para los aerosoles if ( - aerosol_base ( i , j , 0 ) > 0.8 * aerosol_z_initial ( 0 )) then aerosol_base ( i , j , 0 ) = - . 8 * aerosol_z_initial ( 0 ) end if aerosol_base ( i , j , nz1 ) = aerosol_base ( i , j , nz1 - 1 ) end do end subroutine floor_and_ceiling_contour_redefinition subroutine lateral_contour_redefinition () !! contornos laterales use dimensions , only : nx1 , nz1 use dinamic_var_perturbation , only : theta_base use microphysics_perturbation , only : vapor_base , drop_base , rain_base , & crystal_base , snow_base , hail_base , aerosol_base implicit none integer :: j , k do concurrent ( k = 1 : nz1 - 1 , j = 1 : nx1 ) theta_base ( 0 , j , k ) = theta_base ( 1 , j , k ) theta_base ( nx1 + 1 , j , k ) = theta_base ( nx1 , j , k ) theta_base ( j , 0 , k ) = theta_base ( j , 1 , k ) theta_base ( j , nx1 + 1 , k ) = theta_base ( j , nx1 , k ) vapor_base ( 0 , j , k ) = 0. vapor_base ( nx1 + 1 , j , k ) = 0. vapor_base ( j , 0 , k ) = 0. vapor_base ( j , nx1 + 1 , k ) = 0. drop_base ( 0 , j , k ) = drop_base ( 1 , j , k ) drop_base ( nx1 + 1 , j , k ) = drop_base ( nx1 , j , k ) drop_base ( j , 0 , k ) = drop_base ( j , 1 , k ) drop_base ( j , nx1 + 1 , k ) = drop_base ( j , nx1 , k ) rain_base ( 0 , j , k ) = 0. rain_base ( nx1 + 1 , j , k ) = 0. rain_base ( j , 0 , k ) = 0. rain_base ( j , nx1 + 1 , k ) = 0. crystal_base ( 0 , j , k ) = crystal_base ( 1 , j , k ) crystal_base ( nx1 + 1 , j , k ) = crystal_base ( nx1 , j , k ) crystal_base ( j , 0 , k ) = crystal_base ( j , 1 , k ) crystal_base ( j , nx1 + 1 , k ) = crystal_base ( j , nx1 , k ) snow_base ( 0 , j , k ) = snow_base ( 1 , j , k ) snow_base ( nx1 + 1 , j , k ) = snow_base ( nx1 , j , k ) snow_base ( j , 0 , k ) = snow_base ( j , 1 , k ) snow_base ( j , nx1 + 1 , k ) = snow_base ( j , nx1 , k ) hail_base ( 0 , j , k ) = 0. hail_base ( nx1 + 1 , j , k ) = 0. hail_base ( j , 0 , k ) = 0. hail_base ( j , nx1 + 1 , k ) = 0. aerosol_base ( 0 , j , k ) = aerosol_base ( 1 , j , k ) aerosol_base ( nx1 + 1 , j , k ) = aerosol_base ( nx1 , j , k ) aerosol_base ( j , 0 , k ) = aerosol_base ( j , 1 , k ) aerosol_base ( j , nx1 + 1 , k ) = aerosol_base ( j , nx1 , k ) end do end subroutine lateral_contour_redefinition subroutine vapour_negative_correction () !! correccion de negativos para el vapor use dimensions , only : nx1 , nz1 use microphysics_perturbation , only : vapor_base use initial_z_state , only : vapor_z_initial implicit none integer :: i , j , k do concurrent ( i = 0 : nx1 + 1 , j = 0 : nx1 + 1 , k = 0 : nz1 ) if ( vapor_base ( i , j , k ) + vapor_z_initial ( k ) < 0 ) then vapor_base ( i , j , k ) = - vapor_z_initial ( k ) end if end do end subroutine vapour_negative_correction subroutine save_backup () use model_var , only : current_time , tte , posx , posy , Xnub , Ynub , posxx , posyy , & file_number , actual_file use cant01 , only : lte , ltg , ltb use dimensions , only : dt1 use config , only : output_directory use dinamic_var_perturbation , only : w_perturbed_new , u_perturbed_new , & v_perturbed_new , heat_force , theta_new , theta_base , pressure_new , & pressure_base , u_perturbed_base , v_perturbed_base , w_perturbed_base use io , only : str_gen use microphysics_perturbation , only : aerosol_base , drop_new , & rain_new , crystal_new , snow_new , & hail_new , vapor_new , aerosol_new , & vapor_base , drop_base , rain_base , crystal_base , snow_base , hail_base , & Av , Vtgra0 , Vtnie use constants , only : Tvis , Telvs , Tesvs , Tlvl , Tlsl , Tlvs , Eacrcn , Eautcn use initial_z_state , only : air_density_z_initial , vapor_z_initial , & aerosol_z_initial , theta_z_initial , temperature_z_initial , & Pres00 , aerosol_z_relative , cc2 , & vapor_z_relative , u_z_initial , v_z_initial use model_initialization , only : cloud_position , cloud_movement , & statistics use graba , only : graba320 , graba120 implicit none integer :: unit_number if ( current_time / nint ( lte / dt1 ) * nint ( lte / dt1 ) == current_time ) then call statistics () tte = tte + 1 call cloud_position () call cloud_movement () open ( newunit = unit_number , file = output_directory // \"posnub\" // '.sa' , & ACCESS = \"append\" ) write ( unit_number , * ) tte , posx ( tte ), posy ( tte ), Xnub ( tte ), Ynub ( tte ), posxx , posyy close ( unit_number ) end if if ( current_time / nint ( ltg / dt1 ) * nint ( ltg / dt1 ) == current_time ) then file_number = str_gen ( actual_file ) call graba320 ( u_perturbed_base , v_perturbed_base , w_perturbed_base , & theta_base , pressure_base , vapor_base , drop_base , & rain_base , crystal_base , snow_base , hail_base , aerosol_base , file_number ) actual_file = actual_file + 1 end if if ( current_time / nint ( ltb / dt1 ) * nint ( ltb / dt1 ) == current_time ) then call graba120 ( air_density_z_initial , temperature_z_initial , theta_z_initial , & Pres00 , vapor_z_initial , cc2 , & aerosol_z_initial , u_z_initial , v_z_initial , & u_perturbed_base , u_perturbed_new , v_perturbed_base , v_perturbed_new , & w_perturbed_base , w_perturbed_new , theta_base , & theta_new , pressure_base , pressure_new , vapor_base , & vapor_new , drop_base , drop_new , rain_base , rain_new , crystal_base , & crystal_new , snow_base , snow_new , hail_base , hail_new , aerosol_base , & aerosol_new , heat_force , Tvis , Tlvl , Tlsl , Tlvs , Telvs , Tesvs , Av , & Vtnie , Vtgra0 , vapor_z_relative , aerosol_z_relative , Eautcn , Eacrcn ) end if end subroutine save_backup end module model_aux","tags":"","loc":"sourcefile/model_aux.f90.html"},{"title":"model.f90 – cloud_model","text":"Source Code module cloud_model !! This module contains the cloud model implementation. contains subroutine model () !! Incluye microfisica con vapor, gotitas, lluvia, cristales, nieve !! y granizos (por unidad de volumen) !! Con viento de corte. !! Este modelo simula una nube tridimensional, con diferencias !! finitas adelantadas en el tiempo y centradas en el espacio !! Este modelo (asi como sus variantes) sirve de test !! Las grillas son las mismas para las cantidades dinamicas y !! microfisicas, como asi tambien los intervalos de tiempo. !! Todas las variables son reales*4 !! Condiciones de contorno homogeneas para las variables microfisicas !! Graba el valor de todas las variables cada ltb segundos. !! Graba el valor de las variables para analisis cada ltg segundos. !! Condicion de contorno nula para el vapor !! Contempla el desplazamiento de la nube. !! Mejora la condicion en el piso para los aerosoles cuando hay agua (815) use cant01 , only : total_time use model_var , only : current_time use dinamic_var_perturbation , only : theta_base use model_initialization , only : initialize_model use model_aux , only : vapor_advection , dinamics , negative_correction , water_calculation , & microphisics_substring , floor_and_ceiling_contour , lateral_contour , & floor_condition_redefinition , floor_and_ceiling_contour_redefinition , & lateral_contour_redefinition , vapour_negative_correction , save_backup , & speed_pressure , filtro use , intrinsic :: iso_fortran_env , only : I4P => int32 , R8P => real64 use , intrinsic :: iso_fortran_env use forbear , only : bar_object implicit none type ( bar_object ) :: progress_bar real ( R8P ) :: progress_percent call initialize_model () call progress_bar % initialize ( filled_char_string = '㊂' , empty_char_string = '●' , & suffix_string = '| ' , add_progress_percent = . true ., prefix_string = 'Progress |' , & scale_bar_color_fg = 'blue' , scale_bar_style = 'underline_on' , spinner_string = '(  ●   )' ) call progress_bar % start do current_time = 1 , total_time call vapor_advection () call dinamics () call negative_correction () call water_calculation () call microphisics_substring () call floor_and_ceiling_contour () call lateral_contour () call speed_pressure () call floor_condition_redefinition () call floor_and_ceiling_contour_redefinition () call lateral_contour_redefinition () call filtro ( theta_base , . 01 , . 01 , . 02 ) call vapour_negative_correction () call save_backup () progress_percent = real ( current_time , R8P ) / real ( total_time , R8P ) call progress_bar % update ( current = progress_percent ) end do call progress_bar % destroy end subroutine model end module cloud_model","tags":"","loc":"sourcefile/model.f90.html"},{"title":"constants.f90 – cloud_model","text":"Source Code module dimensions !!Defines parameters related to grid dimensions and intervals. !!              These parameters are used in numerical simulations. integer , parameter :: nx1 = 50 !! Number of points in the x-direction integer , parameter :: nz1 = 45 !! Number of points in the z-direction (first grid) integer , parameter :: nz = 64 !! Number of points in the z-direction (possibly a different grid) real , parameter :: dx1 = 30 0.0 !! Spatial interval (grid spacing) in the x-direction real , parameter :: dt1 = 2.0 !! Time interval for the main simulation real , parameter :: dt2 = 1.0 !! Time interval for microphysics real , parameter :: dt3 = 0.2 !! Time interval for speed-pressure end module dimensions module constants !! constants !! Defines mathematical and physical constants relevant to precipitation. !! These constants are used in numerical simulations and atmospheric modeling. real , parameter :: pi = 3.1415926 !! Mathematical constants real , parameter :: gam1p8 = 0.9134 !! Constant related to gamma function real , parameter :: gam2p8 = 1.6765 !! Constant related to gamma function real , parameter :: gam3p8 = 4.6941742 !! Constant related to gamma function real , parameter :: gam4p8 = 1 7.837862 !! Constant related to gamma function real , parameter :: G = 9.8 !! Acceleration due to gravity (m/s&#94;2) real , parameter :: Rd = 28 7.04 !! Specific gas constants (dry air and water vapor) real , parameter :: Rv = 46 1.05 !! Specific gas constants (dry air and water vapor) real , parameter :: Kapa = 0.2857 !! Ratio of specific heats (dry air) real , parameter :: Eps = 0.622646 !! Ratio of molecular weights (water vapor to dry air) real , parameter :: T0 = 27 3.15 !! Reference temperature (Kelvin) real , parameter :: P00 = 101300 !! Reference pressure (Pa) real , parameter :: Kair = 2.40e-2 !! Kinematic viscosity of air (m&#94;2/s) real , parameter :: Cwl = 421 8. !! Specific heat capacities (liquid water) real , parameter :: Cwv = 183 9. !! Specific heat capacities (water vapor) real , parameter :: Cwi = 210 6. !! Specific heat capacities (ice) real , parameter :: Lvl0 = 2.500e6 !! Latent heats (vapor-liquid) real , parameter :: Lsl0 = 7 9.7 !! Latent heats (solid-liquid) real , parameter :: Lvs0 = 2.835e6 !! Latent heats (vapor-solid) real , parameter :: Cp = 100 3. !! Specific heat capacities (constant pressure) real , parameter :: Cv = 71 6. !! Specific heat capacities (constant volume) real , parameter :: elvs0 = 61 0.78 !! Saturation vapor pressures (liquid vapor solid) real , parameter :: esvs0 = 61 0.918 !! Saturation vapor pressures (solid vapor solid) real , parameter :: Dv0 = 2.11e-5 !! Diffusivity of water vapor in air (m&#94;2/s) real , parameter :: Vis0 = 1.718e-5 !! Kinematic viscosity of air (m&#94;2/s) real , parameter :: rhow = 100 0. !! Density of water (kg/m&#94;3) real , parameter :: rhocri = 90 0. !! Densities of crystals (kg/m&#94;3) real , parameter :: rhonie = 10 0. !! Densities of snow (kg/m&#94;3) real , parameter :: rhogra = 50 0. !! Densities of hail (kg/m&#94;3) real , parameter :: N0got = 2.9e24 !! Number concentrations (cloud droplets) real , parameter :: N0llu = 491218 9. !! Number concentrations (raindrops) real , parameter :: N0nie = 1.66e5 !! Number concentrations (ice crystals) real , parameter :: N0gra = 31 0. !! Number concentrations (graupel) real , parameter :: Av0 = 145 5. !! Terminal fall velocity of ice crystals (m/s) real , parameter :: Vtnie0 = 0.5 !! Threshold velocity for ice crystal nucleation (m/s) real , parameter :: Efcol = 0.8 !! Efficiency factor for collision real , parameter :: Efcolgn = 0.7 !! Efficiency factor for collision (graupel) real :: Tvis ( 210 : 320 ) !! Temperature profile (viscous) real :: Tlvl ( 210 : 320 ) !! Temperature profile (liquid) real :: Tlsl ( 210 : 320 ) !! Temperature profile (solid-liquid) real :: Tlvs ( 210 : 320 ) !! Temperature profile (liquid-vapor-solid) real :: Telvs ( 210 : 320 ) !! Temperature profile (equilibrium liquid-vapor-solid) real :: Tesvs ( 210 : 320 ) !! Temperature profile (equilibrium solid-vapor-solid) real :: Eautcn ( 210 : 320 ) !! Equilibrium constants (liquid-vapor) real :: Eacrcn ( 210 : 320 ) !! Equilibrium constants (solid-liquid) end module constants","tags":"","loc":"sourcefile/constants.f90.html"},{"title":"MICROF05.f90 – cloud_model","text":"Source Code ! module microphysics contains subroutine microfis ( els , ess , Lvl , Lvs , Lsl , T , Dv , Eaccn , Eaucn , Eacng , Lsl00 , Fcal , n , & qvapaux , qgotaux , qlluaux , qcriaux , qnieaux , qgraaux , Naer , daer2 , nu , yy ) !! Esta subrutina resuelve lo que le pasa a las gotitas,las gotas, !! los cristales, la nieve, el granizo  y al vapor entre si. !! Si hay nucleacion de gotitas no hay condensacion de agua liquida !! Se ha modificado la parte de evaporacion teniendo en cuenta que !! se debe tender a alcanzar el nivel de saturacion use cant01 use dimensions use dinamic_var_perturbation use microphysics_perturbation use constants use microf05 implicit none real , intent ( in ) :: els , ess , Lvl , Lvs , Lsl , T , Dv , Eaccn , Eaucn , Eacng , Lsl00 , Naer , nu real , intent ( inout ) :: Fcal , daer2 real ( 8 ), intent ( inout ) :: qvapaux , qgotaux , qlluaux , qcriaux , qnieaux , qgraaux integer , intent ( in ) :: n , yy !*    Parametros comunes Nsc = nu / Dv !*    parametros de las distribuciones y variables relacionadas !     Gotitas Rgot = ( qgotaux / cteqgot ) ** ( 1 / 6. ) Ngot = 2. / 2 7. * N0got * Rgot ** 3. !     Lluvia Rllu = ( qlluaux / cteqllu ) ** ( 1 / 4. ) Nllu = N0llu * Rllu Vtm = Av ( 2 * n ) * Rllu ** . 8 Nre = 2. * Vtm * Rllu / nu A = Nre ** ( 1 / 2. ) * Nsc ** ( 1 / 3. ) if ( A <= 1.4 ) then fventl = 1. + . 108 * A ** 2. else fventl = . 78 + . 308 * A end if !     Cristales Rcri = 5e-5 if ( T < T0 ) Rcri = Rcri - 4e-5 * ( T0 - T ) / 4 0. if ( Rcri < 1e-5 ) Rcri = 1e-5 Ncri = qcriaux / ( pi * Rcri ** 3. / 10 * rhocri ) !     Nieve Rnie = ( qnieaux / cteqnie ) ** ( 1 / 4. ) Nnie = N0nie * Rnie Nre = 2. * Vtnie ( 2 * n ) * Rnie / nu if ( T <= T0 ) then fventn = . 78 + . 308 * Nsc ** ( 1. / 3. ) * Nre ** . 5 else fventn = . 86 + . 28 * Nsc ** ( 1. / 3. ) * Nre ** . 5 end if !     Granizo Rgra = ( qgraaux / cteqgra ) ** ( 1 / 4. ) Ngra = N0gra * Rgra Vtgra = Vtgra0 ( 2 * n ) * Rgra ** . 8 Nre = 2. * Vtgra * Rgra / nu fventgs = . 78 + . 308 * Nsc ** ( 1. / 3. ) * Nre ** . 5 fventgl = . 94 + . 308 * Nsc ** ( 1. / 3. ) * Nre ** . 5 s = 0 colilc = 0. coliln = 0. Fcal = 0. Naux = Naer * 1 d6 !********************************************************** !**    calculo de los distintos procesos para los hidrometeoros !********************************************************** !**   Evaporacion - Condensacion Qvls = els / Rv / T Qvls0 = elvs0 / Rv / T0 Qvss = ess / Rv / T qauxl = qvapaux - Qvls qauxl0 = qvapaux - Qvls0 qauxs = qvapaux - Qvss !*    Gotitas if ( Rgot > 0 . and . yy == 0 ) then coevgot = - 4. * pi * Dv * Rgot * Ngot * qauxl !     para que no de cantidades negativas de gotas evaporando if ( coevgot > . 95 * qgotaux / dt2 ) then coevgot = qgotaux / dt2 * . 95 s = 1 end if !     para el vapor no se pase del de saturacion if ( abs ( coevgot ) > abs (. 95 * qauxl / dt2 )) coevgot = - . 95 * qauxl / dt2 else coevgot = 0. end if !*    Lluvia if ( Rllu > 0 . and . yy == 0 ) then coevllu = - 4. * pi * Dv * qauxl * Rllu * Nllu * fventl !     para que no de cantidades negativas de gotas evaporando if ( coevllu > . 95 * qlluaux / dt2 ) coevllu = qlluaux / dt2 * . 95 !     para el vapor no se pase del de saturacion if ( abs ( coevllu ) > abs (. 95 * qauxl / dt2 )) coevllu = - . 95 * qauxl / dt2 else coevllu = 0. end if !*    Cristales If ( qcriaux > 0 . and . T < T0 ) then coevcri = - 8. * Dv * qauxs * Rcri * Ncri !     para que no de cantidades negativas de cristales evaporando if ( coevcri > . 95 * qcriaux / dt2 ) coevcri = qcriaux / dt2 * . 95 !     para el vapor no se pase del de saturacion if ( abs ( coevcri ) > abs (. 95 * qauxs / dt2 )) coevcri = - . 95 * qauxs / dt2 else coevcri = 0. end if !*    Nieve if ( Rnie > 0 ) then if ( T < T0 ) then coevnie = - 8. * Dv * qauxs * Rnie * Nnie * fventn else coevnie = - 8. * Dv * qauxl0 * Rnie * Nnie * fventn end if !     para que no de cantidades negativas de nieve evaporando if ( coevnie > . 95 * qnieaux / dt2 ) coevnie = qnieaux / dt2 * . 95 !     para el vapor no se pase del de saturacion if ( abs ( coevnie ) > abs (. 95 * qauxs / dt2 )) coevnie = - . 95 * qauxs / dt2 else coevnie = 0. end if !*    para granizos (sup crecimiento humedo, se verifica en Tgra) if ( Rgra > 0 ) then coevgra = - 4. * pi * Dv * qauxl0 * Rgra * Ngra * fventgl !     para el vapor no se pase del de saturacion if ( abs ( coevgra ) > abs (. 95 * qauxl0 / dt2 )) coevgra = - . 95 * qauxl0 / dt2 else coevgra = 0. end if !*    para aerosoles if ( coevgot > 0 . and . yy == 0 ) then aux = max ( Rgot , Rgotmin ) libaer = coevgot / ( 4. / 3. * pi * rhow * aux ** 3. ) else libaer = 0. end if if ( coevcri > 0 ) then libaer = libaer + coevcri / ( pi * rhocri * Rcri ** 3. / 1 0. ) * . 5 end if !********************************************************** !**   Autoconversion !*    gotitas a lluvia if ( qgotaux > 2e-3 ) then liqconv = - 1e-3 * qgotaux else liqconv = 0. end if !*    cristales a nieve if ( T < T0 ) then aux = 2 0. / 3. * Eaucn * 5e-3 * . 25 * 6. hieconv = - aux / Rcri / rhocri * qcriaux ** 2. if ( qcriaux > 5e-4 ) then hieconv = hieconv - 2. * qcriaux ** 2. end if if ( Ncri > 10 0. ) then aux = Acri * exp ( Bcri * ( T0 - T )) if ( aux < 10 0. ) aux = 10 0. hieconv = hieconv - 1e-6 * qcriaux * Ncri / aux end if aux = ( qcriaux - coevcri * dt2 ) * . 9 if ( - hieconv > aux ) hieconv = - aux else hieconv = 0. end if if ( qauxs < 0 . and . T <= T0 . and . qcriaux < 5e-4 ) then hieconv = hieconv + 1e-2 * qnieaux end if aux = exp (. 09 * ( T - T0 )) if ( aux < 0.2 ) aux = . 2 if ( qnieaux > 5e-4 ) then aux = aux * qnieaux / 5e-4 nieconv = - 1e-2 * qnieaux * aux else nieconv = 0. end if !********************************************************** !**   Acrecion !*    gotitas por lluvia if ( Rgot > 0 . and . Rllu > 0 . and . s == 0 ) then acgollu = - gam3p8 * qgotaux * Vtm * pi * Rllu ** 2. * Nllu * Efcol !     para que no de cantidades negativas de gotas siendo colectadas if ( acgollu > qgotaux / dt2 * . 98 ) acgollu = qgotaux / dt2 * . 98 else acgollu = 0. end if !*    gotitas por nieve if ( Rgot > 0 . and . Rnie > 0 . and . s == 0 ) then acgonie = - 2. * qgotaux * Vtnie ( 2 * n ) * pi * Rnie ** 2. * Nnie * Efcolgn !     para que no de cantidades negativas de gotas siendo colectadas if ( acgonie > qgotaux / dt2 * . 98 ) acgonie = qgotaux / dt2 * . 98 else acgonie = 0. end if !*    cristales por nieve if ( Ncri > 0 . and . Rnie > 0 . and . T < T0 ) then accrnie = - 2. * qcriaux * Vtnie ( 2 * n ) * pi * ( Rnie + Rcri ) ** 2. * Nnie * Eaccn !     para que no de cantidades negativas de cristales siendo colectados if ( accrnie > qcriaux / dt2 * . 98 ) accrnie = qcriaux / dt2 * . 98 else accrnie = 0. end if !*    gotitas por granizo if ( Rgot > 0 . and . Rgra > 0 . and . s == 0 ) then acgogra = - gam3p8 * qgotaux * Vtgra * pi * Rgra ** 2. * Ngra * Efcol !     para que no de cantidades negativas de gotas siendo colectadas if ( acgogra > qgotaux / dt2 * . 98 ) acgogra = qgotaux / dt2 * . 98 else acgogra = 0. end if !*    lluvia por granizo if ( Rllu > 0 . and . Rgra > 0 . and . s == 0 . and . Vtgra > Vtm ) then acllgra = - pi * Efcol * Ngra * qlluaux * & ( gam3p8 * ( Vtgra * Rgra ** 2. - Vtm * Rllu ** 2. ) + & 2. * gam2p8 * Rgra * Rllu * ( Vtgra - Vtm ) + & 2. * gam1p8 * ( Vtgra * Rllu ** 2. - Vtm * Rgra ** 2. )) !     para que no de cantidades negativas de lluvia siendo colectada if ( acllgra > qlluaux / dt2 * . 98 ) acllgra = qlluaux / dt2 * . 98 else acllgra = 0. end if !*    cristales por granizo (sup aqui crecimiento humedo, si es seco se corrige en Tgra) if ( Ncri > 0 . and . Rgra > 0 . and . s == 0 . and . T < T0 ) then accrgra = - gam3p8 * qcriaux * Vtgra * pi * Rgra ** 2. * Ngra * Efcol !     para que no de cantidades negativas de critales siendo colectados if ( accrgra > qcriaux / dt2 * . 98 ) accrgra = qcriaux / dt2 * . 98 else accrgra = 0. end if !*    nieve por granizo if ( Rnie > 0 . and . Rgra > 0 . and . s == 0 ) then ccnigra = gam3p8 * Vtgra * pi * Rgra ** 2. * Ngra * Nnie acnigra = - ccnigra * qnieaux / Nnie * Eacng !     para que no de cantidades negativas de nieve siendo colectados if ( acnigra > qnieaux / dt2 * . 98 ) acnigra = qnieaux / dt2 * . 98 else ccnigra = 0. acnigra = 0. end if !********************************************************** !**   Congelacion-Fusion de gotas y cristales !*    congelacion homogenea de gotitas if ( T < 23 8. . and . Rgot > 0 ) then aux = exp (( 23 8. - T ) / 8. ) - 1. if ( T < 233 ) aux = exp ( 5. / 8. ) - 1. cfgotcri = - aux * qgotaux else cfgotcri = 0. end if !*    congelacion homogenea de lluvia if ( T < T0 . and . Rllu > 0 ) then aux = - 6.7e-8 * ( exp (. 66 * ( T0 - T )) - 1. ) if ( aux < - . 9 ) aux = - . 9 cfllugra = aux * qlluaux else cfllugra = 0. end if if ( T >= T0 . and . Rcri > 0 ) then cfgotcri = . 95 * qcriaux else cfgotcri = 0. end if !*    fusion de la nieve if ( Rnie > 0 ) then cfln1 = - acgonie if ( T <= T0 ) then cfln2 = - coevnie * Lvs / Lsl if ( T < T0 - 1 0. ) cfln2 = 0. else cfln2 = - coevnie * Lvl0 / Lsl00 + & ( 8. * Kair * fventl * Rnie * Nnie + Cwl * cfln1 ) * ( T - T0 ) / Lsl00 end if if ( cfln2 < 0 ) cfln2 = 0. cfllunie = cfln1 + cfln2 !     para que no de cantidades negativas nieve fundiendose if ( cfln2 > qnieaux / dt2 - coevnie ) then cfln2 = ( qnieaux / dt2 - coevnie ) * . 9 cfllunie = cfln1 + cfln2 end if else cfllunie = 0. cfln1 = 0. cfln2 = 0. end if !**   colision entre lluvia y nieve o cristales que forman granizos (o nieve) !*    lluvia con cristales if ( T < T0 . and . Rllu > 5e-5 . and . Ncri > 0 ) then colilc = gam3p8 * Vtm * pi * Rllu ** 2. * Nllu * Ncri * Efcol !numero de colisiones colilc = min ( colilc , Nllu * . 3 , Ncri * . 3 ) congagua = colilc * ( qcriaux / Ncri + qlluaux / Nllu ) else colilc = 0. congagua = 0. end if !*    lluvia con nieve if ( T < T0 . and . ( Rllu > 5e-5 . and . Rnie > 0 )) then coliln = pi * Efcol * Nllu * Nnie * ( Vtm * & ( gam3p8 * Rllu ** 2. + gam1p8 * 2. * Rnie ** 2. + 2. * gam2p8 * Rnie * Rllu ) & - Vtnie ( 2 * n ) * 2. * ( Rllu ** 2. + Rnie ** 2. + Rnie * Rllu )) coliln = min ( abs ( coliln ), Nllu * . 3 , Nnie * . 3 ) congagua = congagua + coliln * ( qnieaux / Nnie + qlluaux / Nllu ) else coliln = 0. end if !********************************************************** !**   Coleccion de aerosoles !*    coleccion por lluvia coaerllu = - gam3p8 * Vtm * pi * Rllu ** 2. * Nllu * Naux * Efcaer !numero de colisiones !*    coleccion por nieve coaernie = - 2. * Vtnie ( 2 * n ) * pi * Rnie ** 2. * Nnie * Naux * Efcaer !numero de colisiones !*    coleccion por granizo coaergra = - gam3p8 * Vtgra * pi * Rgra ** 2. * Ngra * Naux * Efcaer !numero de colisiones !*    difusion a gotitas coaergot = - 4. * pi * Dfaer * Naux * Rgot * Ngot !*    difusion a cristales coaercri = - 8. * Dfaer * Naux * Rcri * Ncri !******************************************************************** !     Calculo de la temperatura del granizo y determinacion del tipo !     de crecimiento, se usan los terminos de intercambio anteriores !     Primero suponemos crecimiento humedo y calculamos alfagra. !     Si alfagra>1 el crecimiento es seco. !     Si alfagra<0 o Tg>T0 hay melting if ( Rgra > 0 ) then Qvaux = Qvls0 Tg = T0 alfagra = 1. fugra = 0. agual = - acgogra - acllgra hielo = - accrgra - acnigra A1 = 4. * pi * Rgra * Ngra * Kair * T * fventgl B1 = 4. * pi * Rgra * Ngra * Kair * fventgl A2 = 4. * pi * Rgra * Ngra * Lvl0 * Dv * qvapaux * fventgl B2b = 4. * pi * Rgra * Ngra * Lvl0 * Dv * fventgl A3 = agual * ( Cwl * ( T - T0 ) + alfagra * ( Lsl00 + Cwi * T0 )) A3b = agual * ( Cwl * ( T - T0 )) B3 = agual * alfagra * Cwi A4 = hielo * Cwi * T B4 = hielo * Cwi Aalfa = A1 + A2 + A3b + A4 Balfa = ( B1 + B4 ) * Tg + B2b * Qvls0 if ( agual > 0 ) then alfagra = - ( Aalfa - Balfa ) / agual / ( Lsl00 + Cwi * ( T0 - Tg )) if ( alfagra >= 0 . and . alfagra <= 1 ) then ! crecimiento humedo crecigra = 0 A3 = agual * ( Cwl * ( T - T0 ) + alfagra * ( Lsl00 + Cwi * T0 )) B3 = agual * alfagra * Cwi Q1 = A1 - B1 * Tg Q2 = A2 - B2b * Qvls0 Q3 = A3 - B3 * Tg Q4 = A4 - B4 * Tg Qt = Q1 + Q2 + Q3 + Q4 end if if ( alfagra < 0 ) then !fusion crecigra = 1 alfagra = 0. A3 = agual * ( Cwl * ( T - T0 ) + alfagra * ( Lsl00 + Cwi * T0 )) B3 = agual * alfagra * Cwi Q1 = A1 - B1 * Tg Q2 = A2 - B2b * Qvls0 Q3 = A3 - B3 * Tg Q4 = A4 - B4 * Tg Qt = Q1 + Q2 + Q3 + Q4 fugra = - Qt / Lsl00 !       para que no den cantidades de granizo fundiendo if ( - fugra > qgraaux / dt2 ) fugra = - qgraaux / dt2 * . 9 end if end if if ( alfagra > 1. . or . agual == 0 ) then alfagra = 1. accrgra = accrgra / 8. hielo = - accrgra - acnigra A2 = 4. * pi * Rgra * Ngra * Lvs0 * Dv * qvapaux * fventgs B2b = 4. * pi * Rgra * Ngra * Lvs0 * Dv * fventgs A4 = hielo * Cwi * T B4 = hielo * Cwi Q1 = A1 - B1 * Tg Q2 = A2 - B2b * Qvls0 Q3 = A3 - B3 * Tg Q4 = A4 - B4 * Tg Qt = Q1 + Q2 + Q3 + Q4 BB = B1 + B3 + B4 CC2 = B2b / Rv CC3 = B2b * esvs0 / Rv ** 2. * Lvs0 esaux = esvs0 * exp ( Lvs0 / Rv * ( 1. / T0 - 1. / Tg )) dQt = - BB + CC2 * esaux / Tg ** 2. - CC3 / Tg ** 3. Taux = Tg - Qt / dQt do i = 1 , 10 if ( abs ( Taux - Tg ) > . 05 ) then Taux = Tg Qvaux = esaux / Rv / Taux Q1 = A1 - B1 * Taux Q2 = A2 - B2b * Qvaux Q3 = A3 - B3 * Taux Q4 = A4 - B4 * Taux Qt = Q1 + Q2 + Q3 + Q4 dQt = - BB + CC2 * esaux / Tg ** 2. - CC3 / Tg ** 3. Tg = Taux - Qt / dQt esaux = esvs0 * exp ( Lvs0 / Rv * ( 1. / T0 - 1. / Tg )) end if end do if ( Tg <= T0 ) then crecigra = 2 ! crecimiento seco Qvaux = esvs0 / Rv / Tg * exp ( Lvs0 / Rv * ( 1. / T0 - 1. / Tg )) coevgra = - 4. * pi * Dv * Rgra * Ngra * fventgs * & ( qvapaux - Qvaux ) Q2 = - coevgra * Lvs0 Qt = Q1 + Q2 + Q3 + Q4 else crecigra = 3 ! hay fusion Tg = T0 Q1 = A1 - B1 * Tg Q2 = A2 - B2b * Qvls0 Q3 = A3 - B3 * Tg Q4 = A4 - B4 * Tg Qt = Q1 + Q2 + Q3 + Q4 fugra = - Qt / Lsl00 !       para que no den cantidades de granizo fundiendo if ( - fugra > qgraaux / dt2 * . 8 ) fugra = - qgraaux / dt2 * . 8 end if end if fugrallu = - agual * ( 1. - alfagra ) + fugra Fcalgra = ( fugrallu - congagua ) * Cwl * ( Tg - T ) else fugrallu = 0. Fcalgra = 0. end if !********************************************************** !**   multiplicacion de cristales por colisiones !*     colisiones entre granizo con nieve mucrgrni = ccnigra * Ncrgrni * pi * Rcri ** 3. / 1 0. * rhocri if ( T > T0 ) mucrgrni = 0. !*     colisiones entre granizo con granizos if ( Rgra > 0 . and . T > 0 ) then aux = 4. * pi * Rgra ** 2. * Vtgra * . 25 * Ngra ** 2. mucrgrgr = aux * Ncrgrgr * pi * Rcri ** 3. / 1 0. * rhocri else mucrgrgr = 0. end if !********************************************************** !********************************************************** !**   terminos de intercambio invapgot = coevgot invapllu = coevllu invapcri = coevcri invapnie = coevnie invapgra = coevgra ingotllu = liqconv + acgollu ingotcri = cfgotcri ingotnie = acgonie ingotgra = acgogra incrinie = hieconv + accrnie + mucrgrni * . 8 incrigra = accrgra + mucrgrni * . 2 + mucrgrgr inllunie = cfllunie inllugra = cfllugra - fugrallu inniegra = nieconv if ( Rllu > 1e-4 . and . Ncri > 0 . and . T < T0 ) then incrigra = incrigra - colilc * qcriaux / Ncri inllugra = inllugra - colilc * qlluaux / Nllu Fcal = colilc * qlluaux / Nllu * Lsl * dt2 end if if ( Rllu > 5e-5 . and . Rllu <= 1e-4 . and . Ncri > 0 . and . T < T0 ) then incrinie = incrinie - colilc * qcriaux / Ncri inllunie = inllunie - colilc * qlluaux / Nllu Fcal = colilc * qlluaux / Nllu * Lsl * dt2 end if if ( Rllu > 5e-5 . and . Rnie > 0. ) then inllugra = inllugra - coliln * qlluaux / Nllu inniegra = inniegra - coliln * qnieaux / Nnie Fcal = Fcal + coliln * qlluaux / Nllu * Lsl * dt2 end if !     calculo del numero de particulas Intvap = invapgot + invapllu + invapcri + invapnie + invapgra Intgot = - invapgot + ingotllu + ingotcri + ingotnie + ingotgra Intllu = - invapllu - ingotllu + inllunie + inllugra Intcri = - invapcri - ingotcri + incrinie + incrigra Intnie = - invapnie - ingotnie - inllunie - incrinie + inniegra Intgra = - invapgra - ingotgra - inllugra - incrigra - inniegra Intaer = libaer + coaergot + coaerllu + coaercri + coaernie + coaergra qvapaux1 = qvapaux + Intvap * dt2 qgotaux1 = qgotaux + Intgot * dt2 qlluaux1 = qlluaux + Intllu * dt2 qcriaux1 = qcriaux + Intcri * dt2 qnieaux1 = qnieaux + Intnie * dt2 qgraaux1 = qgraaux + Intgra * dt2 !     Correccion de lluvia negativa if ( qlluaux1 < 0 . and . T < 253 ) then qgraaux1 = qgraaux1 + qlluaux1 qlluaux1 = 0. end if !     Correccion de gotas negativas if ( qgotaux1 < 0 ) then invapgot = invapgot * ( 1. - qgotaux1 / ( Intgot * dt2 )) ingotllu = ingotllu * ( 1. - qgotaux1 / ( Intgot * dt2 )) ingotcri = ingotcri * ( 1. - qgotaux1 / ( Intgot * dt2 )) ingotnie = ingotnie * ( 1. - qgotaux1 / ( Intgot * dt2 )) ingotgra = ingotgra * ( 1. - qgotaux1 / ( Intgot * dt2 )) Intvap = invapgot + invapllu + invapcri + invapnie + invapgra Intgot = - invapgot + ingotllu + ingotcri + ingotnie + ingotgra Intllu = - invapllu - ingotllu + inllunie + inllugra Intcri = - invapcri - ingotcri + incrinie + incrigra Intnie = - invapnie - ingotnie - inllunie - incrinie + inniegra Intgra = - invapgra - ingotgra - inllugra - incrigra - inniegra qvapaux1 = qvapaux + Intvap * dt2 qgotaux1 = qgotaux + Intgot * dt2 qlluaux1 = qlluaux + Intllu * dt2 qcriaux1 = qcriaux + Intcri * dt2 qnieaux1 = qnieaux + Intnie * dt2 qgraaux1 = qgraaux + Intgra * dt2 end if !     prevencion de negativos if ( qgotaux1 < 0 . or . qlluaux1 < 0 . or . qcriaux1 < 0 . or . & qnieaux1 < 0 . or . qgraaux1 < 0 ) then if ( qgotaux1 < 0 ) qgotaux1 = 0. if ( qlluaux1 < 0 ) qlluaux1 = 0. if ( qcriaux1 < 0 ) qcriaux1 = 0. if ( qnieaux1 < 0 ) qnieaux1 = 0. if ( qgraaux1 < 0 ) qgraaux1 = 0. end if qvapaux = qvapaux1 qgotaux = qgotaux1 qlluaux = qlluaux1 qcriaux = qcriaux1 qnieaux = qnieaux1 qgraaux = qgraaux1 daer2 = Intaer * dt2 / 1e6 ! calculo del calor obtenido por cambio de fase (por m&#94;-3) Fcal = Fcal + ( - ( invapgot + invapllu ) * Lvl - & ingotcri * Lsl - invapcri * Lvs + Fcalgra ) * dt2 if ( invapnie > 0 . or . T < T0 - 1 0. ) then Fcal = Fcal - invapnie * Lvs * dt2 end if if ( T < T0 ) Fcal = Fcal - inllunie * Cwl * ( T - T0 ) * dt2 return end subroutine microfis end module microphysics","tags":"","loc":"sourcefile/microf05.f90.html"},{"title":"graba.f90 – cloud_model","text":"Source Code module graba contains subroutine graba120 ( air_density_z_initial , temperature_z_initial , theta_z_initial , & Pres00 , vapor_z_initial , cc2 , aerosol_z_initial , u_z_initial , v_z_initial , & u_perturbed_base , u_perturbed_new , v_perturbed_base , v_perturbed_new , & w_perturbed_base , w_perturbed_new , & theta_base , theta_new , pressure_base , pressure_new , & vapor_base , vapor_new , drop_base , drop_new , rain_base , & rain_new , crystal_base , crystal_new , snow_base , snow_new , & hail_base , hail_new , aerosol_base , aerosol_new , heat_force , Tvis , Tlvl , & Tlsl , Tlvs , Telvs , Tesvs , Av , Vtnie , Vtgra0 , & vapor_z_relative , aerosol_z_relative , Eautcn , Eacrcn ) use dimensions use config implicit none real , dimension ( - 3 : nz1 + 3 ), & intent ( in ) :: air_density_z_initial , & temperature_z_initial , theta_z_initial , Pres00 , vapor_z_initial , & cc2 , aerosol_z_initial , u_z_initial , v_z_initial real , dimension ( - 3 : nx1 + 3 , - 3 : nx1 + 3 , - 2 : nz1 + 2 ), & intent ( in ) :: u_perturbed_base , & u_perturbed_new , v_perturbed_base , v_perturbed_new , w_perturbed_base , & w_perturbed_new , theta_base , theta_new , pressure_base , & pressure_new , heat_force , vapor_base , vapor_new , drop_base , & drop_new , aerosol_base , aerosol_new , rain_base , & rain_new , crystal_base , crystal_new , snow_base , & snow_new , hail_base , hail_new real , dimension ( 210 : 320 ), intent ( in ) :: Tvis , Tlvl , Tlsl , Tlvs , Telvs , Tesvs , & Eautcn , Eacrcn real , dimension ( - 3 : 2 * nz1 + 5 ), intent ( in ) :: Av , Vtnie , Vtgra0 real , dimension ( nz1 ), intent ( in ) :: vapor_z_relative , aerosol_z_relative integer :: unit_number open ( newunit = unit_number , file = output_directory // \"inis.da\" , status = & 'unknown' , form = 'unformatted' ) write ( unit_number ) air_density_z_initial , temperature_z_initial , theta_z_initial , & Pres00 , vapor_z_initial , cc2 , aerosol_z_initial , u_z_initial , v_z_initial close ( unit_number ) open ( newunit = unit_number , file = output_directory // \"velos.da\" , status = & 'unknown' , form = 'unformatted' ) rewind unit_number write ( unit_number ) u_perturbed_base , u_perturbed_new , v_perturbed_base , v_perturbed_new , & w_perturbed_base , w_perturbed_new , theta_base , theta_new , & pressure_base , pressure_new , vapor_base , vapor_new , & drop_base , drop_new , rain_base , rain_new , crystal_base , & crystal_new , snow_base , snow_new , hail_base , & hail_new , aerosol_base , aerosol_new , heat_force close ( unit_number ) open ( newunit = unit_number , file = output_directory // \"varconz.da\" , status = & 'unknown' , form = 'unformatted' ) rewind unit_number write ( unit_number ) Tvis , Tlvl , Tlsl , Tlvs , Telvs , Tesvs , Av , Vtnie , Vtgra0 , & vapor_z_relative , aerosol_z_relative , Eautcn , Eacrcn close ( unit_number ) end subroutine graba120 subroutine graba231 ( k , w_perturbed_new , theta_base , vapor_base , rain_base , & hail_base , aerosol_base , vapor_z_initial , aerosol_z_initial , file_number ) !! Grabacion 2D use dimensions use config implicit none real , dimension ( - 3 : nx1 + 3 , - 3 : nx1 + 3 , - 2 : nz1 + 2 ), intent ( in ) :: w_perturbed_new , & theta_base , vapor_base , rain_base , hail_base , aerosol_base real , dimension ( - 3 : nz1 + 3 ), intent ( in ) :: vapor_z_initial , aerosol_z_initial integer , intent ( in ) :: k character ( len = 3 ), intent ( in ) :: file_number character ( len = 100 ) :: nombre integer :: i , j integer :: unit_number nombre = output_directory // 'w_perturbed_new' // file_number // '.m' open ( newunit = unit_number , file = nombre ) do i = 1 , nx1 write ( unit_number , 2000 ) ( w_perturbed_new ( i , j , 1 ), j = 1 , nx1 ) end do close ( unit_number ) nombre = output_directory // 'Tita' // file_number // '.m' open ( newunit = unit_number , file = nombre ) do i = 1 , nx1 write ( unit_number , 2000 ) ( theta_base ( i , j , 0 ), j = 1 , nx1 ) end do close ( unit_number ) nombre = output_directory // 'Qvap' // file_number // '.m' open ( newunit = unit_number , file = nombre ) do i = 1 , nx1 write ( unit_number , 2000 ) (( vapor_base ( i , j , k ) + vapor_z_initial ( k )), j = 1 , nx1 ) end do close ( unit_number ) nombre = output_directory // 'Qllu' // file_number // '.m' open ( newunit = unit_number , file = nombre ) do i = 1 , nx1 write ( unit_number , 2000 ) ( rain_base ( i , j , 1 ), j = 1 , nx1 ) end do close ( unit_number ) nombre = output_directory // 'Aero' // file_number // '.m' open ( newunit = unit_number , file = nombre ) do i = 1 , nx1 write ( unit_number , 2000 ) ( aerosol_base ( i , j , 0 ) + aerosol_z_initial ( 0 ), j = 1 , nx1 ) end do close ( unit_number ) nombre = output_directory // 'Qgra' // file_number // '.m' open ( newunit = unit_number , file = nombre ) do i = 1 , nx1 write ( unit_number , 2000 ) ( hail_base ( i , j , 1 ), j = 1 , nx1 ) end do close ( unit_number ) 2000 format ( 5 0E11 . 3 ) end subroutine graba231 subroutine graba320 ( u_perturbed_base , v_perturbed_base , w_perturbed_base , theta_base , & pressure_base , vapor_base , drop_base , rain_base , crystal_base , snow_base , & hail_base , aerosol_base , file_number ) !! Grabacion 3D use dimensions use config implicit none real , dimension ( - 3 : nx1 + 3 , - 3 : nx1 + 3 , - 2 : nz1 + 2 ), & intent ( in ) :: u_perturbed_base , & v_perturbed_base , w_perturbed_base , theta_base , pressure_base , vapor_base , & drop_base , rain_base , crystal_base , snow_base , hail_base , aerosol_base character ( len = 3 ), intent ( in ) :: file_number character ( len = 30 ) :: file_name integer :: unit_number file_name = output_directory // \"nube\" // trim ( file_number ) // '.sal' open ( newunit = unit_number , file = file_name , status = 'unknown' , form = & 'unformatted' ) write ( unit_number ) u_perturbed_base , v_perturbed_base , w_perturbed_base , theta_base , & pressure_base , vapor_base , drop_base , rain_base , crystal_base , snow_base , & hail_base , aerosol_base close ( unit_number ) end subroutine graba320 end module graba","tags":"","loc":"sourcefile/graba.f90.html"},{"title":"aux_subrut.f90 – cloud_model","text":"Source Code module extra_subrut contains subroutine turbu1 ( kk ) !! Esta subrutina calcula los Dnm para cada plano Z use cant01 use dimensions use dinamic_var_perturbation use constants use turbvar1 use turbu1_vars implicit none integer , intent ( in ) :: kk k = kk + 1 do concurrent ( i = 0 : nx1 + 1 , j = 0 : nx1 + 1 ) if ( kk == 1 ) then do concurrent ( n = 1 : 2 ) do concurrent ( m = 1 : n ) D ( n , m , i , j , 1 ) = 0. end do end do D ( 3 , 1 , i , j , 1 ) = u_perturbed_new ( i , j , 1 ) D ( 3 , 2 , i , j , 1 ) = v_perturbed_new ( i , j , 1 ) D ( 3 , 3 , i , j , 1 ) = w_perturbed_new ( i , j , 1 ) * 2. / 3. do concurrent ( n = 1 : 3 ) do concurrent ( m = 1 : n ) D ( m , n , i , j , 1 ) = D ( n , m , i , j , 1 ) end do end do do concurrent ( lx =- 1 : 1 , ly =- 1 : 1 , lz =- 1 : 1 ) ldis = abs ( lx ) + abs ( ly ) + abs ( lz ) if ( ldis <= 1 ) then vel ( 1 , lx , ly , lz ) = u_perturbed_new ( lx + i , ly + j , lz + 1 ) vel ( 2 , lx , ly , lz ) = v_perturbed_new ( lx + i , ly + j , lz + 1 ) vel ( 3 , lx , ly , lz ) = w_perturbed_new ( lx + i , ly + j , lz + 1 ) end if end do !     calculo de Dij do concurrent ( n = 1 : 3 ) dv ( n , 1 ) = vel ( n , 1 , 0 , 0 ) - vel ( n , - 1 , 0 , 0 ) dv ( n , 2 ) = vel ( n , 0 , 1 , 0 ) - vel ( n , 0 , - 1 , 0 ) dv ( n , 3 ) = vel ( n , 0 , 0 , 1 ) - vel ( n , 0 , 0 , - 1 ) end do do concurrent ( n = 1 : 3 ) do concurrent ( m = 1 : n ) D ( n , m , i , j , 2 ) = ( dv ( n , m ) + dv ( m , n )) D ( m , n , i , j , 2 ) = D ( n , m , i , j , 2 ) if ( n == m ) D ( n , n , i , j , 2 ) = 2. / 3. * D ( n , n , i , j , 2 ) end do end do else do concurrent ( n = 1 : 3 , m = 1 : 3 , lz = 1 : 2 ) D ( n , m , i , j , lz ) = D ( n , m , i , j , lz + 1 ) end do end if !********************************************************* !     Lectura de las velocidades necesarias do concurrent ( lx =- 1 : 1 , ly =- 1 : 1 , lz =- 1 : 1 ) ldis = abs ( lx ) + abs ( ly ) + abs ( lz ) if ( ldis <= 1 ) then vel ( 1 , lx , ly , lz ) = u_perturbed_new ( lx + i , ly + j , lz + k ) vel ( 2 , lx , ly , lz ) = v_perturbed_new ( lx + i , ly + j , lz + k ) vel ( 3 , lx , ly , lz ) = w_perturbed_new ( lx + i , ly + j , lz + k ) end if end do !     calculo de Dij do concurrent ( n = 1 : 3 ) dv ( n , 1 ) = vel ( n , 1 , 0 , 0 ) - vel ( n , - 1 , 0 , 0 ) dv ( n , 2 ) = vel ( n , 0 , 1 , 0 ) - vel ( n , 0 , - 1 , 0 ) dv ( n , 3 ) = vel ( n , 0 , 0 , 1 ) - vel ( n , 0 , 0 , - 1 ) end do do concurrent ( n = 1 : 3 ) do concurrent ( m = 1 : n ) D ( n , m , i , j , 3 ) = ( dv ( n , m ) + dv ( m , n )) D ( m , n , i , j , 3 ) = D ( n , m , i , j , 3 ) if ( n == m ) D ( n , n , i , j , 3 ) = 2. / 3. * D ( n , n , i , j , 3 ) end do end do end do return end subroutine turbu1 subroutine turbu2 ( i , j ) !!      Esta subrutina calcula las cantidades referida a los terminos de !!      turbulencia: K, DK, DDij !!      Dij viene de turbu1 !!     En realidad para tener los valores de las 4 cantidades falta !!     multiplicarlas por: !!                      KMM : cteturb*dx1/2 !!                      DK  : cteturb/4 !!                      Dij : 1/dx2 (simetrico) !!                      DDij: 1/dx2**2 use dimensions use turbvar use turbvar1 use turbu2_vars implicit none integer , intent ( in ) :: i , j real aux !     calculo de KM do lx = - 1 , 1 do ly = - 1 , 1 do lz = - 1 , 1 ldis = abs ( lx ) + abs ( ly ) + abs ( lz ) if ( ldis <= 2 ) then call suma ( aux , & D ( 1 , 1 , i + lx , j + ly , 2 + lz ) ** 2. , & D ( 2 , 2 , i + lx , j + ly , 2 + lz ) ** 2. , & D ( 3 , 3 , i + lx , j + ly , 2 + lz ) ** 2. ) sum = aux / 2. call suma ( aux , & D ( 1 , 2 , i + lx , j + ly , 2 + lz ) ** 2. , & D ( 1 , 3 , i + lx , j + ly , 2 + lz ) ** 2. , & D ( 2 , 3 , i + lx , j + ly , 2 + lz ) ** 2. ) sum = sum + aux KM ( lx , ly , lz ) = sum ** . 5 end if end do end do end do !     calculo de las derivadas (sin la distancia abajo) KM1 = KM ( 1 , 0 , 0 ) - KM ( - 1 , 0 , 0 ) KM2 = KM ( 0 , 1 , 0 ) - KM ( 0 , - 1 , 0 ) KM3 = KM ( 0 , 0 , 1 ) - KM ( 0 , 0 , - 1 ) do concurrent ( n = 1 : 3 ) D1 ( n ) = D ( n , 1 , i + 1 , j , 2 ) - D ( n , 1 , i - 1 , j , 2 ) D2 ( n ) = D ( n , 2 , i , j + 1 , 2 ) - D ( n , 2 , i , j - 1 , 2 ) D3 ( n ) = D ( n , 3 , i , j , 3 ) - D ( n , 3 , i , j , 1 ) end do KMM = KM ( 0 , 0 , 0 ) do concurrent ( n = 1 : 3 , m = 1 : 3 ) DD ( n , m ) = D ( n , m , i , j , 2 ) end do return end subroutine turbu2 subroutine inhomogeneous_velocities ( i , j , k , dden0z ) !! Esta subrutina calcula los terminos inomogeneos para las velocidades use cant01 use dimensions use dinamic_var_perturbation use microphysics_perturbation use constants use initial_z_state use turbvar use sv_inhomogeneous_velocities_and_speed_pressure , only : fu , fv , fw , fp implicit none integer , intent ( in ) :: i , j , k real , intent ( in ) :: dden0z real ( 8 ) :: velocity_xx !! Velocity component xx real ( 8 ) :: velocity_xy !! Velocity component xy real ( 8 ) :: velocity_xz !! Velocity component xz real ( 8 ) :: velocity_yx !! Velocity component yx real ( 8 ) :: velocity_yy !! Velocity component yy real ( 8 ) :: velocity_yz !! Velocity component yz real ( 8 ) :: velocity_zx !! Velocity component zx real ( 8 ) :: velocity_zy !! Velocity component zy real ( 8 ) :: velocity_zz !! Velocity component zz real ( 8 ) :: coefficient_a1 !! Coefficient a1 real ( 8 ) :: coefficient_a2 !! Coefficient a2 real ( 8 ) :: coefficient_a3 !! Coefficient a3 real ( 8 ) :: turbulence_x !! Turbulence x real ( 8 ) :: turbulence_y !! Turbulence y real ( 8 ) :: turbulence_z !! Turbulence z real ( 8 ) :: divergence_x !! Divergence x real ( 8 ) :: divergence_y !! Divergence y real ( 8 ) :: divergence_z !! Divergence z real ( 8 ) :: gravitational_acceleration !! Gravitational acceleration real ( 8 ) :: laplacian_of_laplacian !! Laplacian of laplacian velocity_xx = ( u_perturbed_new ( i - 2 , j , k ) - u_perturbed_new ( i + 2 , j , k )) & + 8. * ( u_perturbed_new ( i + 1 , j , k ) - u_perturbed_new ( i - 1 , j , k )) velocity_xy = ( u_perturbed_new ( i , j - 2 , k ) - u_perturbed_new ( i , j + 2 , k )) & + 8. * ( u_perturbed_new ( i , j + 1 , k ) - u_perturbed_new ( i , j - 1 , k )) velocity_xz = ( u_perturbed_new ( i , j , k - 2 ) - u_perturbed_new ( i , j , k + 2 )) & + 8. * ( u_perturbed_new ( i , j , k + 1 ) - u_perturbed_new ( i , j , k - 1 )) velocity_yx = ( v_perturbed_new ( i - 2 , j , k ) - v_perturbed_new ( i + 2 , j , k )) & + 8. * ( v_perturbed_new ( i + 1 , j , k ) - v_perturbed_new ( i - 1 , j , k )) velocity_yy = ( v_perturbed_new ( i , j - 2 , k ) - v_perturbed_new ( i , j + 2 , k )) & + 8. * ( v_perturbed_new ( i , j + 1 , k ) - v_perturbed_new ( i , j - 1 , k )) velocity_yz = ( v_perturbed_new ( i , j , k - 2 ) - v_perturbed_new ( i , j , k + 2 )) & + 8. * ( v_perturbed_new ( i , j , k + 1 ) - v_perturbed_new ( i , j , k - 1 )) velocity_zx = ( w_perturbed_new ( i - 2 , j , k ) - w_perturbed_new ( i + 2 , j , k )) & + 8. * ( w_perturbed_new ( i + 1 , j , k ) - w_perturbed_new ( i - 1 , j , k )) velocity_zy = ( w_perturbed_new ( i , j - 2 , k ) - w_perturbed_new ( i , j + 2 , k )) & + 8. * ( w_perturbed_new ( i , j + 1 , k ) - w_perturbed_new ( i , j - 1 , k )) velocity_zz = ( w_perturbed_new ( i , j , k - 2 ) - w_perturbed_new ( i , j , k + 2 )) & + 8. * ( w_perturbed_new ( i , j , k + 1 ) - w_perturbed_new ( i , j , k - 1 )) divergence_x = ( u_perturbed_new ( i , j , k ) * velocity_xx + v_perturbed_new ( i , j , k ) * velocity_xy ) & + w_perturbed_new ( i , j , k ) * velocity_xz divergence_y = ( u_perturbed_new ( i , j , k ) * velocity_yx + v_perturbed_new ( i , j , k ) * velocity_yy ) & + w_perturbed_new ( i , j , k ) * velocity_yz divergence_z = ( u_perturbed_new ( i , j , k ) * velocity_zx + v_perturbed_new ( i , j , k ) * velocity_zy ) & + w_perturbed_new ( i , j , k ) * velocity_zz coefficient_a1 = ( KM1 * DD ( 1 , 1 ) + KM2 * DD ( 1 , 2 )) + KM3 * DD ( 1 , 3 ) coefficient_a2 = KMM * (( D1 ( 1 ) + D2 ( 1 )) + D3 ( 1 )) coefficient_a3 = KMM * DD ( 1 , 3 ) * dden0z turbulence_x = cteturb * (( coefficient_a1 + coefficient_a2 ) + coefficient_a3 ) coefficient_a1 = ( KM1 * DD ( 2 , 1 ) + KM2 * DD ( 2 , 2 )) + KM3 * DD ( 2 , 3 ) coefficient_a2 = KMM * (( D1 ( 2 ) + D2 ( 2 )) + D3 ( 2 )) coefficient_a3 = KMM * DD ( 2 , 3 ) * dden0z turbulence_y = cteturb * (( coefficient_a1 + coefficient_a2 ) + coefficient_a3 ) coefficient_a1 = ( KM1 * DD ( 3 , 1 ) + KM2 * DD ( 3 , 2 )) + KM3 * DD ( 3 , 3 ) coefficient_a2 = KMM * (( D1 ( 3 ) + D2 ( 3 )) + D3 ( 3 )) coefficient_a3 = KMM * DD ( 3 , 3 ) * dden0z turbulence_z = cteturb * (( coefficient_a1 + coefficient_a2 ) + coefficient_a3 ) ! gravitational_acceleration = G * ( theta_base ( i , j , k ) / theta_z_initial ( k ) & + ( AA * vapor_base ( i , j , k ) - drop_base ( i , j , k ) - rain_base ( i , j , k ) & - crystal_base ( i , j , k ) - snow_base ( i , j , k ) - hail_base ( i , j , k ) & ) / air_density_z_initial ( k )) fu ( i , j , k ) = turbulence_x / dx8 - divergence_x / dx12 fv ( i , j , k ) = turbulence_y / dx8 - divergence_y / dx12 fw ( i , j , k ) = turbulence_z / dx8 - divergence_z / dx12 + gravitational_acceleration !     agregado para la P (23/8/97) laplacian_of_laplacian = ( pressure_new ( i + 1 , j , k ) + pressure_new ( i - 1 , j , k )) & + ( pressure_new ( i , j + 1 , k ) + pressure_new ( i , j - 1 , k )) & + pressure_new ( i , j , k + 1 ) + pressure_new ( i , j , k - 1 ) & - 6. * pressure_new ( i , j , k ) fp ( i , j , k ) = cteturb * KMM / dx2 * laplacian_of_laplacian return end subroutine inhomogeneous_velocities subroutine tempot ( i , j , k , dden0z , Fcal ) !! heat_force es el calor liberado por cambio de fase, por unidad de masa de aire use cant01 use dimensions use dinamic_var_perturbation use constants use initial_z_state use turbvar use tempe01 implicit none real , intent ( in ) :: dden0z , Fcal integer , intent ( in ) :: i , j , k adv ( 1 ) = ( u_perturbed_new ( i , j , k ) + u_z_initial ( k )) * ( theta_base ( i + 1 , j , k ) - theta_base ( i - 1 , j , k )) adv ( 2 ) = ( v_perturbed_new ( i , j , k ) + v_z_initial ( k )) * ( theta_base ( i , j + 1 , k ) - theta_base ( i , j - 1 , k )) adv ( 3 ) = w_perturbed_new ( i , j , k ) * ( theta_base ( i , j , k + 1 ) - theta_base ( i , j , k - 1 )) advec = - (( adv ( 1 ) + adv ( 2 )) + adv ( 3 )) verti = - w_perturbed_new ( i , j , k ) * ( theta_z_initial ( k + 1 ) - theta_z_initial ( k - 1 )) calor = Fcal * theta_z_initial ( k ) / ( temperature_z_initial ( k ) * Cp ) dtita ( 1 ) = theta_base ( i + 1 , j , k ) - theta_base ( i - 1 , j , k ) dtita ( 2 ) = theta_base ( i , j + 1 , k ) - theta_base ( i , j - 1 , k ) dtita ( 3 ) = theta_base ( i , j , k + 1 ) - theta_base ( i , j , k - 1 ) escal = ( dtita ( 1 ) * KM1 + dtita ( 2 ) * KM2 ) + dtita ( 3 ) * KM3 lapla = ( theta_base ( i + 1 , j , k ) + theta_base ( i - 1 , j , k )) & + ( theta_base ( i , j + 1 , k ) + theta_base ( i , j - 1 , k )) & + theta_base ( i , j , k + 1 ) + theta_base ( i , j , k - 1 ) & - 6 * theta_base ( i , j , k ) lapla = lapla + ( theta_z_initial ( k + 1 ) + theta_z_initial ( k - 1 ) - 2. * theta_z_initial ( k )) turden = dden0z * ( theta_z_initial ( k + 1 ) - theta_z_initial ( k - 1 )) turbul = 3. * cteturb / dx8 * ( escal + KMM * ( 4. * lapla + turden )) theta_new ( i , j , k ) = dt1 * (( advec + verti ) / dx2 + turbul + calor ) + & theta_base ( i , j , k ) return end subroutine tempot subroutine dvapor ( l , m , n ) use cant01 use dimensions use dinamic_var_perturbation use microphysics_perturbation use constants use initial_z_state use advecs use turbvar use dvapor_vars implicit none integer , intent ( in ) :: l , m , n dqvap ( 1 ) = vapor_base ( l + 1 , m , n ) - vapor_base ( l - 1 , m , n ) dqvap ( 2 ) = vapor_base ( l , m + 1 , n ) - vapor_base ( l , m - 1 , n ) dqvap ( 3 ) = vapor_base ( l , m , n + 1 ) - vapor_base ( l , m , n - 1 ) adv ( 1 ) = ((( u_perturbed_new ( l + 1 , m , n ) + u_perturbed_new ( l , m , n )) * & ( vapor_base ( l + 1 , m , n ) + vapor_base ( l , m , n ))) - & (( u_perturbed_new ( l - 1 , m , n ) + u_perturbed_new ( l , m , n )) * & ( vapor_base ( l - 1 , m , n ) + vapor_base ( l , m , n )))) / 4. adv ( 1 ) = adv ( 1 ) + dqvap ( 1 ) / 2. * u_z_initial ( n ) adv ( 2 ) = ((( v_perturbed_new ( l , m + 1 , n ) + v_perturbed_new ( l , m , n )) * & ( vapor_base ( l , m + 1 , n ) + vapor_base ( l , m , n ))) - & (( v_perturbed_new ( l , m - 1 , n ) + v_perturbed_new ( l , m , n )) * & ( vapor_base ( l , m - 1 , n ) + vapor_base ( l , m , n )))) / 4. adv ( 2 ) = adv ( 2 ) + dqvap ( 2 ) / 2. * v_z_initial ( n ) advvap2 ( l , m ) = ( w_perturbed_new ( l , m , n ) + w_perturbed_new ( l , m , n + 1 )) * & ( vapor_base ( l , m , n ) + vapor_base ( l , m , n + 1 )) / 4. adv ( 3 ) = advvap2 ( l , m ) - advvap1 ( l , m ) advec = - (( adv ( 1 ) + adv ( 2 )) + adv ( 3 )) verti = - (( w_perturbed_new ( l , m , n + 1 ) + w_perturbed_new ( l , m , n )) * ( vapor_z_initial ( n + 1 ) + vapor_z_initial ( n )) - & ( w_perturbed_new ( l , m , n - 1 ) + w_perturbed_new ( l , m , n )) * ( vapor_z_initial ( n - 1 ) + vapor_z_initial ( n ))) / 4. aux = - ( u_perturbed_new ( l + 1 , m , n ) - u_perturbed_new ( l - 1 , m , n ) & + v_perturbed_new ( l , m + 1 , n ) - v_perturbed_new ( l , m - 1 , n )) * & vapor_z_initial ( n ) / 2. escal = dqvap ( 1 ) * KM1 + dqvap ( 2 ) * KM2 + dqvap ( 3 ) * KM3 lapla = (( vapor_base ( l + 1 , m , n ) + vapor_base ( l - 1 , m , n )) + & ( vapor_base ( l , m + 1 , n ) + vapor_base ( l , m - 1 , n ))) + & vapor_base ( l , m , n + 1 ) + vapor_base ( l , m , n - 1 ) - & 6. * vapor_base ( l , m , n ) lapla = lapla + ( vapor_z_initial ( n + 1 ) + vapor_z_initial ( n - 1 ) - 2. * vapor_z_initial ( n )) turbul = cteturb * ( escal / dx8 + KMM / dx2 * lapla ) vapor_new ( l , m , n ) = dt1 * (( advec + verti + aux ) / dx1 + turbul ) + vapor_base ( l , m , n ) aux = dt1 / dx1 aux = aux * ( verti + advec ) + dt1 * turbul + vapor_base ( l , m , n ) return end subroutine dvapor subroutine dgotit ( l , m , n ) use cant01 use dimensions use dinamic_var_perturbation use microphysics_perturbation use constants use initial_z_state use advecs use turbvar use dgotit_vars implicit none integer , intent ( in ) :: l , m , n dqgot ( 1 ) = drop_base ( l + 1 , m , n ) - drop_base ( l - 1 , m , n ) dqgot ( 2 ) = drop_base ( l , m + 1 , n ) - drop_base ( l , m - 1 , n ) dqgot ( 3 ) = drop_base ( l , m , n + 1 ) - drop_base ( l , m , n - 1 ) adv ( 1 ) = (( u_perturbed_new ( l + 1 , m , n ) + u_perturbed_new ( l , m , n )) * ( drop_base ( l + 1 , m , n ) + drop_base ( l , m , n )) & - ( u_perturbed_new ( l - 1 , m , n ) + u_perturbed_new ( l , m , n )) * ( drop_base ( l - 1 , m , n ) + drop_base ( l , m , n ))) / 4. adv ( 1 ) = adv ( 1 ) + dqgot ( 1 ) / 2. * u_z_initial ( n ) adv ( 2 ) = (( v_perturbed_new ( l , m + 1 , n ) + v_perturbed_new ( l , m , n )) * ( drop_base ( l , m + 1 , n ) + drop_base ( l , m , n )) & - ( v_perturbed_new ( l , m - 1 , n ) + v_perturbed_new ( l , m , n )) * ( drop_base ( l , m - 1 , n ) + drop_base ( l , m , n ))) / 4. adv ( 2 ) = adv ( 2 ) + dqgot ( 2 ) / 2. * v_z_initial ( n ) advgot2 ( l , m ) = ( w_perturbed_new ( l , m , n ) + w_perturbed_new ( l , m , n + 1 )) * & ( drop_base ( l , m , n ) + drop_base ( l , m , n + 1 )) / 4. if (( advgot2 ( l , m ) - advgot1 ( l , m )) * dt1 / dx1 > drop_base ( l , m , n ) . and . & w_perturbed_new ( l , m , n ) > 0 ) then advgot2 ( l , m ) = advgot1 ( l , m ) + drop_base ( l , m , n ) * dx1 / dt1 end if adv ( 3 ) = advgot2 ( l , m ) - advgot1 ( l , m ) advec = - ( adv ( 1 ) + adv ( 2 ) + adv ( 3 )) / dx1 escal = dqgot ( 1 ) * KM1 + dqgot ( 2 ) * KM2 + dqgot ( 3 ) * KM3 lapla = drop_base ( l + 1 , m , n ) + drop_base ( l , m + 1 , n ) + drop_base ( l , m , n + 1 ) + & drop_base ( l - 1 , m , n ) + drop_base ( l , m - 1 , n ) + drop_base ( l , m , n - 1 ) - & 6. * drop_base ( l , m , n ) turbul = cteturb * ( escal / dx8 + KMM / dx2 * lapla ) drop_new ( l , m , n ) = dt1 * ( advec + turbul ) + drop_base ( l , m , n ) return end subroutine dgotit subroutine dlluvi ( l , m , n ) use cant01 use dimensions use dinamic_var_perturbation use microphysics_perturbation use constants use initial_z_state use advecs use turbvar use dlluvi_vars implicit none integer , intent ( in ) :: l , m , n dqllu ( 1 ) = rain_base ( l + 1 , m , n ) - rain_base ( l - 1 , m , n ) dqllu ( 2 ) = rain_base ( l , m + 1 , n ) - rain_base ( l , m - 1 , n ) dqllu ( 3 ) = rain_base ( l , m , n + 1 ) - rain_base ( l , m , n - 1 ) adv ( 1 ) = (( u_perturbed_new ( l + 1 , m , n ) + u_perturbed_new ( l , m , n )) * ( rain_base ( l + 1 , m , n ) + rain_base ( l , m , n )) & - ( u_perturbed_new ( l - 1 , m , n ) + u_perturbed_new ( l , m , n )) * ( rain_base ( l - 1 , m , n ) + rain_base ( l , m , n ))) / 4. adv ( 1 ) = adv ( 1 ) + dqllu ( 1 ) / 2. * u_z_initial ( n ) adv ( 2 ) = (( v_perturbed_new ( l , m + 1 , n ) + v_perturbed_new ( l , m , n )) * ( rain_base ( l , m + 1 , n ) + rain_base ( l , m , n )) - & ( v_perturbed_new ( l , m - 1 , n ) + v_perturbed_new ( l , m , n )) * ( rain_base ( l , m - 1 , n ) + rain_base ( l , m , n ))) / 4. adv ( 2 ) = adv ( 2 ) + dqllu ( 2 ) / 2. * v_z_initial ( n ) advllu2 ( l , m ) = ( w_perturbed_new ( l , m , n ) + w_perturbed_new ( l , m , n + 1 )) * & ( rain_base ( l , m , n ) + rain_base ( l , m , n + 1 )) / 4. adv ( 3 ) = advllu2 ( l , m ) - advllu1 ( l , m ) advec = - ( adv ( 1 ) + adv ( 2 ) + adv ( 3 )) escal = dqllu ( 1 ) * KM1 + dqllu ( 2 ) * KM2 + dqllu ( 3 ) * KM3 lapla = rain_base ( l + 1 , m , n ) + rain_base ( l , m + 1 , n ) + rain_base ( l , m , n + 1 ) + & rain_base ( l - 1 , m , n ) + rain_base ( l , m - 1 , n ) + rain_base ( l , m , n - 1 ) - & 6. * rain_base ( l , m , n ) turbul = cteturb * ( escal / dx8 + KMM / dx2 * lapla ) !***  termino de sedimentacion Qllus = ( rain_base ( l , m , n + 1 ) + rain_base ( l , m , n )) / 2. Qllui = ( rain_base ( l , m , n - 1 ) + rain_base ( l , m , n )) / 2. Rms = ( Qllus / cteqllu ) ** . 25 Rmm = ( rain_base ( l , m , n ) / cteqllu ) ** . 25 Rmi = ( Qllui / cteqllu ) ** . 25 Vtllus = ( Av ( 2 * n + 1 ) * Rms ** . 8 + Av ( 2 * n ) * Rmm ** . 8 ) / 2. Vtllui = ( Av ( 2 * n - 1 ) * Rmi ** . 8 + Av ( 2 * n ) * Rmm ** . 8 ) / 2. if ( n == 1 ) then Vtllui = Av ( 2 * n ) * Rmm ** . 8 Qllui = rain_base ( l , m , n ) end if sedim = gam4p8 / 6. * ( Qllus * Vtllus - Qllui * Vtllui ) rain_new ( l , m , n ) = dt1 * (( advec + sedim ) / dx1 + turbul ) + rain_base ( l , m , n ) return end subroutine dlluvi subroutine dcrist ( l , m , n ) use cant01 use dimensions use dinamic_var_perturbation use microphysics_perturbation use constants use initial_z_state use advecs use turbvar use dcrist_vars implicit none integer , intent ( in ) :: l , m , n dqcri ( 1 ) = crystal_base ( l + 1 , m , n ) - crystal_base ( l - 1 , m , n ) dqcri ( 2 ) = crystal_base ( l , m + 1 , n ) - crystal_base ( l , m - 1 , n ) dqcri ( 3 ) = crystal_base ( l , m , n + 1 ) - crystal_base ( l , m , n - 1 ) adv ( 1 ) = (( u_perturbed_new ( l + 1 , m , n ) + u_perturbed_new ( l , m , n )) * ( crystal_base ( l + 1 , m , n ) + crystal_base ( l , m , n )) & - ( u_perturbed_new ( l - 1 , m , n ) + u_perturbed_new ( l , m , n )) * ( crystal_base ( l - 1 , m , n ) + crystal_base ( l , m , n ))) / 4. adv ( 1 ) = adv ( 1 ) + dqcri ( 1 ) / 2. * u_z_initial ( n ) adv ( 2 ) = (( v_perturbed_new ( l , m + 1 , n ) + v_perturbed_new ( l , m , n )) * ( crystal_base ( l , m + 1 , n ) + crystal_base ( l , m , n )) - & ( v_perturbed_new ( l , m - 1 , n ) + v_perturbed_new ( l , m , n )) * ( crystal_base ( l , m - 1 , n ) + crystal_base ( l , m , n ))) / 4. adv ( 2 ) = adv ( 2 ) + dqcri ( 2 ) / 2. * v_z_initial ( n ) advcri2 ( l , m ) = ( w_perturbed_new ( l , m , n ) + w_perturbed_new ( l , m , n + 1 )) * & ( crystal_base ( l , m , n ) + crystal_base ( l , m , n + 1 )) / 4. adv ( 3 ) = advcri2 ( l , m ) - advcri1 ( l , m ) advec = - ( adv ( 1 ) + adv ( 2 ) + adv ( 3 )) / dx1 escal = dqcri ( 1 ) * KM1 + dqcri ( 2 ) * KM2 + dqcri ( 3 ) * KM3 lapla = crystal_base ( l + 1 , m , n ) + crystal_base ( l , m + 1 , n ) + crystal_base ( l , m , n + 1 ) + & crystal_base ( l - 1 , m , n ) + crystal_base ( l , m - 1 , n ) + crystal_base ( l , m , n - 1 ) - & 6. * crystal_base ( l , m , n ) turbul = cteturb * ( escal / dx8 + KMM / dx2 * lapla ) crystal_new ( l , m , n ) = dt1 * ( advec + turbul ) + crystal_base ( l , m , n ) return end subroutine dcrist subroutine dnieve ( l , m , n ) use cant01 use dimensions use dinamic_var_perturbation use microphysics_perturbation use constants use initial_z_state use advecs use turbvar use dnieve_vars implicit none integer , intent ( in ) :: l , m , n dqnie ( 1 ) = snow_base ( l + 1 , m , n ) - snow_base ( l - 1 , m , n ) dqnie ( 2 ) = snow_base ( l , m + 1 , n ) - snow_base ( l , m - 1 , n ) dqnie ( 3 ) = snow_base ( l , m , n + 1 ) - snow_base ( l , m , n - 1 ) adv ( 1 ) = (( u_perturbed_new ( l + 1 , m , n ) + u_perturbed_new ( l , m , n )) * ( snow_base ( l + 1 , m , n ) + snow_base ( l , m , n )) & - ( u_perturbed_new ( l - 1 , m , n ) + u_perturbed_new ( l , m , n )) * ( snow_base ( l - 1 , m , n ) + snow_base ( l , m , n ))) / 4. adv ( 1 ) = adv ( 1 ) + dqnie ( 1 ) / 2. * u_z_initial ( n ) adv ( 2 ) = (( v_perturbed_new ( l , m + 1 , n ) + v_perturbed_new ( l , m , n )) * ( snow_base ( l , m + 1 , n ) + snow_base ( l , m , n )) - & ( v_perturbed_new ( l , m - 1 , n ) + v_perturbed_new ( l , m , n )) * ( snow_base ( l , m - 1 , n ) + snow_base ( l , m , n ))) / 4. adv ( 2 ) = adv ( 2 ) + dqnie ( 2 ) / 2. * v_z_initial ( n ) advnie2 ( l , m ) = ( w_perturbed_new ( l , m , n ) + w_perturbed_new ( l , m , n + 1 )) * & ( snow_base ( l , m , n ) + snow_base ( l , m , n + 1 )) / 4. adv ( 3 ) = advnie2 ( l , m ) - advnie1 ( l , m ) advec = - ( adv ( 1 ) + adv ( 2 ) + adv ( 3 )) escal = dqnie ( 1 ) * KM1 + dqnie ( 2 ) * KM2 + dqnie ( 3 ) * KM3 lapla = snow_base ( l + 1 , m , n ) + snow_base ( l , m + 1 , n ) + snow_base ( l , m , n + 1 ) + & snow_base ( l - 1 , m , n ) + snow_base ( l , m - 1 , n ) + snow_base ( l , m , n - 1 ) - & 6. * snow_base ( l , m , n ) turbul = cteturb * ( escal / dx8 + KMM / dx2 * lapla ) !***  termino de sedimentacion Qnies = ( snow_base ( l , m , n + 1 ) + snow_base ( l , m , n )) / 2. Qniei = ( snow_base ( l , m , n - 1 ) + snow_base ( l , m , n )) / 2. sedim = Vtnie ( 2 * n + 1 ) * Qnies - Vtnie ( 2 * n - 1 ) * Qniei snow_new ( l , m , n ) = dt1 * (( advec + sedim ) / dx1 + turbul ) + snow_base ( l , m , n ) return end subroutine dnieve subroutine dgrani ( l , m , n ) use cant01 use dimensions use dinamic_var_perturbation use microphysics_perturbation use constants use initial_z_state use advecs use turbvar use dgrani_vars implicit none integer , intent ( in ) :: l , m , n dqgra ( 1 ) = hail_base ( l + 1 , m , n ) - hail_base ( l - 1 , m , n ) dqgra ( 2 ) = hail_base ( l , m + 1 , n ) - hail_base ( l , m - 1 , n ) dqgra ( 3 ) = hail_base ( l , m , n + 1 ) - hail_base ( l , m , n - 1 ) adv ( 1 ) = (( u_perturbed_new ( l + 1 , m , n ) + u_perturbed_new ( l , m , n )) * ( hail_base ( l + 1 , m , n ) + hail_base ( l , m , n )) & - ( u_perturbed_new ( l - 1 , m , n ) + u_perturbed_new ( l , m , n )) * ( hail_base ( l - 1 , m , n ) + hail_base ( l , m , n ))) / 4. adv ( 1 ) = adv ( 1 ) + dqgra ( 1 ) / 2. * u_z_initial ( n ) adv ( 2 ) = (( v_perturbed_new ( l , m + 1 , n ) + v_perturbed_new ( l , m , n )) * ( hail_base ( l , m + 1 , n ) + hail_base ( l , m , n )) - & ( v_perturbed_new ( l , m - 1 , n ) + v_perturbed_new ( l , m , n )) * ( hail_base ( l , m - 1 , n ) + hail_base ( l , m , n ))) / 4. adv ( 2 ) = adv ( 2 ) + dqgra ( 2 ) / 2. * v_z_initial ( n ) advgra2 ( l , m ) = ( w_perturbed_new ( l , m , n ) + w_perturbed_new ( l , m , n + 1 )) * & ( hail_base ( l , m , n ) + hail_base ( l , m , n + 1 )) / 4. adv ( 3 ) = advgra2 ( l , m ) - advgra1 ( l , m ) advec = - ( adv ( 1 ) + adv ( 2 ) + adv ( 3 )) escal = dqgra ( 1 ) * KM1 + dqgra ( 2 ) * KM2 + dqgra ( 3 ) * KM3 lapla = hail_base ( l + 1 , m , n ) + hail_base ( l , m + 1 , n ) + hail_base ( l , m , n + 1 ) + & hail_base ( l - 1 , m , n ) + hail_base ( l , m - 1 , n ) + hail_base ( l , m , n - 1 ) - & 6. * hail_base ( l , m , n ) turbul = cteturb * ( escal / dx8 + KMM / dx2 * lapla ) !***  termino de sedimentacion Qgras = ( hail_base ( l , m , n + 1 ) + hail_base ( l , m , n )) / 2. Qgrai = ( hail_base ( l , m , n - 1 ) + hail_base ( l , m , n )) / 2. Rms = ( Qgras / cteqgra ) ** . 25 Rmm = ( hail_base ( l , m , n ) / cteqgra ) ** . 25 Rmi = ( Qgrai / cteqgra ) ** . 25 Vtgras = ( Vtgra0 ( 2 * n + 1 ) * Rms ** . 8 + Vtgra0 ( 2 * n ) * Rmm ** . 8 ) / 2. Vtgrai = ( Vtgra0 ( 2 * n - 1 ) * Rmi ** . 8 + Vtgra0 ( 2 * n ) * Rmm ** . 8 ) / 2. if ( n == 1 ) then Vtgrai = Vtgra0 ( 2 * n ) * Rmm ** . 8 Qgrai = hail_base ( l , m , n ) end if sedim = gam4p8 / 6. * ( Qgras * Vtgras - Qgrai * Vtgrai ) !*** hail_new ( l , m , n ) = dt1 * (( advec + sedim ) / dx1 + turbul ) + hail_base ( l , m , n ) return end subroutine dgrani subroutine daeros ( l , m , n ) use cant01 use dimensions use dinamic_var_perturbation use microphysics_perturbation use constants use initial_z_state use advecs use turbvar use daeros_vars implicit none integer , intent ( in ) :: l , m , n daer ( 1 ) = aerosol_base ( l + 1 , m , n ) - aerosol_base ( l - 1 , m , n ) daer ( 2 ) = aerosol_base ( l , m + 1 , n ) - aerosol_base ( l , m - 1 , n ) daer ( 3 ) = aerosol_base ( l , m , n + 1 ) - aerosol_base ( l , m , n - 1 ) adv ( 1 ) = ((( u_perturbed_new ( l + 1 , m , n ) + u_perturbed_new ( l , m , n )) * ( aerosol_base ( l + 1 , m , n ) + aerosol_base ( l , m , n ))) - & (( u_perturbed_new ( l - 1 , m , n ) + u_perturbed_new ( l , m , n )) * ( aerosol_base ( l - 1 , m , n ) + aerosol_base ( l , m , n )))) / 4. adv ( 1 ) = adv ( 1 ) + daer ( 1 ) / 2. * u_z_initial ( n ) adv ( 2 ) = ((( v_perturbed_new ( l , m + 1 , n ) & + v_perturbed_new ( l , m , n )) * ( aerosol_base ( l , m + 1 , n ) & + aerosol_base ( l , m , n ))) & - (( v_perturbed_new ( l , m - 1 , n ) & + v_perturbed_new ( l , m , n )) * ( aerosol_base ( l , m - 1 , n ) & + aerosol_base ( l , m , n )))) / 4. adv ( 2 ) = adv ( 2 ) + daer ( 2 ) / 2. * v_z_initial ( n ) advaer2 ( l , m ) = ( w_perturbed_new ( l , m , n ) + w_perturbed_new ( l , m , n + 1 )) * & ( aerosol_base ( l , m , n ) + aerosol_base ( l , m , n + 1 )) / 4. adv ( 3 ) = advaer2 ( l , m ) - advaer1 ( l , m ) advec = - ( adv ( 1 ) + adv ( 2 ) + adv ( 3 )) verti = - (( w_perturbed_new ( l , m , n + 1 ) + w_perturbed_new ( l , m , n )) * ( aerosol_z_initial ( n + 1 ) + aerosol_z_initial ( n )) - & ( w_perturbed_new ( l , m , n - 1 ) + w_perturbed_new ( l , m , n )) * ( aerosol_z_initial ( n - 1 ) + aerosol_z_initial ( n ))) / 4. aux = - (( u_perturbed_new ( l + 1 , m , n ) - u_perturbed_new ( l - 1 , m , n )) & + ( v_perturbed_new ( l , m + 1 , n ) - v_perturbed_new ( l , m - 1 , n ))) * & aerosol_z_initial ( n ) / 2. escal = daer ( 1 ) * KM1 + daer ( 2 ) * KM2 + daer ( 3 ) * KM3 lapla = aerosol_base ( l + 1 , m , n ) + aerosol_base ( l , m + 1 , n ) + aerosol_base ( l , m , n + 1 ) + & aerosol_base ( l - 1 , m , n ) + aerosol_base ( l , m - 1 , n ) + aerosol_base ( l , m , n - 1 ) - & 6. * aerosol_base ( l , m , n ) lapla = (( aerosol_base ( l + 1 , m , n ) + aerosol_base ( l - 1 , m , n )) & + ( aerosol_base ( l , m + 1 , n ) + aerosol_base ( l , m - 1 , n ))) & + aerosol_base ( l , m , n - 1 ) + aerosol_base ( l , m , n + 1 ) & - 6. * aerosol_base ( l , m , n ) lapla = lapla + ( aerosol_z_initial ( n + 1 ) + aerosol_z_initial ( n - 1 ) - 2. * aerosol_z_initial ( n )) turbul = cteturb * ( escal / dx8 + KMM / dx2 * lapla ) aerosol_new ( l , m , n ) = dt1 * (( advec + verti + aux ) / dx1 + turbul ) + aerosol_base ( l , m , n ) return end subroutine daeros subroutine corgot !! Esta subrutina corrige los lugares en donde la dinamica da !! negativa la cantidad de gotitas use dimensions use microphysics_perturbation use lmngot use corgot_vars implicit none neg1 = 0. pos1 = 0. do concurrent ( n = ngot ( 1 ): ngot ( 2 ), l = lgot ( 1 ): lgot ( 2 ), m = mgot ( 1 ): mgot ( 2 )) if ( drop_new ( l , m , n ) < 0. ) then neg1 = neg1 + drop_new ( l , m , n ) drop_new ( l , m , n ) = 0 else pos1 = pos1 + drop_new ( l , m , n ) end if end do if ( pos1 <= - neg1 ) then do concurrent ( l = lgot ( 1 ): lgot ( 2 ), m = mgot ( 1 ): mgot ( 2 ), n = ngot ( 1 ): ngot ( 2 )) drop_new ( l , m , n ) = 0. end do else aux1 = neg1 / pos1 do concurrent ( l = lgot ( 1 ): lgot ( 2 ), m = mgot ( 1 ): mgot ( 2 ), n = ngot ( 1 ): ngot ( 2 )) if ( drop_new ( l , m , n ) > 0 ) then drop_new ( l , m , n ) = drop_new ( l , m , n ) * ( 1. + aux1 ) end if end do end if return end subroutine corgot subroutine corllu !! Esta subrutina corrige los lugares en donde la dinamica da !! negativa la cantidad de gotas use dimensions use microphysics_perturbation use lmnllu use corgot_vars implicit none neg1 = 0. pos1 = 0. do concurrent ( n = nllu ( 1 ): nllu ( 2 ), l = lllu ( 1 ): lllu ( 2 ), m = mllu ( 1 ): mllu ( 2 )) if ( rain_new ( l , m , n ) < 0. ) then neg1 = neg1 + rain_new ( l , m , n ) rain_new ( l , m , n ) = 0 else pos1 = pos1 + rain_new ( l , m , n ) end if end do if ( pos1 <= - neg1 ) then do concurrent ( l = lllu ( 1 ): lllu ( 2 ), m = mllu ( 1 ): mllu ( 2 ), n = nllu ( 1 ): nllu ( 2 )) rain_new ( l , m , n ) = 0. end do else aux1 = neg1 / pos1 do concurrent ( l = lllu ( 1 ): lllu ( 2 ), m = mllu ( 1 ): mllu ( 2 ), n = nllu ( 1 ): nllu ( 2 )) if ( rain_new ( l , m , n ) > 0 ) then rain_new ( l , m , n ) = rain_new ( l , m , n ) * ( 1. + aux1 ) end if end do end if return end subroutine corllu subroutine corcri !! Esta subrutina corrige los lugares en donde la dinamica da !! negativa la cantidad de cristales use dimensions use microphysics_perturbation use lmncri use corgot_vars implicit none neg1 = 0. pos1 = 0. do concurrent ( n = ncri ( 1 ): ncri ( 2 ), l = lcri ( 1 ): lcri ( 2 ), m = mcri ( 1 ): mcri ( 2 )) if ( crystal_new ( l , m , n ) < 0. ) then neg1 = neg1 + crystal_new ( l , m , n ) crystal_new ( l , m , n ) = 0 else pos1 = pos1 + crystal_new ( l , m , n ) end if end do if ( pos1 <= - neg1 ) then do concurrent ( l = lcri ( 1 ): lcri ( 2 ), m = mcri ( 1 ): mcri ( 2 ), n = ncri ( 1 ): ncri ( 2 )) crystal_new ( l , m , n ) = 0. end do else aux1 = neg1 / pos1 do concurrent ( l = lcri ( 1 ): lcri ( 2 ), m = mcri ( 1 ): mcri ( 2 ), n = ncri ( 1 ): ncri ( 2 )) if ( crystal_new ( l , m , n ) > 0 ) then crystal_new ( l , m , n ) = crystal_new ( l , m , n ) * ( 1. + aux1 ) end if end do end if return end subroutine corcri subroutine cornie !! Esta subrutina corrige los lugares en donde la dinamica da !! negativa la cantidad de nieve use dimensions use microphysics_perturbation use lmnnie use corgot_vars implicit none neg1 = 0. pos1 = 0. do concurrent ( n = nnie ( 1 ): nnie ( 2 ), l = lnie ( 1 ): lnie ( 2 ), m = mnie ( 1 ): mnie ( 2 )) if ( snow_new ( l , m , n ) < 0. ) then neg1 = neg1 + snow_new ( l , m , n ) snow_new ( l , m , n ) = 0 else pos1 = pos1 + snow_new ( l , m , n ) end if end do if ( pos1 <= - neg1 ) then do concurrent ( l = lnie ( 1 ): lnie ( 2 ), m = mnie ( 1 ): mnie ( 2 ), n = nnie ( 1 ): nnie ( 2 )) snow_new ( l , m , n ) = 0. end do else aux1 = neg1 / pos1 do concurrent ( l = lnie ( 1 ): lnie ( 2 ), m = mnie ( 1 ): mnie ( 2 ), n = nnie ( 1 ): nnie ( 2 )) if ( snow_new ( l , m , n ) > 0 ) then snow_new ( l , m , n ) = snow_new ( l , m , n ) * ( 1. + aux1 ) end if end do end if return end subroutine cornie subroutine corgra !! Esta subrutina corrige los lugares en donde la dinamica da !! negativa la cantidad de granizos use dimensions use microphysics_perturbation use lmngra use corgot_vars implicit none neg1 = 0. pos1 = 0. do concurrent ( n = ngra ( 1 ): ngra ( 2 ), l = lgra ( 1 ): lgra ( 2 ), m = mgra ( 1 ): mgra ( 2 )) if ( hail_new ( l , m , n ) < 0. ) then neg1 = neg1 + hail_new ( l , m , n ) hail_new ( l , m , n ) = 0 else pos1 = pos1 + hail_new ( l , m , n ) end if end do if ( pos1 <= - neg1 ) then do concurrent ( l = lgra ( 1 ): lgra ( 2 ), m = mgra ( 1 ): mgra ( 2 ), n = ngra ( 1 ): ngra ( 2 )) hail_new ( l , m , n ) = 0. end do else aux1 = neg1 / pos1 do concurrent ( l = lgra ( 1 ): lgra ( 2 ), m = mgra ( 1 ): mgra ( 2 ), n = ngra ( 1 ): ngra ( 2 )) if ( hail_new ( l , m , n ) > 0 ) then hail_new ( l , m , n ) = hail_new ( l , m , n ) * ( 1. + aux1 ) end if end do end if return end subroutine corgra subroutine corvap ( Qvapneg ) !! Esta subrutina corrige los lugares en donde la dinamica da !! negativa la cantidad de vapor use dimensions use microphysics_perturbation use initial_z_state use corvap_vars implicit none real ( 8 ), intent ( in ) :: Qvapneg do concurrent ( k = 1 : nz1 ) dq = Qvapneg * vapor_z_relative ( k ) / nx1 ** 2. do concurrent ( i = 1 : nx1 , j = 1 : nx1 ) vapor_new ( i , j , k ) = vapor_new ( i , j , k ) + dq if ( vapor_new ( i , j , k ) + vapor_z_initial ( k ) < 0 ) vapor_new ( i , j , k ) = - vapor_z_initial ( k ) end do end do return end subroutine corvap subroutine coraer ( aerneg ) !! Esta subrutina corrige los lugares en donde la dinamica da !! negativa la cantidad de aerosoles use dimensions use microphysics_perturbation use initial_z_state use coraer_vars implicit none real ( 8 ), intent ( in ) :: aerneg do concurrent ( k = 1 : nz1 ) dq = aerneg * aerosol_z_relative ( k ) / nx1 ** 2. do concurrent ( i = 1 : nx1 , j = 1 : nx1 ) aerosol_new ( i , j , k ) = aerosol_new ( i , j , k ) + dq if ( aerosol_new ( i , j , k ) + aerosol_z_initial ( k ) < 0 ) aerosol_new ( i , j , k ) = - aerosol_z_initial ( k ) end do end do return end subroutine coraer subroutine suma ( sum , a1 , a2 , a3 ) implicit none real a1 , a2 , a3 , sum , aux integer j do concurrent ( j = 1 : 2 ) if ( a1 > a2 ) then aux = a1 a1 = a2 a2 = aux end if if ( a2 > a3 ) then aux = a2 a2 = a3 a3 = aux end if end do sum = ( a1 + a2 ) + a3 return end subroutine suma subroutine nuclea ( Qvap , Qliq , Naer , TT , rhoa , e1 , esl , ess , rl , rs , Lvl , Lvs , Naux , auxl , auxs ) use cant01 use dimensions use constants use nuclea61 implicit none real , intent ( in ) :: Naer , rhoa , rs , Lvl , Lvs real , intent ( inout ) :: Qliq , Qvap , TT , e1 , esl , ess , rl real , intent ( inout ) :: Naux , auxl , auxs !     Numero de aesosoles B = Lvl / Rv auxl = 0. auxs = 0. Naux = 0. Rcri = 5e-5 if ( TT < T0 ) Rcri = Rcri - 4e-5 * ( T0 - TT ) / 4 0. if ( Rcri < 1e-5 ) Rcri = 1e-5 !     nucleacion sobre cristales Tc = T0 - TT if ( Tc > 0 . and . rs > 0 . and . Naer > 0 ) then mcri = pi * Rcri ** 3. / 1 0. * rhocri Naux = Acri * exp ( Bcri * Tc ) if ( Naux > . 9 ) Naux = . 9 Naux = Naux * Naer * 1e6 ! en m3 auxs = Naux * mcri if ( auxs > ( Qvap - ess / Rv / TT * . 95 )) then auxs = ( Qvap - ess / Rv / TT ) * . 95 Naux = auxs / mcri ! en m3 end if Qvap = Qvap - auxs TT1 = TT TT2 = TT + ( auxs * Lvs ) / ( Cp * rhoa ) TT = TT2 e1 = Qvap * Rv * TT esl = esl * exp ( B * ( TT2 - TT1 ) / TT2 / TT1 ) ess = ess * exp ( B * ( TT2 - TT1 ) / TT2 / TT1 ) Naux = - Naux / 1e6 ! en cm3 end if !     nucleacion sobre gotitas if ( e1 > esl ) then s = 0 hhh = 0 xxx = 0 TT1 = TT Ti = TT ei = e1 esli = esl auxl = 0. caux = B * esli / Ti !TODO: Check this loop 10 continue F0 = Lvl / Rv * ( esl / TT1 - ei / Ti ) + Cp * rhoa * ( TT1 - Ti ) F0p = Cp * rhoa + B / TT1 ** 2. * caux TT2 = TT1 - F0 / F0p auxl = ( ei / Ti - esl / TT2 ) / Rv Qliq1 = Qliq + auxl e1 = esl if ( Qliq1 < 0 ) then Qliq1 = 0. auxl = - Qliq TT2 = esl / ( e1 / TT1 - auxl * Rv ) e1 = ( Qvap - auxl ) * Rv * TT2 hhh = 1 end if s = 1 esl = esl * exp ( B * ( TT2 - TT1 ) / TT2 / TT1 ) TT1 = TT2 rl = abs ( e1 - esl ) / esl xxx = xxx + 1 if ( rl > 1e-3 . and . hhh == 0 ) goto 10 Qvap = Qvap - auxl Qliq = Qliq + auxl !* !      variacion en los aerosoles !      considerando que las nuevas gotitas tienen un radio Rgotmin Naux = Naux - auxl / ( 4. / 3. * pi * rhow * Rgotmin ** 3. ) / 1e6 TT = TT2 end if return end subroutine nuclea end module extra_subrut","tags":"","loc":"sourcefile/aux_subrut.f90.html"},{"title":"text_handling.f90 – cloud_model","text":"Source Code module io !! I/O related procedures implicit none interface str module procedure :: str_gen end interface contains function str_gen ( int_in ) result ( str_out ) integer , intent ( in ) :: int_in character ( len = 3 ) :: str_out_mid character ( len = 4 ) :: str_out str_out_mid = str_gen_aux ( int_in ) if ( int_in < 10 ) then str_out = '0' // str_out_mid else str_out = str_out_mid end if end function str_gen function str_gen_aux ( int_in ) result ( str_out ) class ( * ), intent ( in ) :: int_in character ( len = 99 ) :: str_mid character ( len = 3 ) :: str_out select type ( int_in ) type is ( real ) write ( str_mid , * ) int_in type is ( integer ) write ( str_mid , * ) int_in end select str_out = trim ( adjustl ( str_mid )) end function str_gen_aux end module io","tags":"","loc":"sourcefile/text_handling.f90.html"}]}